var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n2, m4) {
  for (var i3 = 0; i3 < m4.length; i3++) {
    const e3 = m4[i3];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k3 in e3) {
        if (k3 !== "default" && !(k3 in n2)) {
          const d4 = Object.getOwnPropertyDescriptor(e3, k3);
          if (d4) {
            Object.defineProperty(n2, k3, d4.get ? d4 : {
              enumerable: true,
              get: () => e3[k3]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a4 = function a5() {
      if (this instanceof a5) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a4.prototype = f2.prototype;
  } else
    a4 = {};
  Object.defineProperty(a4, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k3) {
    var d4 = Object.getOwnPropertyDescriptor(n2, k3);
    Object.defineProperty(a4, k3, d4.get ? d4 : {
      enumerable: true,
      get: function() {
        return n2[k3];
      }
    });
  });
  return a4;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$8 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$7 = Symbol.for("react.provider"), u$6 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$5 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$3(a4) {
  if (null === a4 || "object" !== typeof a4)
    return null;
  a4 = z$2 && a4[z$2] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$3 = {};
function E$2(a4, b3, e3) {
  this.props = a4;
  this.context = b3;
  this.refs = D$3;
  this.updater = e3 || B$2;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a4, b3) {
  if ("object" !== typeof a4 && "function" !== typeof a4 && null != a4)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a4, b3, "setState");
};
E$2.prototype.forceUpdate = function(a4) {
  this.updater.enqueueForceUpdate(this, a4, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$2.prototype;
function G$2(a4, b3, e3) {
  this.props = a4;
  this.context = b3;
  this.refs = D$3;
  this.updater = e3 || B$2;
}
var H$3 = G$2.prototype = new F$1();
H$3.constructor = G$2;
C$2(H$3, E$2.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$3(a4, b3, e3) {
  var d4, c3 = {}, k3 = null, h4 = null;
  if (null != b3)
    for (d4 in void 0 !== b3.ref && (h4 = b3.ref), void 0 !== b3.key && (k3 = "" + b3.key), b3)
      J.call(b3, d4) && !L$1.hasOwnProperty(d4) && (c3[d4] = b3[d4]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c3.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m4 = 0; m4 < g2; m4++)
      f2[m4] = arguments[m4 + 2];
    c3.children = f2;
  }
  if (a4 && a4.defaultProps)
    for (d4 in g2 = a4.defaultProps, g2)
      void 0 === c3[d4] && (c3[d4] = g2[d4]);
  return { $$typeof: l$7, type: a4, key: k3, ref: h4, props: c3, _owner: K$1.current };
}
function N$2(a4, b3) {
  return { $$typeof: l$7, type: a4.type, key: b3, ref: a4.ref, props: a4.props, _owner: a4._owner };
}
function O$1(a4) {
  return "object" === typeof a4 && null !== a4 && a4.$$typeof === l$7;
}
function escape$1(a4) {
  var b3 = { "=": "=0", ":": "=2" };
  return "$" + a4.replace(/[=:]/g, function(a5) {
    return b3[a5];
  });
}
var P$1 = /\/+/g;
function Q$1(a4, b3) {
  return "object" === typeof a4 && null !== a4 && null != a4.key ? escape$1("" + a4.key) : b3.toString(36);
}
function R$2(a4, b3, e3, d4, c3) {
  var k3 = typeof a4;
  if ("undefined" === k3 || "boolean" === k3)
    a4 = null;
  var h4 = false;
  if (null === a4)
    h4 = true;
  else
    switch (k3) {
      case "string":
      case "number":
        h4 = true;
        break;
      case "object":
        switch (a4.$$typeof) {
          case l$7:
          case n$5:
            h4 = true;
        }
    }
  if (h4)
    return h4 = a4, c3 = c3(h4), a4 = "" === d4 ? "." + Q$1(h4, 0) : d4, I$3(c3) ? (e3 = "", null != a4 && (e3 = a4.replace(P$1, "$&/") + "/"), R$2(c3, b3, e3, "", function(a5) {
      return a5;
    })) : null != c3 && (O$1(c3) && (c3 = N$2(c3, e3 + (!c3.key || h4 && h4.key === c3.key ? "" : ("" + c3.key).replace(P$1, "$&/") + "/") + a4)), b3.push(c3)), 1;
  h4 = 0;
  d4 = "" === d4 ? "." : d4 + ":";
  if (I$3(a4))
    for (var g2 = 0; g2 < a4.length; g2++) {
      k3 = a4[g2];
      var f2 = d4 + Q$1(k3, g2);
      h4 += R$2(k3, b3, e3, f2, c3);
    }
  else if (f2 = A$3(a4), "function" === typeof f2)
    for (a4 = f2.call(a4), g2 = 0; !(k3 = a4.next()).done; )
      k3 = k3.value, f2 = d4 + Q$1(k3, g2++), h4 += R$2(k3, b3, e3, f2, c3);
  else if ("object" === k3)
    throw b3 = String(a4), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a4).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S$3(a4, b3, e3) {
  if (null == a4)
    return a4;
  var d4 = [], c3 = 0;
  R$2(a4, d4, "", "", function(a5) {
    return b3.call(e3, a5, c3++);
  });
  return d4;
}
function T$2(a4) {
  if (-1 === a4._status) {
    var b3 = a4._result;
    b3 = b3();
    b3.then(function(b4) {
      if (0 === a4._status || -1 === a4._status)
        a4._status = 1, a4._result = b4;
    }, function(b4) {
      if (0 === a4._status || -1 === a4._status)
        a4._status = 2, a4._result = b4;
    });
    -1 === a4._status && (a4._status = 0, a4._result = b3);
  }
  if (1 === a4._status)
    return a4._result.default;
  throw a4._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$3, forEach: function(a4, b3, e3) {
  S$3(a4, function() {
    b3.apply(this, arguments);
  }, e3);
}, count: function(a4) {
  var b3 = 0;
  S$3(a4, function() {
    b3++;
  });
  return b3;
}, toArray: function(a4) {
  return S$3(a4, function(a5) {
    return a5;
  }) || [];
}, only: function(a4) {
  if (!O$1(a4))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a4;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$8;
react_production_min.Profiler = r$6;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a4, b3, e3) {
  if (null === a4 || void 0 === a4)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a4 + ".");
  var d4 = C$2({}, a4.props), c3 = a4.key, k3 = a4.ref, h4 = a4._owner;
  if (null != b3) {
    void 0 !== b3.ref && (k3 = b3.ref, h4 = K$1.current);
    void 0 !== b3.key && (c3 = "" + b3.key);
    if (a4.type && a4.type.defaultProps)
      var g2 = a4.type.defaultProps;
    for (f2 in b3)
      J.call(b3, f2) && !L$1.hasOwnProperty(f2) && (d4[f2] = void 0 === b3[f2] && void 0 !== g2 ? g2[f2] : b3[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d4.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m4 = 0; m4 < f2; m4++)
      g2[m4] = arguments[m4 + 2];
    d4.children = g2;
  }
  return { $$typeof: l$7, type: a4.type, key: c3, ref: k3, props: d4, _owner: h4 };
};
react_production_min.createContext = function(a4) {
  a4 = { $$typeof: u$6, _currentValue: a4, _currentValue2: a4, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a4.Provider = { $$typeof: t$7, _context: a4 };
  return a4.Consumer = a4;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a4) {
  var b3 = M$3.bind(null, a4);
  b3.type = a4;
  return b3;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a4) {
  return { $$typeof: v$3, render: a4 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a4) {
  return { $$typeof: y$5, _payload: { _status: -1, _result: a4 }, _init: T$2 };
};
react_production_min.memo = function(a4, b3) {
  return { $$typeof: x$1, type: a4, compare: void 0 === b3 ? null : b3 };
};
react_production_min.startTransition = function(a4) {
  var b3 = V$1.transition;
  V$1.transition = {};
  try {
    a4();
  } finally {
    V$1.transition = b3;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a4, b3) {
  return U$1.current.useCallback(a4, b3);
};
react_production_min.useContext = function(a4) {
  return U$1.current.useContext(a4);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a4) {
  return U$1.current.useDeferredValue(a4);
};
react_production_min.useEffect = function(a4, b3) {
  return U$1.current.useEffect(a4, b3);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a4, b3, e3) {
  return U$1.current.useImperativeHandle(a4, b3, e3);
};
react_production_min.useInsertionEffect = function(a4, b3) {
  return U$1.current.useInsertionEffect(a4, b3);
};
react_production_min.useLayoutEffect = function(a4, b3) {
  return U$1.current.useLayoutEffect(a4, b3);
};
react_production_min.useMemo = function(a4, b3) {
  return U$1.current.useMemo(a4, b3);
};
react_production_min.useReducer = function(a4, b3, e3) {
  return U$1.current.useReducer(a4, b3, e3);
};
react_production_min.useRef = function(a4) {
  return U$1.current.useRef(a4);
};
react_production_min.useState = function(a4) {
  return U$1.current.useState(a4);
};
react_production_min.useSyncExternalStore = function(a4, b3, e3) {
  return U$1.current.useSyncExternalStore(a4, b3, e3);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const e$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$3 = reactExports, k$2 = Symbol.for("react.element"), l$6 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$4 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$7 = { key: true, ref: true, __self: true, __source: true };
function q$2(c3, a4, g2) {
  var b3, d4 = {}, e3 = null, h4 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a4.key && (e3 = "" + a4.key);
  void 0 !== a4.ref && (h4 = a4.ref);
  for (b3 in a4)
    m$3.call(a4, b3) && !p$7.hasOwnProperty(b3) && (d4[b3] = a4[b3]);
  if (c3 && c3.defaultProps)
    for (b3 in a4 = c3.defaultProps, a4)
      void 0 === d4[b3] && (d4[b3] = a4[b3]);
  return { $$typeof: k$2, type: c3, key: e3, ref: h4, props: d4, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$6;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a4, b3) {
    var c3 = a4.length;
    a4.push(b3);
    a:
      for (; 0 < c3; ) {
        var d4 = c3 - 1 >>> 1, e3 = a4[d4];
        if (0 < g2(e3, b3))
          a4[d4] = b3, a4[c3] = e3, c3 = d4;
        else
          break a;
      }
  }
  function h4(a4) {
    return 0 === a4.length ? null : a4[0];
  }
  function k3(a4) {
    if (0 === a4.length)
      return null;
    var b3 = a4[0], c3 = a4.pop();
    if (c3 !== b3) {
      a4[0] = c3;
      a:
        for (var d4 = 0, e3 = a4.length, w3 = e3 >>> 1; d4 < w3; ) {
          var m4 = 2 * (d4 + 1) - 1, C2 = a4[m4], n2 = m4 + 1, x2 = a4[n2];
          if (0 > g2(C2, c3))
            n2 < e3 && 0 > g2(x2, C2) ? (a4[d4] = x2, a4[n2] = c3, d4 = n2) : (a4[d4] = C2, a4[m4] = c3, d4 = m4);
          else if (n2 < e3 && 0 > g2(x2, c3))
            a4[d4] = x2, a4[n2] = c3, d4 = n2;
          else
            break a;
        }
    }
    return b3;
  }
  function g2(a4, b3) {
    var c3 = a4.sortIndex - b3.sortIndex;
    return 0 !== c3 ? c3 : a4.id - b3.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q3 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q3;
    };
  }
  var r3 = [], t4 = [], u3 = 1, v2 = null, y4 = 3, z3 = false, A2 = false, B3 = false, D3 = "function" === typeof setTimeout ? setTimeout : null, E3 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G3(a4) {
    for (var b3 = h4(t4); null !== b3; ) {
      if (null === b3.callback)
        k3(t4);
      else if (b3.startTime <= a4)
        k3(t4), b3.sortIndex = b3.expirationTime, f2(r3, b3);
      else
        break;
      b3 = h4(t4);
    }
  }
  function H4(a4) {
    B3 = false;
    G3(a4);
    if (!A2)
      if (null !== h4(r3))
        A2 = true, I3(J2);
      else {
        var b3 = h4(t4);
        null !== b3 && K3(H4, b3.startTime - a4);
      }
  }
  function J2(a4, b3) {
    A2 = false;
    B3 && (B3 = false, E3(L3), L3 = -1);
    z3 = true;
    var c3 = y4;
    try {
      G3(b3);
      for (v2 = h4(r3); null !== v2 && (!(v2.expirationTime > b3) || a4 && !M4()); ) {
        var d4 = v2.callback;
        if ("function" === typeof d4) {
          v2.callback = null;
          y4 = v2.priorityLevel;
          var e3 = d4(v2.expirationTime <= b3);
          b3 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h4(r3) && k3(r3);
          G3(b3);
        } else
          k3(r3);
        v2 = h4(r3);
      }
      if (null !== v2)
        var w3 = true;
      else {
        var m4 = h4(t4);
        null !== m4 && K3(H4, m4.startTime - b3);
        w3 = false;
      }
      return w3;
    } finally {
      v2 = null, y4 = c3, z3 = false;
    }
  }
  var N2 = false, O3 = null, L3 = -1, P2 = 5, Q3 = -1;
  function M4() {
    return exports.unstable_now() - Q3 < P2 ? false : true;
  }
  function R3() {
    if (null !== O3) {
      var a4 = exports.unstable_now();
      Q3 = a4;
      var b3 = true;
      try {
        b3 = O3(true, a4);
      } finally {
        b3 ? S4() : (N2 = false, O3 = null);
      }
    } else
      N2 = false;
  }
  var S4;
  if ("function" === typeof F2)
    S4 = function() {
      F2(R3);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T3 = new MessageChannel(), U2 = T3.port2;
    T3.port1.onmessage = R3;
    S4 = function() {
      U2.postMessage(null);
    };
  } else
    S4 = function() {
      D3(R3, 0);
    };
  function I3(a4) {
    O3 = a4;
    N2 || (N2 = true, S4());
  }
  function K3(a4, b3) {
    L3 = D3(function() {
      a4(exports.unstable_now());
    }, b3);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a4) {
    a4.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z3 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a4) {
    0 > a4 || 125 < a4 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a4 ? Math.floor(1e3 / a4) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y4;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h4(r3);
  };
  exports.unstable_next = function(a4) {
    switch (y4) {
      case 1:
      case 2:
      case 3:
        var b3 = 3;
        break;
      default:
        b3 = y4;
    }
    var c3 = y4;
    y4 = b3;
    try {
      return a4();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a4, b3) {
    switch (a4) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a4 = 3;
    }
    var c3 = y4;
    y4 = a4;
    try {
      return b3();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_scheduleCallback = function(a4, b3, c3) {
    var d4 = exports.unstable_now();
    "object" === typeof c3 && null !== c3 ? (c3 = c3.delay, c3 = "number" === typeof c3 && 0 < c3 ? d4 + c3 : d4) : c3 = d4;
    switch (a4) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c3 + e3;
    a4 = { id: u3++, callback: b3, priorityLevel: a4, startTime: c3, expirationTime: e3, sortIndex: -1 };
    c3 > d4 ? (a4.sortIndex = c3, f2(t4, a4), null === h4(r3) && a4 === h4(t4) && (B3 ? (E3(L3), L3 = -1) : B3 = true, K3(H4, c3 - d4))) : (a4.sortIndex = e3, f2(r3, a4), A2 || z3 || (A2 = true, I3(J2)));
    return a4;
  };
  exports.unstable_shouldYield = M4;
  exports.unstable_wrapCallback = function(a4) {
    var b3 = y4;
    return function() {
      var c3 = y4;
      y4 = b3;
      try {
        return a4.apply(this, arguments);
      } finally {
        y4 = c3;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$6(a4) {
  for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a4, c3 = 1; c3 < arguments.length; c3++)
    b3 += "&args[]=" + encodeURIComponent(arguments[c3]);
  return "Minified React error #" + a4 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a4, b3) {
  ha(a4, b3);
  ha(a4 + "Capture", b3);
}
function ha(a4, b3) {
  ea[a4] = b3;
  for (a4 = 0; a4 < b3.length; a4++)
    da.add(b3[a4]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a4) {
  if (ja.call(ma, a4))
    return true;
  if (ja.call(la, a4))
    return false;
  if (ka.test(a4))
    return ma[a4] = true;
  la[a4] = true;
  return false;
}
function pa(a4, b3, c3, d4) {
  if (null !== c3 && 0 === c3.type)
    return false;
  switch (typeof b3) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d4)
        return false;
      if (null !== c3)
        return !c3.acceptsBooleans;
      a4 = a4.toLowerCase().slice(0, 5);
      return "data-" !== a4 && "aria-" !== a4;
    default:
      return false;
  }
}
function qa(a4, b3, c3, d4) {
  if (null === b3 || "undefined" === typeof b3 || pa(a4, b3, c3, d4))
    return true;
  if (d4)
    return false;
  if (null !== c3)
    switch (c3.type) {
      case 3:
        return !b3;
      case 4:
        return false === b3;
      case 5:
        return isNaN(b3);
      case 6:
        return isNaN(b3) || 1 > b3;
    }
  return false;
}
function v$2(a4, b3, c3, d4, e3, f2, g2) {
  this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
  this.attributeName = d4;
  this.attributeNamespace = e3;
  this.mustUseProperty = c3;
  this.propertyName = a4;
  this.type = b3;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
  z$1[a4] = new v$2(a4, 0, false, a4, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
  var b3 = a4[0];
  z$1[b3] = new v$2(b3, 1, false, a4[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 2, false, a4.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 2, false, a4, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
  z$1[a4] = new v$2(a4, 3, false, a4.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 3, true, a4, null, false, false);
});
["capture", "download"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 4, false, a4, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 6, false, a4, null, false, false);
});
["rowSpan", "start"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 5, false, a4.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a4) {
  return a4[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
  var b3 = a4.replace(
    ra,
    sa
  );
  z$1[b3] = new v$2(b3, 1, false, a4, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
  var b3 = a4.replace(ra, sa);
  z$1[b3] = new v$2(b3, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
  var b3 = a4.replace(ra, sa);
  z$1[b3] = new v$2(b3, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 1, false, a4.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a4) {
  z$1[a4] = new v$2(a4, 1, false, a4.toLowerCase(), null, true, true);
});
function ta(a4, b3, c3, d4) {
  var e3 = z$1.hasOwnProperty(b3) ? z$1[b3] : null;
  if (null !== e3 ? 0 !== e3.type : d4 || !(2 < b3.length) || "o" !== b3[0] && "O" !== b3[0] || "n" !== b3[1] && "N" !== b3[1])
    qa(b3, c3, e3, d4) && (c3 = null), d4 || null === e3 ? oa(b3) && (null === c3 ? a4.removeAttribute(b3) : a4.setAttribute(b3, "" + c3)) : e3.mustUseProperty ? a4[e3.propertyName] = null === c3 ? 3 === e3.type ? false : "" : c3 : (b3 = e3.attributeName, d4 = e3.attributeNamespace, null === c3 ? a4.removeAttribute(b3) : (e3 = e3.type, c3 = 3 === e3 || 4 === e3 && true === c3 ? "" : "" + c3, d4 ? a4.setAttributeNS(d4, b3, c3) : a4.setAttribute(b3, c3)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a4) {
  if (null === a4 || "object" !== typeof a4)
    return null;
  a4 = Ja && a4[Ja] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var A$2 = Object.assign, La;
function Ma(a4) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c3) {
      var b3 = c3.stack.trim().match(/\n( *(at )?)/);
      La = b3 && b3[1] || "";
    }
  return "\n" + La + a4;
}
var Na = false;
function Oa(a4, b3) {
  if (!a4 || Na)
    return "";
  Na = true;
  var c3 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b3)
      if (b3 = function() {
        throw Error();
      }, Object.defineProperty(b3.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b3, []);
        } catch (l2) {
          var d4 = l2;
        }
        Reflect.construct(a4, [], b3);
      } else {
        try {
          b3.call();
        } catch (l2) {
          d4 = l2;
        }
        a4.call(b3.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d4 = l2;
      }
      a4();
    }
  } catch (l2) {
    if (l2 && d4 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d4.stack.split("\n"), g2 = e3.length - 1, h4 = f2.length - 1; 1 <= g2 && 0 <= h4 && e3[g2] !== f2[h4]; )
        h4--;
      for (; 1 <= g2 && 0 <= h4; g2--, h4--)
        if (e3[g2] !== f2[h4]) {
          if (1 !== g2 || 1 !== h4) {
            do
              if (g2--, h4--, 0 > h4 || e3[g2] !== f2[h4]) {
                var k3 = "\n" + e3[g2].replace(" at new ", " at ");
                a4.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a4.displayName));
                return k3;
              }
            while (1 <= g2 && 0 <= h4);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c3;
  }
  return (a4 = a4 ? a4.displayName || a4.name : "") ? Ma(a4) : "";
}
function Pa(a4) {
  switch (a4.tag) {
    case 5:
      return Ma(a4.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a4 = Oa(a4.type, false), a4;
    case 11:
      return a4 = Oa(a4.type.render, false), a4;
    case 1:
      return a4 = Oa(a4.type, true), a4;
    default:
      return "";
  }
}
function Qa(a4) {
  if (null == a4)
    return null;
  if ("function" === typeof a4)
    return a4.displayName || a4.name || null;
  if ("string" === typeof a4)
    return a4;
  switch (a4) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a4)
    switch (a4.$$typeof) {
      case Ca:
        return (a4.displayName || "Context") + ".Consumer";
      case Ba:
        return (a4._context.displayName || "Context") + ".Provider";
      case Da:
        var b3 = a4.render;
        a4 = a4.displayName;
        a4 || (a4 = b3.displayName || b3.name || "", a4 = "" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
        return a4;
      case Ga:
        return b3 = a4.displayName || null, null !== b3 ? b3 : Qa(a4.type) || "Memo";
      case Ha:
        b3 = a4._payload;
        a4 = a4._init;
        try {
          return Qa(a4(b3));
        } catch (c3) {
        }
    }
  return null;
}
function Ra(a4) {
  var b3 = a4.type;
  switch (a4.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b3.displayName || "Context") + ".Consumer";
    case 10:
      return (b3._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a4 = b3.render, a4 = a4.displayName || a4.name || "", b3.displayName || ("" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b3;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b3);
    case 8:
      return b3 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b3)
        return b3.displayName || b3.name || null;
      if ("string" === typeof b3)
        return b3;
  }
  return null;
}
function Sa(a4) {
  switch (typeof a4) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a4;
    case "object":
      return a4;
    default:
      return "";
  }
}
function Ta(a4) {
  var b3 = a4.type;
  return (a4 = a4.nodeName) && "input" === a4.toLowerCase() && ("checkbox" === b3 || "radio" === b3);
}
function Ua(a4) {
  var b3 = Ta(a4) ? "checked" : "value", c3 = Object.getOwnPropertyDescriptor(a4.constructor.prototype, b3), d4 = "" + a4[b3];
  if (!a4.hasOwnProperty(b3) && "undefined" !== typeof c3 && "function" === typeof c3.get && "function" === typeof c3.set) {
    var e3 = c3.get, f2 = c3.set;
    Object.defineProperty(a4, b3, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a5) {
      d4 = "" + a5;
      f2.call(this, a5);
    } });
    Object.defineProperty(a4, b3, { enumerable: c3.enumerable });
    return { getValue: function() {
      return d4;
    }, setValue: function(a5) {
      d4 = "" + a5;
    }, stopTracking: function() {
      a4._valueTracker = null;
      delete a4[b3];
    } };
  }
}
function Va(a4) {
  a4._valueTracker || (a4._valueTracker = Ua(a4));
}
function Wa(a4) {
  if (!a4)
    return false;
  var b3 = a4._valueTracker;
  if (!b3)
    return true;
  var c3 = b3.getValue();
  var d4 = "";
  a4 && (d4 = Ta(a4) ? a4.checked ? "true" : "false" : a4.value);
  a4 = d4;
  return a4 !== c3 ? (b3.setValue(a4), true) : false;
}
function Xa(a4) {
  a4 = a4 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a4)
    return null;
  try {
    return a4.activeElement || a4.body;
  } catch (b3) {
    return a4.body;
  }
}
function Ya(a4, b3) {
  var c3 = b3.checked;
  return A$2({}, b3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c3 ? c3 : a4._wrapperState.initialChecked });
}
function Za(a4, b3) {
  var c3 = null == b3.defaultValue ? "" : b3.defaultValue, d4 = null != b3.checked ? b3.checked : b3.defaultChecked;
  c3 = Sa(null != b3.value ? b3.value : c3);
  a4._wrapperState = { initialChecked: d4, initialValue: c3, controlled: "checkbox" === b3.type || "radio" === b3.type ? null != b3.checked : null != b3.value };
}
function ab(a4, b3) {
  b3 = b3.checked;
  null != b3 && ta(a4, "checked", b3, false);
}
function bb(a4, b3) {
  ab(a4, b3);
  var c3 = Sa(b3.value), d4 = b3.type;
  if (null != c3)
    if ("number" === d4) {
      if (0 === c3 && "" === a4.value || a4.value != c3)
        a4.value = "" + c3;
    } else
      a4.value !== "" + c3 && (a4.value = "" + c3);
  else if ("submit" === d4 || "reset" === d4) {
    a4.removeAttribute("value");
    return;
  }
  b3.hasOwnProperty("value") ? cb(a4, b3.type, c3) : b3.hasOwnProperty("defaultValue") && cb(a4, b3.type, Sa(b3.defaultValue));
  null == b3.checked && null != b3.defaultChecked && (a4.defaultChecked = !!b3.defaultChecked);
}
function db(a4, b3, c3) {
  if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
    var d4 = b3.type;
    if (!("submit" !== d4 && "reset" !== d4 || void 0 !== b3.value && null !== b3.value))
      return;
    b3 = "" + a4._wrapperState.initialValue;
    c3 || b3 === a4.value || (a4.value = b3);
    a4.defaultValue = b3;
  }
  c3 = a4.name;
  "" !== c3 && (a4.name = "");
  a4.defaultChecked = !!a4._wrapperState.initialChecked;
  "" !== c3 && (a4.name = c3);
}
function cb(a4, b3, c3) {
  if ("number" !== b3 || Xa(a4.ownerDocument) !== a4)
    null == c3 ? a4.defaultValue = "" + a4._wrapperState.initialValue : a4.defaultValue !== "" + c3 && (a4.defaultValue = "" + c3);
}
var eb = Array.isArray;
function fb(a4, b3, c3, d4) {
  a4 = a4.options;
  if (b3) {
    b3 = {};
    for (var e3 = 0; e3 < c3.length; e3++)
      b3["$" + c3[e3]] = true;
    for (c3 = 0; c3 < a4.length; c3++)
      e3 = b3.hasOwnProperty("$" + a4[c3].value), a4[c3].selected !== e3 && (a4[c3].selected = e3), e3 && d4 && (a4[c3].defaultSelected = true);
  } else {
    c3 = "" + Sa(c3);
    b3 = null;
    for (e3 = 0; e3 < a4.length; e3++) {
      if (a4[e3].value === c3) {
        a4[e3].selected = true;
        d4 && (a4[e3].defaultSelected = true);
        return;
      }
      null !== b3 || a4[e3].disabled || (b3 = a4[e3]);
    }
    null !== b3 && (b3.selected = true);
  }
}
function gb(a4, b3) {
  if (null != b3.dangerouslySetInnerHTML)
    throw Error(p$6(91));
  return A$2({}, b3, { value: void 0, defaultValue: void 0, children: "" + a4._wrapperState.initialValue });
}
function hb(a4, b3) {
  var c3 = b3.value;
  if (null == c3) {
    c3 = b3.children;
    b3 = b3.defaultValue;
    if (null != c3) {
      if (null != b3)
        throw Error(p$6(92));
      if (eb(c3)) {
        if (1 < c3.length)
          throw Error(p$6(93));
        c3 = c3[0];
      }
      b3 = c3;
    }
    null == b3 && (b3 = "");
    c3 = b3;
  }
  a4._wrapperState = { initialValue: Sa(c3) };
}
function ib(a4, b3) {
  var c3 = Sa(b3.value), d4 = Sa(b3.defaultValue);
  null != c3 && (c3 = "" + c3, c3 !== a4.value && (a4.value = c3), null == b3.defaultValue && a4.defaultValue !== c3 && (a4.defaultValue = c3));
  null != d4 && (a4.defaultValue = "" + d4);
}
function jb(a4) {
  var b3 = a4.textContent;
  b3 === a4._wrapperState.initialValue && "" !== b3 && null !== b3 && (a4.value = b3);
}
function kb(a4) {
  switch (a4) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a4, b3) {
  return null == a4 || "http://www.w3.org/1999/xhtml" === a4 ? kb(b3) : "http://www.w3.org/2000/svg" === a4 && "foreignObject" === b3 ? "http://www.w3.org/1999/xhtml" : a4;
}
var mb, nb = function(a4) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b3, c3, d4, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a4(b3, c3, d4, e3);
    });
  } : a4;
}(function(a4, b3) {
  if ("http://www.w3.org/2000/svg" !== a4.namespaceURI || "innerHTML" in a4)
    a4.innerHTML = b3;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
    for (b3 = mb.firstChild; a4.firstChild; )
      a4.removeChild(a4.firstChild);
    for (; b3.firstChild; )
      a4.appendChild(b3.firstChild);
  }
});
function ob(a4, b3) {
  if (b3) {
    var c3 = a4.firstChild;
    if (c3 && c3 === a4.lastChild && 3 === c3.nodeType) {
      c3.nodeValue = b3;
      return;
    }
  }
  a4.textContent = b3;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a4) {
  qb.forEach(function(b3) {
    b3 = b3 + a4.charAt(0).toUpperCase() + a4.substring(1);
    pb[b3] = pb[a4];
  });
});
function rb(a4, b3, c3) {
  return null == b3 || "boolean" === typeof b3 || "" === b3 ? "" : c3 || "number" !== typeof b3 || 0 === b3 || pb.hasOwnProperty(a4) && pb[a4] ? ("" + b3).trim() : b3 + "px";
}
function sb(a4, b3) {
  a4 = a4.style;
  for (var c3 in b3)
    if (b3.hasOwnProperty(c3)) {
      var d4 = 0 === c3.indexOf("--"), e3 = rb(c3, b3[c3], d4);
      "float" === c3 && (c3 = "cssFloat");
      d4 ? a4.setProperty(c3, e3) : a4[c3] = e3;
    }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a4, b3) {
  if (b3) {
    if (tb[a4] && (null != b3.children || null != b3.dangerouslySetInnerHTML))
      throw Error(p$6(137, a4));
    if (null != b3.dangerouslySetInnerHTML) {
      if (null != b3.children)
        throw Error(p$6(60));
      if ("object" !== typeof b3.dangerouslySetInnerHTML || !("__html" in b3.dangerouslySetInnerHTML))
        throw Error(p$6(61));
    }
    if (null != b3.style && "object" !== typeof b3.style)
      throw Error(p$6(62));
  }
}
function vb(a4, b3) {
  if (-1 === a4.indexOf("-"))
    return "string" === typeof b3.is;
  switch (a4) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a4) {
  a4 = a4.target || a4.srcElement || window;
  a4.correspondingUseElement && (a4 = a4.correspondingUseElement);
  return 3 === a4.nodeType ? a4.parentNode : a4;
}
var yb = null, zb = null, Ab = null;
function Bb(a4) {
  if (a4 = Cb(a4)) {
    if ("function" !== typeof yb)
      throw Error(p$6(280));
    var b3 = a4.stateNode;
    b3 && (b3 = Db(b3), yb(a4.stateNode, a4.type, b3));
  }
}
function Eb(a4) {
  zb ? Ab ? Ab.push(a4) : Ab = [a4] : zb = a4;
}
function Fb() {
  if (zb) {
    var a4 = zb, b3 = Ab;
    Ab = zb = null;
    Bb(a4);
    if (b3)
      for (a4 = 0; a4 < b3.length; a4++)
        Bb(b3[a4]);
  }
}
function Gb(a4, b3) {
  return a4(b3);
}
function Hb() {
}
var Ib = false;
function Jb(a4, b3, c3) {
  if (Ib)
    return a4(b3, c3);
  Ib = true;
  try {
    return Gb(a4, b3, c3);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a4, b3) {
  var c3 = a4.stateNode;
  if (null === c3)
    return null;
  var d4 = Db(c3);
  if (null === d4)
    return null;
  c3 = d4[b3];
  a:
    switch (b3) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d4 = !d4.disabled) || (a4 = a4.type, d4 = !("button" === a4 || "input" === a4 || "select" === a4 || "textarea" === a4));
        a4 = !d4;
        break a;
      default:
        a4 = false;
    }
  if (a4)
    return null;
  if (c3 && "function" !== typeof c3)
    throw Error(p$6(231, b3, typeof c3));
  return c3;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a4) {
    Lb = false;
  }
function Nb(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b3.apply(c3, l2);
  } catch (m4) {
    this.onError(m4);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a4) {
  Ob = true;
  Pb = a4;
} };
function Tb(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$6(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a4) {
  var b3 = a4, c3 = a4;
  if (a4.alternate)
    for (; b3.return; )
      b3 = b3.return;
  else {
    a4 = b3;
    do
      b3 = a4, 0 !== (b3.flags & 4098) && (c3 = b3.return), a4 = b3.return;
    while (a4);
  }
  return 3 === b3.tag ? c3 : null;
}
function Wb(a4) {
  if (13 === a4.tag) {
    var b3 = a4.memoizedState;
    null === b3 && (a4 = a4.alternate, null !== a4 && (b3 = a4.memoizedState));
    if (null !== b3)
      return b3.dehydrated;
  }
  return null;
}
function Xb(a4) {
  if (Vb(a4) !== a4)
    throw Error(p$6(188));
}
function Yb(a4) {
  var b3 = a4.alternate;
  if (!b3) {
    b3 = Vb(a4);
    if (null === b3)
      throw Error(p$6(188));
    return b3 !== a4 ? null : a4;
  }
  for (var c3 = a4, d4 = b3; ; ) {
    var e3 = c3.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d4 = e3.return;
      if (null !== d4) {
        c3 = d4;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c3)
          return Xb(e3), a4;
        if (f2 === d4)
          return Xb(e3), b3;
        f2 = f2.sibling;
      }
      throw Error(p$6(188));
    }
    if (c3.return !== d4.return)
      c3 = e3, d4 = f2;
    else {
      for (var g2 = false, h4 = e3.child; h4; ) {
        if (h4 === c3) {
          g2 = true;
          c3 = e3;
          d4 = f2;
          break;
        }
        if (h4 === d4) {
          g2 = true;
          d4 = e3;
          c3 = f2;
          break;
        }
        h4 = h4.sibling;
      }
      if (!g2) {
        for (h4 = f2.child; h4; ) {
          if (h4 === c3) {
            g2 = true;
            c3 = f2;
            d4 = e3;
            break;
          }
          if (h4 === d4) {
            g2 = true;
            d4 = f2;
            c3 = e3;
            break;
          }
          h4 = h4.sibling;
        }
        if (!g2)
          throw Error(p$6(189));
      }
    }
    if (c3.alternate !== d4)
      throw Error(p$6(190));
  }
  if (3 !== c3.tag)
    throw Error(p$6(188));
  return c3.stateNode.current === c3 ? a4 : b3;
}
function Zb(a4) {
  a4 = Yb(a4);
  return null !== a4 ? $b(a4) : null;
}
function $b(a4) {
  if (5 === a4.tag || 6 === a4.tag)
    return a4;
  for (a4 = a4.child; null !== a4; ) {
    var b3 = $b(a4);
    if (null !== b3)
      return b3;
    a4 = a4.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a4) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a4, void 0, 128 === (a4.current.flags & 128));
    } catch (b3) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a4) {
  a4 >>>= 0;
  return 0 === a4 ? 32 : 31 - (pc(a4) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a4) {
  switch (a4 & -a4) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a4 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a4 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a4;
  }
}
function uc(a4, b3) {
  var c3 = a4.pendingLanes;
  if (0 === c3)
    return 0;
  var d4 = 0, e3 = a4.suspendedLanes, f2 = a4.pingedLanes, g2 = c3 & 268435455;
  if (0 !== g2) {
    var h4 = g2 & ~e3;
    0 !== h4 ? d4 = tc(h4) : (f2 &= g2, 0 !== f2 && (d4 = tc(f2)));
  } else
    g2 = c3 & ~e3, 0 !== g2 ? d4 = tc(g2) : 0 !== f2 && (d4 = tc(f2));
  if (0 === d4)
    return 0;
  if (0 !== b3 && b3 !== d4 && 0 === (b3 & e3) && (e3 = d4 & -d4, f2 = b3 & -b3, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b3;
  0 !== (d4 & 4) && (d4 |= c3 & 16);
  b3 = a4.entangledLanes;
  if (0 !== b3)
    for (a4 = a4.entanglements, b3 &= d4; 0 < b3; )
      c3 = 31 - oc(b3), e3 = 1 << c3, d4 |= a4[c3], b3 &= ~e3;
  return d4;
}
function vc(a4, b3) {
  switch (a4) {
    case 1:
    case 2:
    case 4:
      return b3 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b3 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a4, b3) {
  for (var c3 = a4.suspendedLanes, d4 = a4.pingedLanes, e3 = a4.expirationTimes, f2 = a4.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h4 = 1 << g2, k3 = e3[g2];
    if (-1 === k3) {
      if (0 === (h4 & c3) || 0 !== (h4 & d4))
        e3[g2] = vc(h4, b3);
    } else
      k3 <= b3 && (a4.expiredLanes |= h4);
    f2 &= ~h4;
  }
}
function xc(a4) {
  a4 = a4.pendingLanes & -1073741825;
  return 0 !== a4 ? a4 : a4 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a4 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a4;
}
function zc(a4) {
  for (var b3 = [], c3 = 0; 31 > c3; c3++)
    b3.push(a4);
  return b3;
}
function Ac(a4, b3, c3) {
  a4.pendingLanes |= b3;
  536870912 !== b3 && (a4.suspendedLanes = 0, a4.pingedLanes = 0);
  a4 = a4.eventTimes;
  b3 = 31 - oc(b3);
  a4[b3] = c3;
}
function Bc(a4, b3) {
  var c3 = a4.pendingLanes & ~b3;
  a4.pendingLanes = b3;
  a4.suspendedLanes = 0;
  a4.pingedLanes = 0;
  a4.expiredLanes &= b3;
  a4.mutableReadLanes &= b3;
  a4.entangledLanes &= b3;
  b3 = a4.entanglements;
  var d4 = a4.eventTimes;
  for (a4 = a4.expirationTimes; 0 < c3; ) {
    var e3 = 31 - oc(c3), f2 = 1 << e3;
    b3[e3] = 0;
    d4[e3] = -1;
    a4[e3] = -1;
    c3 &= ~f2;
  }
}
function Cc(a4, b3) {
  var c3 = a4.entangledLanes |= b3;
  for (a4 = a4.entanglements; c3; ) {
    var d4 = 31 - oc(c3), e3 = 1 << d4;
    e3 & b3 | a4[d4] & b3 && (a4[d4] |= b3);
    c3 &= ~e3;
  }
}
var C$1 = 0;
function Dc(a4) {
  a4 &= -a4;
  return 1 < a4 ? 4 < a4 ? 0 !== (a4 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a4, b3) {
  switch (a4) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b3.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b3.pointerId);
  }
}
function Tc(a4, b3, c3, d4, e3, f2) {
  if (null === a4 || a4.nativeEvent !== f2)
    return a4 = { blockedOn: b3, domEventName: c3, eventSystemFlags: d4, nativeEvent: f2, targetContainers: [e3] }, null !== b3 && (b3 = Cb(b3), null !== b3 && Fc(b3)), a4;
  a4.eventSystemFlags |= d4;
  b3 = a4.targetContainers;
  null !== e3 && -1 === b3.indexOf(e3) && b3.push(e3);
  return a4;
}
function Uc(a4, b3, c3, d4, e3) {
  switch (b3) {
    case "focusin":
      return Lc = Tc(Lc, a4, b3, c3, d4, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a4, b3, c3, d4, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a4, b3, c3, d4, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a4, b3, c3, d4, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a4, b3, c3, d4, e3)), true;
  }
  return false;
}
function Vc(a4) {
  var b3 = Wc(a4.target);
  if (null !== b3) {
    var c3 = Vb(b3);
    if (null !== c3) {
      if (b3 = c3.tag, 13 === b3) {
        if (b3 = Wb(c3), null !== b3) {
          a4.blockedOn = b3;
          Ic(a4.priority, function() {
            Gc(c3);
          });
          return;
        }
      } else if (3 === b3 && c3.stateNode.current.memoizedState.isDehydrated) {
        a4.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a4.blockedOn = null;
}
function Xc(a4) {
  if (null !== a4.blockedOn)
    return false;
  for (var b3 = a4.targetContainers; 0 < b3.length; ) {
    var c3 = Yc(a4.domEventName, a4.eventSystemFlags, b3[0], a4.nativeEvent);
    if (null === c3) {
      c3 = a4.nativeEvent;
      var d4 = new c3.constructor(c3.type, c3);
      wb = d4;
      c3.target.dispatchEvent(d4);
      wb = null;
    } else
      return b3 = Cb(c3), null !== b3 && Fc(b3), a4.blockedOn = c3, false;
    b3.shift();
  }
  return true;
}
function Zc(a4, b3, c3) {
  Xc(a4) && c3.delete(b3);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a4, b3) {
  a4.blockedOn === b3 && (a4.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a4) {
  function b3(b4) {
    return ad(b4, a4);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a4);
    for (var c3 = 1; c3 < Kc.length; c3++) {
      var d4 = Kc[c3];
      d4.blockedOn === a4 && (d4.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a4);
  null !== Mc && ad(Mc, a4);
  null !== Nc && ad(Nc, a4);
  Oc.forEach(b3);
  Pc.forEach(b3);
  for (c3 = 0; c3 < Qc.length; c3++)
    d4 = Qc[c3], d4.blockedOn === a4 && (d4.blockedOn = null);
  for (; 0 < Qc.length && (c3 = Qc[0], null === c3.blockedOn); )
    Vc(c3), null === c3.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a4, b3, c3, d4) {
  var e3 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a4, b3, c3, d4);
  } finally {
    C$1 = e3, cd.transition = f2;
  }
}
function gd(a4, b3, c3, d4) {
  var e3 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a4, b3, c3, d4);
  } finally {
    C$1 = e3, cd.transition = f2;
  }
}
function fd(a4, b3, c3, d4) {
  if (dd) {
    var e3 = Yc(a4, b3, c3, d4);
    if (null === e3)
      hd(a4, b3, d4, id$2, c3), Sc(a4, d4);
    else if (Uc(e3, a4, b3, c3, d4))
      d4.stopPropagation();
    else if (Sc(a4, d4), b3 & 4 && -1 < Rc.indexOf(a4)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a4, b3, c3, d4);
        null === f2 && hd(a4, b3, d4, id$2, c3);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d4.stopPropagation();
    } else
      hd(a4, b3, d4, null, c3);
  }
}
var id$2 = null;
function Yc(a4, b3, c3, d4) {
  id$2 = null;
  a4 = xb(d4);
  a4 = Wc(a4);
  if (null !== a4)
    if (b3 = Vb(a4), null === b3)
      a4 = null;
    else if (c3 = b3.tag, 13 === c3) {
      a4 = Wb(b3);
      if (null !== a4)
        return a4;
      a4 = null;
    } else if (3 === c3) {
      if (b3.stateNode.current.memoizedState.isDehydrated)
        return 3 === b3.tag ? b3.stateNode.containerInfo : null;
      a4 = null;
    } else
      b3 !== a4 && (a4 = null);
  id$2 = a4;
  return null;
}
function jd(a4) {
  switch (a4) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a4, b3 = ld, c3 = b3.length, d4, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a4 = 0; a4 < c3 && b3[a4] === e3[a4]; a4++)
    ;
  var g2 = c3 - a4;
  for (d4 = 1; d4 <= g2 && b3[c3 - d4] === e3[f2 - d4]; d4++)
    ;
  return md = e3.slice(a4, 1 < d4 ? 1 - d4 : void 0);
}
function od(a4) {
  var b3 = a4.keyCode;
  "charCode" in a4 ? (a4 = a4.charCode, 0 === a4 && 13 === b3 && (a4 = 13)) : a4 = b3;
  10 === a4 && (a4 = 13);
  return 32 <= a4 || 13 === a4 ? a4 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a4) {
  function b3(b4, d4, e3, f2, g2) {
    this._reactName = b4;
    this._targetInst = e3;
    this.type = d4;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c3 in a4)
      a4.hasOwnProperty(c3) && (b4 = a4[c3], this[c3] = b4 ? b4(f2) : f2[c3]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b3.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a5 = this.nativeEvent;
    a5 && (a5.preventDefault ? a5.preventDefault() : "unknown" !== typeof a5.returnValue && (a5.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a5 = this.nativeEvent;
    a5 && (a5.stopPropagation ? a5.stopPropagation() : "unknown" !== typeof a5.cancelBubble && (a5.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b3;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a4) {
  return a4.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a4) {
  return void 0 === a4.relatedTarget ? a4.fromElement === a4.srcElement ? a4.toElement : a4.fromElement : a4.relatedTarget;
}, movementX: function(a4) {
  if ("movementX" in a4)
    return a4.movementX;
  a4 !== yd && (yd && "mousemove" === a4.type ? (wd = a4.screenX - yd.screenX, xd = a4.screenY - yd.screenY) : xd = wd = 0, yd = a4);
  return wd;
}, movementY: function(a4) {
  return "movementY" in a4 ? a4.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a4) {
  return "clipboardData" in a4 ? a4.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a4) {
  var b3 = this.nativeEvent;
  return b3.getModifierState ? b3.getModifierState(a4) : (a4 = Od[a4]) ? !!b3[a4] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a4) {
  if (a4.key) {
    var b3 = Md[a4.key] || a4.key;
    if ("Unidentified" !== b3)
      return b3;
  }
  return "keypress" === a4.type ? (a4 = od(a4), 13 === a4 ? "Enter" : String.fromCharCode(a4)) : "keydown" === a4.type || "keyup" === a4.type ? Nd[a4.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a4) {
  return "keypress" === a4.type ? od(a4) : 0;
}, keyCode: function(a4) {
  return "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
}, which: function(a4) {
  return "keypress" === a4.type ? od(a4) : "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a4) {
    return "deltaX" in a4 ? a4.deltaX : "wheelDeltaX" in a4 ? -a4.wheelDeltaX : 0;
  },
  deltaY: function(a4) {
    return "deltaY" in a4 ? a4.deltaY : "wheelDeltaY" in a4 ? -a4.wheelDeltaY : "wheelDelta" in a4 ? -a4.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe = false;
function ge(a4, b3) {
  switch (a4) {
    case "keyup":
      return -1 !== $d.indexOf(b3.keyCode);
    case "keydown":
      return 229 !== b3.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a4) {
  a4 = a4.detail;
  return "object" === typeof a4 && "data" in a4 ? a4.data : null;
}
var ie = false;
function je(a4, b3) {
  switch (a4) {
    case "compositionend":
      return he(b3);
    case "keypress":
      if (32 !== b3.which)
        return null;
      fe = true;
      return ee$1;
    case "textInput":
      return a4 = b3.data, a4 === ee$1 && fe ? null : a4;
    default:
      return null;
  }
}
function ke(a4, b3) {
  if (ie)
    return "compositionend" === a4 || !ae && ge(a4, b3) ? (a4 = nd(), md = ld = kd = null, ie = false, a4) : null;
  switch (a4) {
    case "paste":
      return null;
    case "keypress":
      if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
        if (b3.char && 1 < b3.char.length)
          return b3.char;
        if (b3.which)
          return String.fromCharCode(b3.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b3.locale ? null : b3.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a4) {
  var b3 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return "input" === b3 ? !!le[a4.type] : "textarea" === b3 ? true : false;
}
function ne$1(a4, b3, c3, d4) {
  Eb(d4);
  b3 = oe(b3, "onChange");
  0 < b3.length && (c3 = new td("onChange", "change", null, c3, d4), a4.push({ event: c3, listeners: b3 }));
}
var pe = null, qe = null;
function re$1(a4) {
  se(a4, 0);
}
function te$1(a4) {
  var b3 = ue(a4);
  if (Wa(b3))
    return a4;
}
function ve(a4, b3) {
  if ("change" === a4)
    return b3;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a4) {
  if ("value" === a4.propertyName && te$1(qe)) {
    var b3 = [];
    ne$1(b3, qe, a4, xb(a4));
    Jb(re$1, b3);
  }
}
function Ce(a4, b3, c3) {
  "focusin" === a4 ? (Ae(), pe = b3, qe = c3, pe.attachEvent("onpropertychange", Be)) : "focusout" === a4 && Ae();
}
function De(a4) {
  if ("selectionchange" === a4 || "keyup" === a4 || "keydown" === a4)
    return te$1(qe);
}
function Ee(a4, b3) {
  if ("click" === a4)
    return te$1(b3);
}
function Fe(a4, b3) {
  if ("input" === a4 || "change" === a4)
    return te$1(b3);
}
function Ge$1(a4, b3) {
  return a4 === b3 && (0 !== a4 || 1 / a4 === 1 / b3) || a4 !== a4 && b3 !== b3;
}
var He = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie(a4, b3) {
  if (He(a4, b3))
    return true;
  if ("object" !== typeof a4 || null === a4 || "object" !== typeof b3 || null === b3)
    return false;
  var c3 = Object.keys(a4), d4 = Object.keys(b3);
  if (c3.length !== d4.length)
    return false;
  for (d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    if (!ja.call(b3, e3) || !He(a4[e3], b3[e3]))
      return false;
  }
  return true;
}
function Je(a4) {
  for (; a4 && a4.firstChild; )
    a4 = a4.firstChild;
  return a4;
}
function Ke(a4, b3) {
  var c3 = Je(a4);
  a4 = 0;
  for (var d4; c3; ) {
    if (3 === c3.nodeType) {
      d4 = a4 + c3.textContent.length;
      if (a4 <= b3 && d4 >= b3)
        return { node: c3, offset: b3 - a4 };
      a4 = d4;
    }
    a: {
      for (; c3; ) {
        if (c3.nextSibling) {
          c3 = c3.nextSibling;
          break a;
        }
        c3 = c3.parentNode;
      }
      c3 = void 0;
    }
    c3 = Je(c3);
  }
}
function Le(a4, b3) {
  return a4 && b3 ? a4 === b3 ? true : a4 && 3 === a4.nodeType ? false : b3 && 3 === b3.nodeType ? Le(a4, b3.parentNode) : "contains" in a4 ? a4.contains(b3) : a4.compareDocumentPosition ? !!(a4.compareDocumentPosition(b3) & 16) : false : false;
}
function Me() {
  for (var a4 = window, b3 = Xa(); b3 instanceof a4.HTMLIFrameElement; ) {
    try {
      var c3 = "string" === typeof b3.contentWindow.location.href;
    } catch (d4) {
      c3 = false;
    }
    if (c3)
      a4 = b3.contentWindow;
    else
      break;
    b3 = Xa(a4.document);
  }
  return b3;
}
function Ne(a4) {
  var b3 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return b3 && ("input" === b3 && ("text" === a4.type || "search" === a4.type || "tel" === a4.type || "url" === a4.type || "password" === a4.type) || "textarea" === b3 || "true" === a4.contentEditable);
}
function Oe(a4) {
  var b3 = Me(), c3 = a4.focusedElem, d4 = a4.selectionRange;
  if (b3 !== c3 && c3 && c3.ownerDocument && Le(c3.ownerDocument.documentElement, c3)) {
    if (null !== d4 && Ne(c3)) {
      if (b3 = d4.start, a4 = d4.end, void 0 === a4 && (a4 = b3), "selectionStart" in c3)
        c3.selectionStart = b3, c3.selectionEnd = Math.min(a4, c3.value.length);
      else if (a4 = (b3 = c3.ownerDocument || document) && b3.defaultView || window, a4.getSelection) {
        a4 = a4.getSelection();
        var e3 = c3.textContent.length, f2 = Math.min(d4.start, e3);
        d4 = void 0 === d4.end ? f2 : Math.min(d4.end, e3);
        !a4.extend && f2 > d4 && (e3 = d4, d4 = f2, f2 = e3);
        e3 = Ke(c3, f2);
        var g2 = Ke(
          c3,
          d4
        );
        e3 && g2 && (1 !== a4.rangeCount || a4.anchorNode !== e3.node || a4.anchorOffset !== e3.offset || a4.focusNode !== g2.node || a4.focusOffset !== g2.offset) && (b3 = b3.createRange(), b3.setStart(e3.node, e3.offset), a4.removeAllRanges(), f2 > d4 ? (a4.addRange(b3), a4.extend(g2.node, g2.offset)) : (b3.setEnd(g2.node, g2.offset), a4.addRange(b3)));
      }
    }
    b3 = [];
    for (a4 = c3; a4 = a4.parentNode; )
      1 === a4.nodeType && b3.push({ element: a4, left: a4.scrollLeft, top: a4.scrollTop });
    "function" === typeof c3.focus && c3.focus();
    for (c3 = 0; c3 < b3.length; c3++)
      a4 = b3[c3], a4.element.scrollLeft = a4.left, a4.element.scrollTop = a4.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a4, b3, c3) {
  var d4 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument;
  Te || null == Qe || Qe !== Xa(d4) || (d4 = Qe, "selectionStart" in d4 && Ne(d4) ? d4 = { start: d4.selectionStart, end: d4.selectionEnd } : (d4 = (d4.ownerDocument && d4.ownerDocument.defaultView || window).getSelection(), d4 = { anchorNode: d4.anchorNode, anchorOffset: d4.anchorOffset, focusNode: d4.focusNode, focusOffset: d4.focusOffset }), Se && Ie(Se, d4) || (Se = d4, d4 = oe(Re, "onSelect"), 0 < d4.length && (b3 = new td("onSelect", "select", null, b3, c3), a4.push({ event: b3, listeners: d4 }), b3.target = Qe)));
}
function Ve(a4, b3) {
  var c3 = {};
  c3[a4.toLowerCase()] = b3.toLowerCase();
  c3["Webkit" + a4] = "webkit" + b3;
  c3["Moz" + a4] = "moz" + b3;
  return c3;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a4) {
  if (Xe[a4])
    return Xe[a4];
  if (!We[a4])
    return a4;
  var b3 = We[a4], c3;
  for (c3 in b3)
    if (b3.hasOwnProperty(c3) && c3 in Ye)
      return Xe[a4] = b3[c3];
  return a4;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a4, b3) {
  df.set(a4, b3);
  fa(b3, [a4]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a4, b3, c3) {
  var d4 = a4.type || "unknown-event";
  a4.currentTarget = c3;
  Ub(d4, b3, void 0, a4);
  a4.currentTarget = null;
}
function se(a4, b3) {
  b3 = 0 !== (b3 & 4);
  for (var c3 = 0; c3 < a4.length; c3++) {
    var d4 = a4[c3], e3 = d4.event;
    d4 = d4.listeners;
    a: {
      var f2 = void 0;
      if (b3)
        for (var g2 = d4.length - 1; 0 <= g2; g2--) {
          var h4 = d4[g2], k3 = h4.instance, l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k3 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h4, l2);
          f2 = k3;
        }
      else
        for (g2 = 0; g2 < d4.length; g2++) {
          h4 = d4[g2];
          k3 = h4.instance;
          l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k3 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h4, l2);
          f2 = k3;
        }
    }
  }
  if (Qb)
    throw a4 = Rb, Qb = false, Rb = null, a4;
}
function D$2(a4, b3) {
  var c3 = b3[of];
  void 0 === c3 && (c3 = b3[of] = /* @__PURE__ */ new Set());
  var d4 = a4 + "__bubble";
  c3.has(d4) || (pf(b3, a4, 2, false), c3.add(d4));
}
function qf(a4, b3, c3) {
  var d4 = 0;
  b3 && (d4 |= 4);
  pf(c3, a4, d4, b3);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a4) {
  if (!a4[rf]) {
    a4[rf] = true;
    da.forEach(function(b4) {
      "selectionchange" !== b4 && (mf.has(b4) || qf(b4, false, a4), qf(b4, true, a4));
    });
    var b3 = 9 === a4.nodeType ? a4 : a4.ownerDocument;
    null === b3 || b3[rf] || (b3[rf] = true, qf("selectionchange", false, b3));
  }
}
function pf(a4, b3, c3, d4) {
  switch (jd(b3)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c3 = e3.bind(null, b3, c3, a4);
  e3 = void 0;
  !Lb || "touchstart" !== b3 && "touchmove" !== b3 && "wheel" !== b3 || (e3 = true);
  d4 ? void 0 !== e3 ? a4.addEventListener(b3, c3, { capture: true, passive: e3 }) : a4.addEventListener(b3, c3, true) : void 0 !== e3 ? a4.addEventListener(b3, c3, { passive: e3 }) : a4.addEventListener(b3, c3, false);
}
function hd(a4, b3, c3, d4, e3) {
  var f2 = d4;
  if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d4)
    a:
      for (; ; ) {
        if (null === d4)
          return;
        var g2 = d4.tag;
        if (3 === g2 || 4 === g2) {
          var h4 = d4.stateNode.containerInfo;
          if (h4 === e3 || 8 === h4.nodeType && h4.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d4.return; null !== g2; ) {
              var k3 = g2.tag;
              if (3 === k3 || 4 === k3) {
                if (k3 = g2.stateNode.containerInfo, k3 === e3 || 8 === k3.nodeType && k3.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h4; ) {
            g2 = Wc(h4);
            if (null === g2)
              return;
            k3 = g2.tag;
            if (5 === k3 || 6 === k3) {
              d4 = f2 = g2;
              continue a;
            }
            h4 = h4.parentNode;
          }
        }
        d4 = d4.return;
      }
  Jb(function() {
    var d5 = f2, e4 = xb(c3), g3 = [];
    a: {
      var h5 = df.get(a4);
      if (void 0 !== h5) {
        var k4 = td, n2 = a4;
        switch (a4) {
          case "keypress":
            if (0 === od(c3))
              break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c3.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t4 = 0 !== (b3 & 4), J2 = !t4 && "scroll" === a4, x2 = t4 ? null !== h5 ? h5 + "Capture" : null : h5;
        t4 = [];
        for (var w3 = d5, u3; null !== w3; ) {
          u3 = w3;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x2 && (F2 = Kb(w3, x2), null != F2 && t4.push(tf(w3, F2, u3))));
          if (J2)
            break;
          w3 = w3.return;
        }
        0 < t4.length && (h5 = new k4(h5, n2, null, c3, e4), g3.push({ event: h5, listeners: t4 }));
      }
    }
    if (0 === (b3 & 7)) {
      a: {
        h5 = "mouseover" === a4 || "pointerover" === a4;
        k4 = "mouseout" === a4 || "pointerout" === a4;
        if (h5 && c3 !== wb && (n2 = c3.relatedTarget || c3.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k4 || h5) {
          h5 = e4.window === e4 ? e4 : (h5 = e4.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
          if (k4) {
            if (n2 = c3.relatedTarget || c3.toElement, k4 = d5, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k4 = null, n2 = d5;
          if (k4 !== n2) {
            t4 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a4 || "pointerover" === a4)
              t4 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h5 : ue(k4);
            u3 = null == n2 ? h5 : ue(n2);
            h5 = new t4(F2, w3 + "leave", k4, c3, e4);
            h5.target = J2;
            h5.relatedTarget = u3;
            F2 = null;
            Wc(e4) === d5 && (t4 = new t4(x2, w3 + "enter", n2, c3, e4), t4.target = u3, t4.relatedTarget = J2, F2 = t4);
            J2 = F2;
            if (k4 && n2)
              b: {
                t4 = k4;
                x2 = n2;
                w3 = 0;
                for (u3 = t4; u3; u3 = vf(u3))
                  w3++;
                u3 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u3++;
                for (; 0 < w3 - u3; )
                  t4 = vf(t4), w3--;
                for (; 0 < u3 - w3; )
                  x2 = vf(x2), u3--;
                for (; w3--; ) {
                  if (t4 === x2 || null !== x2 && t4 === x2.alternate)
                    break b;
                  t4 = vf(t4);
                  x2 = vf(x2);
                }
                t4 = null;
              }
            else
              t4 = null;
            null !== k4 && wf(g3, h5, k4, t4, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t4, true);
          }
        }
      }
      a: {
        h5 = d5 ? ue(d5) : window;
        k4 = h5.nodeName && h5.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h5.type)
          var na = ve;
        else if (me(h5))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k4 = h5.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee);
        if (na && (na = na(a4, d5))) {
          ne$1(g3, na, c3, e4);
          break a;
        }
        xa && xa(a4, h5, d5);
        "focusout" === a4 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
      }
      xa = d5 ? ue(d5) : window;
      switch (a4) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d5, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c3, e4);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c3, e4);
      }
      var $a;
      if (ae)
        b: {
          switch (a4) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a4, c3) && (ba = "onCompositionEnd") : "keydown" === a4 && 229 === c3.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c3.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d5, ba), 0 < xa.length && (ba = new Ld(ba, a4, null, c3, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c3), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a4, c3) : ke(a4, c3))
        d5 = oe(d5, "onBeforeInput"), 0 < d5.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c3, e4), g3.push({ event: e4, listeners: d5 }), e4.data = $a);
    }
    se(g3, b3);
  });
}
function tf(a4, b3, c3) {
  return { instance: a4, listener: b3, currentTarget: c3 };
}
function oe(a4, b3) {
  for (var c3 = b3 + "Capture", d4 = []; null !== a4; ) {
    var e3 = a4, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a4, c3), null != f2 && d4.unshift(tf(a4, f2, e3)), f2 = Kb(a4, b3), null != f2 && d4.push(tf(a4, f2, e3)));
    a4 = a4.return;
  }
  return d4;
}
function vf(a4) {
  if (null === a4)
    return null;
  do
    a4 = a4.return;
  while (a4 && 5 !== a4.tag);
  return a4 ? a4 : null;
}
function wf(a4, b3, c3, d4, e3) {
  for (var f2 = b3._reactName, g2 = []; null !== c3 && c3 !== d4; ) {
    var h4 = c3, k3 = h4.alternate, l2 = h4.stateNode;
    if (null !== k3 && k3 === d4)
      break;
    5 === h4.tag && null !== l2 && (h4 = l2, e3 ? (k3 = Kb(c3, f2), null != k3 && g2.unshift(tf(c3, k3, h4))) : e3 || (k3 = Kb(c3, f2), null != k3 && g2.push(tf(c3, k3, h4))));
    c3 = c3.return;
  }
  0 !== g2.length && a4.push({ event: b3, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a4) {
  return ("string" === typeof a4 ? a4 : "" + a4).replace(xf, "\n").replace(yf, "");
}
function Af(a4, b3, c3) {
  b3 = zf(b3);
  if (zf(a4) !== b3 && c3)
    throw Error(p$6(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a4, b3) {
  return "textarea" === a4 || "noscript" === a4 || "string" === typeof b3.children || "number" === typeof b3.children || "object" === typeof b3.dangerouslySetInnerHTML && null !== b3.dangerouslySetInnerHTML && null != b3.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a4) {
  return Hf.resolve(null).then(a4).catch(If);
} : Ff;
function If(a4) {
  setTimeout(function() {
    throw a4;
  });
}
function Kf(a4, b3) {
  var c3 = b3, d4 = 0;
  do {
    var e3 = c3.nextSibling;
    a4.removeChild(c3);
    if (e3 && 8 === e3.nodeType)
      if (c3 = e3.data, "/$" === c3) {
        if (0 === d4) {
          a4.removeChild(e3);
          bd(b3);
          return;
        }
        d4--;
      } else
        "$" !== c3 && "$?" !== c3 && "$!" !== c3 || d4++;
    c3 = e3;
  } while (c3);
  bd(b3);
}
function Lf(a4) {
  for (; null != a4; a4 = a4.nextSibling) {
    var b3 = a4.nodeType;
    if (1 === b3 || 3 === b3)
      break;
    if (8 === b3) {
      b3 = a4.data;
      if ("$" === b3 || "$!" === b3 || "$?" === b3)
        break;
      if ("/$" === b3)
        return null;
    }
  }
  return a4;
}
function Mf(a4) {
  a4 = a4.previousSibling;
  for (var b3 = 0; a4; ) {
    if (8 === a4.nodeType) {
      var c3 = a4.data;
      if ("$" === c3 || "$!" === c3 || "$?" === c3) {
        if (0 === b3)
          return a4;
        b3--;
      } else
        "/$" === c3 && b3++;
    }
    a4 = a4.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a4) {
  var b3 = a4[Of];
  if (b3)
    return b3;
  for (var c3 = a4.parentNode; c3; ) {
    if (b3 = c3[uf] || c3[Of]) {
      c3 = b3.alternate;
      if (null !== b3.child || null !== c3 && null !== c3.child)
        for (a4 = Mf(a4); null !== a4; ) {
          if (c3 = a4[Of])
            return c3;
          a4 = Mf(a4);
        }
      return b3;
    }
    a4 = c3;
    c3 = a4.parentNode;
  }
  return null;
}
function Cb(a4) {
  a4 = a4[Of] || a4[uf];
  return !a4 || 5 !== a4.tag && 6 !== a4.tag && 13 !== a4.tag && 3 !== a4.tag ? null : a4;
}
function ue(a4) {
  if (5 === a4.tag || 6 === a4.tag)
    return a4.stateNode;
  throw Error(p$6(33));
}
function Db(a4) {
  return a4[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a4) {
  return { current: a4 };
}
function E$1(a4) {
  0 > Tf || (a4.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a4, b3) {
  Tf++;
  Sf[Tf] = a4.current;
  a4.current = b3;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a4, b3) {
  var c3 = a4.type.contextTypes;
  if (!c3)
    return Vf;
  var d4 = a4.stateNode;
  if (d4 && d4.__reactInternalMemoizedUnmaskedChildContext === b3)
    return d4.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c3)
    e3[f2] = b3[f2];
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = b3, a4.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a4) {
  a4 = a4.childContextTypes;
  return null !== a4 && void 0 !== a4;
}
function $f() {
  E$1(Wf);
  E$1(H$2);
}
function ag(a4, b3, c3) {
  if (H$2.current !== Vf)
    throw Error(p$6(168));
  G$1(H$2, b3);
  G$1(Wf, c3);
}
function bg(a4, b3, c3) {
  var d4 = a4.stateNode;
  b3 = b3.childContextTypes;
  if ("function" !== typeof d4.getChildContext)
    return c3;
  d4 = d4.getChildContext();
  for (var e3 in d4)
    if (!(e3 in b3))
      throw Error(p$6(108, Ra(a4) || "Unknown", e3));
  return A$2({}, c3, d4);
}
function cg(a4) {
  a4 = (a4 = a4.stateNode) && a4.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a4);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a4, b3, c3) {
  var d4 = a4.stateNode;
  if (!d4)
    throw Error(p$6(169));
  c3 ? (a4 = bg(a4, b3, Xf), d4.__reactInternalMemoizedMergedChildContext = a4, E$1(Wf), E$1(H$2), G$1(H$2, a4)) : E$1(Wf);
  G$1(Wf, c3);
}
var eg = null, fg = false, gg = false;
function hg(a4) {
  null === eg ? eg = [a4] : eg.push(a4);
}
function ig(a4) {
  fg = true;
  hg(a4);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a4 = 0, b3 = C$1;
    try {
      var c3 = eg;
      for (C$1 = 1; a4 < c3.length; a4++) {
        var d4 = c3[a4];
        do
          d4 = d4(true);
        while (null !== d4);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a4 + 1)), ac(fc, jg), e3;
    } finally {
      C$1 = b3, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a4, b3) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a4;
  ng = b3;
}
function ug(a4, b3, c3) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a4;
  var d4 = rg;
  a4 = sg;
  var e3 = 32 - oc(d4) - 1;
  d4 &= ~(1 << e3);
  c3 += 1;
  var f2 = 32 - oc(b3) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d4 & (1 << g2) - 1).toString(32);
    d4 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b3) + e3 | c3 << e3 | d4;
    sg = f2 + a4;
  } else
    rg = 1 << f2 | c3 << e3 | d4, sg = a4;
}
function vg(a4) {
  null !== a4.return && (tg(a4, 1), ug(a4, 1, 0));
}
function wg(a4) {
  for (; a4 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a4 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a4, b3) {
  var c3 = Bg(5, null, null, 0);
  c3.elementType = "DELETED";
  c3.stateNode = b3;
  c3.return = a4;
  b3 = a4.deletions;
  null === b3 ? (a4.deletions = [c3], a4.flags |= 16) : b3.push(c3);
}
function Cg(a4, b3) {
  switch (a4.tag) {
    case 5:
      var c3 = a4.type;
      b3 = 1 !== b3.nodeType || c3.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
      return null !== b3 ? (a4.stateNode = b3, xg = a4, yg = Lf(b3.firstChild), true) : false;
    case 6:
      return b3 = "" === a4.pendingProps || 3 !== b3.nodeType ? null : b3, null !== b3 ? (a4.stateNode = b3, xg = a4, yg = null, true) : false;
    case 13:
      return b3 = 8 !== b3.nodeType ? null : b3, null !== b3 ? (c3 = null !== qg ? { id: rg, overflow: sg } : null, a4.memoizedState = { dehydrated: b3, treeContext: c3, retryLane: 1073741824 }, c3 = Bg(18, null, null, 0), c3.stateNode = b3, c3.return = a4, a4.child = c3, xg = a4, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a4) {
  return 0 !== (a4.mode & 1) && 0 === (a4.flags & 128);
}
function Eg(a4) {
  if (I$2) {
    var b3 = yg;
    if (b3) {
      var c3 = b3;
      if (!Cg(a4, b3)) {
        if (Dg(a4))
          throw Error(p$6(418));
        b3 = Lf(c3.nextSibling);
        var d4 = xg;
        b3 && Cg(a4, b3) ? Ag(d4, c3) : (a4.flags = a4.flags & -4097 | 2, I$2 = false, xg = a4);
      }
    } else {
      if (Dg(a4))
        throw Error(p$6(418));
      a4.flags = a4.flags & -4097 | 2;
      I$2 = false;
      xg = a4;
    }
  }
}
function Fg(a4) {
  for (a4 = a4.return; null !== a4 && 5 !== a4.tag && 3 !== a4.tag && 13 !== a4.tag; )
    a4 = a4.return;
  xg = a4;
}
function Gg(a4) {
  if (a4 !== xg)
    return false;
  if (!I$2)
    return Fg(a4), I$2 = true, false;
  var b3;
  (b3 = 3 !== a4.tag) && !(b3 = 5 !== a4.tag) && (b3 = a4.type, b3 = "head" !== b3 && "body" !== b3 && !Ef(a4.type, a4.memoizedProps));
  if (b3 && (b3 = yg)) {
    if (Dg(a4))
      throw Hg(), Error(p$6(418));
    for (; b3; )
      Ag(a4, b3), b3 = Lf(b3.nextSibling);
  }
  Fg(a4);
  if (13 === a4.tag) {
    a4 = a4.memoizedState;
    a4 = null !== a4 ? a4.dehydrated : null;
    if (!a4)
      throw Error(p$6(317));
    a: {
      a4 = a4.nextSibling;
      for (b3 = 0; a4; ) {
        if (8 === a4.nodeType) {
          var c3 = a4.data;
          if ("/$" === c3) {
            if (0 === b3) {
              yg = Lf(a4.nextSibling);
              break a;
            }
            b3--;
          } else
            "$" !== c3 && "$!" !== c3 && "$?" !== c3 || b3++;
        }
        a4 = a4.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a4.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a4 = yg; a4; )
    a4 = Lf(a4.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a4) {
  null === zg ? zg = [a4] : zg.push(a4);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a4, b3) {
  if (a4 && a4.defaultProps) {
    b3 = A$2({}, b3);
    a4 = a4.defaultProps;
    for (var c3 in a4)
      void 0 === b3[c3] && (b3[c3] = a4[c3]);
    return b3;
  }
  return b3;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a4) {
  var b3 = Mg.current;
  E$1(Mg);
  a4._currentValue = b3;
}
function Sg(a4, b3, c3) {
  for (; null !== a4; ) {
    var d4 = a4.alternate;
    (a4.childLanes & b3) !== b3 ? (a4.childLanes |= b3, null !== d4 && (d4.childLanes |= b3)) : null !== d4 && (d4.childLanes & b3) !== b3 && (d4.childLanes |= b3);
    if (a4 === c3)
      break;
    a4 = a4.return;
  }
}
function Tg(a4, b3) {
  Ng = a4;
  Pg = Og = null;
  a4 = a4.dependencies;
  null !== a4 && null !== a4.firstContext && (0 !== (a4.lanes & b3) && (Ug = true), a4.firstContext = null);
}
function Vg(a4) {
  var b3 = a4._currentValue;
  if (Pg !== a4)
    if (a4 = { context: a4, memoizedValue: b3, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$6(308));
      Og = a4;
      Ng.dependencies = { lanes: 0, firstContext: a4 };
    } else
      Og = Og.next = a4;
  return b3;
}
var Wg = null;
function Xg(a4) {
  null === Wg ? Wg = [a4] : Wg.push(a4);
}
function Yg(a4, b3, c3, d4) {
  var e3 = b3.interleaved;
  null === e3 ? (c3.next = c3, Xg(b3)) : (c3.next = e3.next, e3.next = c3);
  b3.interleaved = c3;
  return Zg(a4, d4);
}
function Zg(a4, b3) {
  a4.lanes |= b3;
  var c3 = a4.alternate;
  null !== c3 && (c3.lanes |= b3);
  c3 = a4;
  for (a4 = a4.return; null !== a4; )
    a4.childLanes |= b3, c3 = a4.alternate, null !== c3 && (c3.childLanes |= b3), c3 = a4, a4 = a4.return;
  return 3 === c3.tag ? c3.stateNode : null;
}
var $g = false;
function ah(a4) {
  a4.updateQueue = { baseState: a4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a4, b3) {
  a4 = a4.updateQueue;
  b3.updateQueue === a4 && (b3.updateQueue = { baseState: a4.baseState, firstBaseUpdate: a4.firstBaseUpdate, lastBaseUpdate: a4.lastBaseUpdate, shared: a4.shared, effects: a4.effects });
}
function ch(a4, b3) {
  return { eventTime: a4, lane: b3, tag: 0, payload: null, callback: null, next: null };
}
function dh(a4, b3, c3) {
  var d4 = a4.updateQueue;
  if (null === d4)
    return null;
  d4 = d4.shared;
  if (0 !== (K & 2)) {
    var e3 = d4.pending;
    null === e3 ? b3.next = b3 : (b3.next = e3.next, e3.next = b3);
    d4.pending = b3;
    return Zg(a4, c3);
  }
  e3 = d4.interleaved;
  null === e3 ? (b3.next = b3, Xg(d4)) : (b3.next = e3.next, e3.next = b3);
  d4.interleaved = b3;
  return Zg(a4, c3);
}
function eh(a4, b3, c3) {
  b3 = b3.updateQueue;
  if (null !== b3 && (b3 = b3.shared, 0 !== (c3 & 4194240))) {
    var d4 = b3.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a4, c3);
  }
}
function fh(a4, b3) {
  var c3 = a4.updateQueue, d4 = a4.alternate;
  if (null !== d4 && (d4 = d4.updateQueue, c3 === d4)) {
    var e3 = null, f2 = null;
    c3 = c3.firstBaseUpdate;
    if (null !== c3) {
      do {
        var g2 = { eventTime: c3.eventTime, lane: c3.lane, tag: c3.tag, payload: c3.payload, callback: c3.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c3 = c3.next;
      } while (null !== c3);
      null === f2 ? e3 = f2 = b3 : f2 = f2.next = b3;
    } else
      e3 = f2 = b3;
    c3 = { baseState: d4.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d4.shared, effects: d4.effects };
    a4.updateQueue = c3;
    return;
  }
  a4 = c3.lastBaseUpdate;
  null === a4 ? c3.firstBaseUpdate = b3 : a4.next = b3;
  c3.lastBaseUpdate = b3;
}
function gh(a4, b3, c3, d4) {
  var e3 = a4.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h4 = e3.shared.pending;
  if (null !== h4) {
    e3.shared.pending = null;
    var k3 = h4, l2 = k3.next;
    k3.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k3;
    var m4 = a4.alternate;
    null !== m4 && (m4 = m4.updateQueue, h4 = m4.lastBaseUpdate, h4 !== g2 && (null === h4 ? m4.firstBaseUpdate = l2 : h4.next = l2, m4.lastBaseUpdate = k3));
  }
  if (null !== f2) {
    var q3 = e3.baseState;
    g2 = 0;
    m4 = l2 = k3 = null;
    h4 = f2;
    do {
      var r3 = h4.lane, y4 = h4.eventTime;
      if ((d4 & r3) === r3) {
        null !== m4 && (m4 = m4.next = {
          eventTime: y4,
          lane: 0,
          tag: h4.tag,
          payload: h4.payload,
          callback: h4.callback,
          next: null
        });
        a: {
          var n2 = a4, t4 = h4;
          r3 = b3;
          y4 = c3;
          switch (t4.tag) {
            case 1:
              n2 = t4.payload;
              if ("function" === typeof n2) {
                q3 = n2.call(y4, q3, r3);
                break a;
              }
              q3 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t4.payload;
              r3 = "function" === typeof n2 ? n2.call(y4, q3, r3) : n2;
              if (null === r3 || void 0 === r3)
                break a;
              q3 = A$2({}, q3, r3);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h4.callback && 0 !== h4.lane && (a4.flags |= 64, r3 = e3.effects, null === r3 ? e3.effects = [h4] : r3.push(h4));
      } else
        y4 = { eventTime: y4, lane: r3, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m4 ? (l2 = m4 = y4, k3 = q3) : m4 = m4.next = y4, g2 |= r3;
      h4 = h4.next;
      if (null === h4)
        if (h4 = e3.shared.pending, null === h4)
          break;
        else
          r3 = h4, h4 = r3.next, r3.next = null, e3.lastBaseUpdate = r3, e3.shared.pending = null;
    } while (1);
    null === m4 && (k3 = q3);
    e3.baseState = k3;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m4;
    b3 = e3.shared.interleaved;
    if (null !== b3) {
      e3 = b3;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b3);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g2;
    a4.lanes = g2;
    a4.memoizedState = q3;
  }
}
function ih(a4, b3, c3) {
  a4 = b3.effects;
  b3.effects = null;
  if (null !== a4)
    for (b3 = 0; b3 < a4.length; b3++) {
      var d4 = a4[b3], e3 = d4.callback;
      if (null !== e3) {
        d4.callback = null;
        d4 = c3;
        if ("function" !== typeof e3)
          throw Error(p$6(191, e3));
        e3.call(d4);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a4, b3, c3, d4) {
  b3 = a4.memoizedState;
  c3 = c3(d4, b3);
  c3 = null === c3 || void 0 === c3 ? b3 : A$2({}, b3, c3);
  a4.memoizedState = c3;
  0 === a4.lanes && (a4.updateQueue.baseState = c3);
}
var nh = { isMounted: function(a4) {
  return (a4 = a4._reactInternals) ? Vb(a4) === a4 : false;
}, enqueueSetState: function(a4, b3, c3) {
  a4 = a4._reactInternals;
  var d4 = L(), e3 = lh(a4), f2 = ch(d4, e3);
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = dh(a4, f2, e3);
  null !== b3 && (mh(b3, a4, e3, d4), eh(b3, a4, e3));
}, enqueueReplaceState: function(a4, b3, c3) {
  a4 = a4._reactInternals;
  var d4 = L(), e3 = lh(a4), f2 = ch(d4, e3);
  f2.tag = 1;
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = dh(a4, f2, e3);
  null !== b3 && (mh(b3, a4, e3, d4), eh(b3, a4, e3));
}, enqueueForceUpdate: function(a4, b3) {
  a4 = a4._reactInternals;
  var c3 = L(), d4 = lh(a4), e3 = ch(c3, d4);
  e3.tag = 2;
  void 0 !== b3 && null !== b3 && (e3.callback = b3);
  b3 = dh(a4, e3, d4);
  null !== b3 && (mh(b3, a4, d4, c3), eh(b3, a4, d4));
} };
function oh(a4, b3, c3, d4, e3, f2, g2) {
  a4 = a4.stateNode;
  return "function" === typeof a4.shouldComponentUpdate ? a4.shouldComponentUpdate(d4, f2, g2) : b3.prototype && b3.prototype.isPureReactComponent ? !Ie(c3, d4) || !Ie(e3, f2) : true;
}
function ph(a4, b3, c3) {
  var d4 = false, e3 = Vf;
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b3) ? Xf : H$2.current, d4 = b3.contextTypes, f2 = (d4 = null !== d4 && void 0 !== d4) ? Yf(a4, e3) : Vf);
  b3 = new b3(c3, f2);
  a4.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null;
  b3.updater = nh;
  a4.stateNode = b3;
  b3._reactInternals = a4;
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = e3, a4.__reactInternalMemoizedMaskedChildContext = f2);
  return b3;
}
function qh(a4, b3, c3, d4) {
  a4 = b3.state;
  "function" === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c3, d4);
  "function" === typeof b3.UNSAFE_componentWillReceiveProps && b3.UNSAFE_componentWillReceiveProps(c3, d4);
  b3.state !== a4 && nh.enqueueReplaceState(b3, b3.state, null);
}
function rh(a4, b3, c3, d4) {
  var e3 = a4.stateNode;
  e3.props = c3;
  e3.state = a4.memoizedState;
  e3.refs = jh;
  ah(a4);
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b3) ? Xf : H$2.current, e3.context = Yf(a4, f2));
  e3.state = a4.memoizedState;
  f2 = b3.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a4, b3, f2, c3), e3.state = a4.memoizedState);
  "function" === typeof b3.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b3 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b3 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a4, c3, e3, d4), e3.state = a4.memoizedState);
  "function" === typeof e3.componentDidMount && (a4.flags |= 4194308);
}
function sh(a4, b3, c3) {
  a4 = c3.ref;
  if (null !== a4 && "function" !== typeof a4 && "object" !== typeof a4) {
    if (c3._owner) {
      c3 = c3._owner;
      if (c3) {
        if (1 !== c3.tag)
          throw Error(p$6(309));
        var d4 = c3.stateNode;
      }
      if (!d4)
        throw Error(p$6(147, a4));
      var e3 = d4, f2 = "" + a4;
      if (null !== b3 && null !== b3.ref && "function" === typeof b3.ref && b3.ref._stringRef === f2)
        return b3.ref;
      b3 = function(a5) {
        var b4 = e3.refs;
        b4 === jh && (b4 = e3.refs = {});
        null === a5 ? delete b4[f2] : b4[f2] = a5;
      };
      b3._stringRef = f2;
      return b3;
    }
    if ("string" !== typeof a4)
      throw Error(p$6(284));
    if (!c3._owner)
      throw Error(p$6(290, a4));
  }
  return a4;
}
function th(a4, b3) {
  a4 = Object.prototype.toString.call(b3);
  throw Error(p$6(31, "[object Object]" === a4 ? "object with keys {" + Object.keys(b3).join(", ") + "}" : a4));
}
function uh(a4) {
  var b3 = a4._init;
  return b3(a4._payload);
}
function vh$1(a4) {
  function b3(b4, c4) {
    if (a4) {
      var d5 = b4.deletions;
      null === d5 ? (b4.deletions = [c4], b4.flags |= 16) : d5.push(c4);
    }
  }
  function c3(c4, d5) {
    if (!a4)
      return null;
    for (; null !== d5; )
      b3(c4, d5), d5 = d5.sibling;
    return null;
  }
  function d4(a5, b4) {
    for (a5 = /* @__PURE__ */ new Map(); null !== b4; )
      null !== b4.key ? a5.set(b4.key, b4) : a5.set(b4.index, b4), b4 = b4.sibling;
    return a5;
  }
  function e3(a5, b4) {
    a5 = wh(a5, b4);
    a5.index = 0;
    a5.sibling = null;
    return a5;
  }
  function f2(b4, c4, d5) {
    b4.index = d5;
    if (!a4)
      return b4.flags |= 1048576, c4;
    d5 = b4.alternate;
    if (null !== d5)
      return d5 = d5.index, d5 < c4 ? (b4.flags |= 2, c4) : d5;
    b4.flags |= 2;
    return c4;
  }
  function g2(b4) {
    a4 && null === b4.alternate && (b4.flags |= 2);
    return b4;
  }
  function h4(a5, b4, c4, d5) {
    if (null === b4 || 6 !== b4.tag)
      return b4 = xh(c4, a5.mode, d5), b4.return = a5, b4;
    b4 = e3(b4, c4);
    b4.return = a5;
    return b4;
  }
  function k3(a5, b4, c4, d5) {
    var f3 = c4.type;
    if (f3 === ya)
      return m4(a5, b4, c4.props.children, d5, c4.key);
    if (null !== b4 && (b4.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b4.type))
      return d5 = e3(b4, c4.props), d5.ref = sh(a5, b4, c4), d5.return = a5, d5;
    d5 = yh(c4.type, c4.key, c4.props, null, a5.mode, d5);
    d5.ref = sh(a5, b4, c4);
    d5.return = a5;
    return d5;
  }
  function l2(a5, b4, c4, d5) {
    if (null === b4 || 4 !== b4.tag || b4.stateNode.containerInfo !== c4.containerInfo || b4.stateNode.implementation !== c4.implementation)
      return b4 = zh(c4, a5.mode, d5), b4.return = a5, b4;
    b4 = e3(b4, c4.children || []);
    b4.return = a5;
    return b4;
  }
  function m4(a5, b4, c4, d5, f3) {
    if (null === b4 || 7 !== b4.tag)
      return b4 = Ah(c4, a5.mode, d5, f3), b4.return = a5, b4;
    b4 = e3(b4, c4);
    b4.return = a5;
    return b4;
  }
  function q3(a5, b4, c4) {
    if ("string" === typeof b4 && "" !== b4 || "number" === typeof b4)
      return b4 = xh("" + b4, a5.mode, c4), b4.return = a5, b4;
    if ("object" === typeof b4 && null !== b4) {
      switch (b4.$$typeof) {
        case va:
          return c4 = yh(b4.type, b4.key, b4.props, null, a5.mode, c4), c4.ref = sh(a5, null, b4), c4.return = a5, c4;
        case wa:
          return b4 = zh(b4, a5.mode, c4), b4.return = a5, b4;
        case Ha:
          var d5 = b4._init;
          return q3(a5, d5(b4._payload), c4);
      }
      if (eb(b4) || Ka(b4))
        return b4 = Ah(b4, a5.mode, c4, null), b4.return = a5, b4;
      th(a5, b4);
    }
    return null;
  }
  function r3(a5, b4, c4, d5) {
    var e4 = null !== b4 ? b4.key : null;
    if ("string" === typeof c4 && "" !== c4 || "number" === typeof c4)
      return null !== e4 ? null : h4(a5, b4, "" + c4, d5);
    if ("object" === typeof c4 && null !== c4) {
      switch (c4.$$typeof) {
        case va:
          return c4.key === e4 ? k3(a5, b4, c4, d5) : null;
        case wa:
          return c4.key === e4 ? l2(a5, b4, c4, d5) : null;
        case Ha:
          return e4 = c4._init, r3(
            a5,
            b4,
            e4(c4._payload),
            d5
          );
      }
      if (eb(c4) || Ka(c4))
        return null !== e4 ? null : m4(a5, b4, c4, d5, null);
      th(a5, c4);
    }
    return null;
  }
  function y4(a5, b4, c4, d5, e4) {
    if ("string" === typeof d5 && "" !== d5 || "number" === typeof d5)
      return a5 = a5.get(c4) || null, h4(b4, a5, "" + d5, e4);
    if ("object" === typeof d5 && null !== d5) {
      switch (d5.$$typeof) {
        case va:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, k3(b4, a5, d5, e4);
        case wa:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, l2(b4, a5, d5, e4);
        case Ha:
          var f3 = d5._init;
          return y4(a5, b4, c4, f3(d5._payload), e4);
      }
      if (eb(d5) || Ka(d5))
        return a5 = a5.get(c4) || null, m4(b4, a5, d5, e4, null);
      th(b4, d5);
    }
    return null;
  }
  function n2(e4, g3, h5, k4) {
    for (var l3 = null, m5 = null, u3 = g3, w3 = g3 = 0, x2 = null; null !== u3 && w3 < h5.length; w3++) {
      u3.index > w3 ? (x2 = u3, u3 = null) : x2 = u3.sibling;
      var n3 = r3(e4, u3, h5[w3], k4);
      if (null === n3) {
        null === u3 && (u3 = x2);
        break;
      }
      a4 && u3 && null === n3.alternate && b3(e4, u3);
      g3 = f2(n3, g3, w3);
      null === m5 ? l3 = n3 : m5.sibling = n3;
      m5 = n3;
      u3 = x2;
    }
    if (w3 === h5.length)
      return c3(e4, u3), I$2 && tg(e4, w3), l3;
    if (null === u3) {
      for (; w3 < h5.length; w3++)
        u3 = q3(e4, h5[w3], k4), null !== u3 && (g3 = f2(u3, g3, w3), null === m5 ? l3 = u3 : m5.sibling = u3, m5 = u3);
      I$2 && tg(e4, w3);
      return l3;
    }
    for (u3 = d4(e4, u3); w3 < h5.length; w3++)
      x2 = y4(u3, e4, w3, h5[w3], k4), null !== x2 && (a4 && null !== x2.alternate && u3.delete(null === x2.key ? w3 : x2.key), g3 = f2(x2, g3, w3), null === m5 ? l3 = x2 : m5.sibling = x2, m5 = x2);
    a4 && u3.forEach(function(a5) {
      return b3(e4, a5);
    });
    I$2 && tg(e4, w3);
    return l3;
  }
  function t4(e4, g3, h5, k4) {
    var l3 = Ka(h5);
    if ("function" !== typeof l3)
      throw Error(p$6(150));
    h5 = l3.call(h5);
    if (null == h5)
      throw Error(p$6(151));
    for (var u3 = l3 = null, m5 = g3, w3 = g3 = 0, x2 = null, n3 = h5.next(); null !== m5 && !n3.done; w3++, n3 = h5.next()) {
      m5.index > w3 ? (x2 = m5, m5 = null) : x2 = m5.sibling;
      var t5 = r3(e4, m5, n3.value, k4);
      if (null === t5) {
        null === m5 && (m5 = x2);
        break;
      }
      a4 && m5 && null === t5.alternate && b3(e4, m5);
      g3 = f2(t5, g3, w3);
      null === u3 ? l3 = t5 : u3.sibling = t5;
      u3 = t5;
      m5 = x2;
    }
    if (n3.done)
      return c3(
        e4,
        m5
      ), I$2 && tg(e4, w3), l3;
    if (null === m5) {
      for (; !n3.done; w3++, n3 = h5.next())
        n3 = q3(e4, n3.value, k4), null !== n3 && (g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
      I$2 && tg(e4, w3);
      return l3;
    }
    for (m5 = d4(e4, m5); !n3.done; w3++, n3 = h5.next())
      n3 = y4(m5, e4, w3, n3.value, k4), null !== n3 && (a4 && null !== n3.alternate && m5.delete(null === n3.key ? w3 : n3.key), g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
    a4 && m5.forEach(function(a5) {
      return b3(e4, a5);
    });
    I$2 && tg(e4, w3);
    return l3;
  }
  function J2(a5, d5, f3, h5) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k4 = f3.key, l3 = d5; null !== l3; ) {
              if (l3.key === k4) {
                k4 = f3.type;
                if (k4 === ya) {
                  if (7 === l3.tag) {
                    c3(a5, l3.sibling);
                    d5 = e3(l3, f3.props.children);
                    d5.return = a5;
                    a5 = d5;
                    break a;
                  }
                } else if (l3.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && uh(k4) === l3.type) {
                  c3(a5, l3.sibling);
                  d5 = e3(l3, f3.props);
                  d5.ref = sh(a5, l3, f3);
                  d5.return = a5;
                  a5 = d5;
                  break a;
                }
                c3(a5, l3);
                break;
              } else
                b3(a5, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d5 = Ah(f3.props.children, a5.mode, h5, f3.key), d5.return = a5, a5 = d5) : (h5 = yh(f3.type, f3.key, f3.props, null, a5.mode, h5), h5.ref = sh(a5, d5, f3), h5.return = a5, a5 = h5);
          }
          return g2(a5);
        case wa:
          a: {
            for (l3 = f3.key; null !== d5; ) {
              if (d5.key === l3)
                if (4 === d5.tag && d5.stateNode.containerInfo === f3.containerInfo && d5.stateNode.implementation === f3.implementation) {
                  c3(a5, d5.sibling);
                  d5 = e3(d5, f3.children || []);
                  d5.return = a5;
                  a5 = d5;
                  break a;
                } else {
                  c3(a5, d5);
                  break;
                }
              else
                b3(a5, d5);
              d5 = d5.sibling;
            }
            d5 = zh(f3, a5.mode, h5);
            d5.return = a5;
            a5 = d5;
          }
          return g2(a5);
        case Ha:
          return l3 = f3._init, J2(a5, d5, l3(f3._payload), h5);
      }
      if (eb(f3))
        return n2(a5, d5, f3, h5);
      if (Ka(f3))
        return t4(a5, d5, f3, h5);
      th(a5, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d5 && 6 === d5.tag ? (c3(a5, d5.sibling), d5 = e3(d5, f3), d5.return = a5, a5 = d5) : (c3(a5, d5), d5 = xh(f3, a5.mode, h5), d5.return = a5, a5 = d5), g2(a5)) : c3(a5, d5);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a4) {
  if (a4 === Dh)
    throw Error(p$6(174));
  return a4;
}
function Ih(a4, b3) {
  G$1(Gh, b3);
  G$1(Fh, a4);
  G$1(Eh, Dh);
  a4 = b3.nodeType;
  switch (a4) {
    case 9:
    case 11:
      b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, "");
      break;
    default:
      a4 = 8 === a4 ? b3.parentNode : b3, b3 = a4.namespaceURI || null, a4 = a4.tagName, b3 = lb(b3, a4);
  }
  E$1(Eh);
  G$1(Eh, b3);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a4) {
  Hh(Gh.current);
  var b3 = Hh(Eh.current);
  var c3 = lb(b3, a4.type);
  b3 !== c3 && (G$1(Fh, a4), G$1(Eh, c3));
}
function Lh(a4) {
  Fh.current === a4 && (E$1(Eh), E$1(Fh));
}
var M$2 = Uf(0);
function Mh(a4) {
  for (var b3 = a4; null !== b3; ) {
    if (13 === b3.tag) {
      var c3 = b3.memoizedState;
      if (null !== c3 && (c3 = c3.dehydrated, null === c3 || "$?" === c3.data || "$!" === c3.data))
        return b3;
    } else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
      if (0 !== (b3.flags & 128))
        return b3;
    } else if (null !== b3.child) {
      b3.child.return = b3;
      b3 = b3.child;
      continue;
    }
    if (b3 === a4)
      break;
    for (; null === b3.sibling; ) {
      if (null === b3.return || b3.return === a4)
        return null;
      b3 = b3.return;
    }
    b3.sibling.return = b3.return;
    b3 = b3.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a4 = 0; a4 < Nh.length; a4++)
    Nh[a4]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$6(321));
}
function Wh(a4, b3) {
  if (null === b3)
    return false;
  for (var c3 = 0; c3 < b3.length && c3 < a4.length; c3++)
    if (!He(a4[c3], b3[c3]))
      return false;
  return true;
}
function Xh(a4, b3, c3, d4, e3, f2) {
  Rh = f2;
  N$1 = b3;
  b3.memoizedState = null;
  b3.updateQueue = null;
  b3.lanes = 0;
  Ph.current = null === a4 || null === a4.memoizedState ? Yh : Zh;
  a4 = c3(d4, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$6(301));
      f2 += 1;
      P = O = null;
      b3.updateQueue = null;
      Ph.current = $h;
      a4 = c3(d4, e3);
    } while (Th);
  }
  Ph.current = ai;
  b3 = null !== O && null !== O.next;
  Rh = 0;
  P = O = N$1 = null;
  Sh = false;
  if (b3)
    throw Error(p$6(300));
  return a4;
}
function bi() {
  var a4 = 0 !== Uh;
  Uh = 0;
  return a4;
}
function ci() {
  var a4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N$1.memoizedState = P = a4 : P = P.next = a4;
  return P;
}
function di() {
  if (null === O) {
    var a4 = N$1.alternate;
    a4 = null !== a4 ? a4.memoizedState : null;
  } else
    a4 = O.next;
  var b3 = null === P ? N$1.memoizedState : P.next;
  if (null !== b3)
    P = b3, O = a4;
  else {
    if (null === a4)
      throw Error(p$6(310));
    O = a4;
    a4 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N$1.memoizedState = P = a4 : P = P.next = a4;
  }
  return P;
}
function ei(a4, b3) {
  return "function" === typeof b3 ? b3(a4) : b3;
}
function fi(a4) {
  var b3 = di(), c3 = b3.queue;
  if (null === c3)
    throw Error(p$6(311));
  c3.lastRenderedReducer = a4;
  var d4 = O, e3 = d4.baseQueue, f2 = c3.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d4.baseQueue = e3 = f2;
    c3.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d4 = d4.baseState;
    var h4 = g2 = null, k3 = null, l2 = f2;
    do {
      var m4 = l2.lane;
      if ((Rh & m4) === m4)
        null !== k3 && (k3 = k3.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d4 = l2.hasEagerState ? l2.eagerState : a4(d4, l2.action);
      else {
        var q3 = {
          lane: m4,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k3 ? (h4 = k3 = q3, g2 = d4) : k3 = k3.next = q3;
        N$1.lanes |= m4;
        hh |= m4;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k3 ? g2 = d4 : k3.next = h4;
    He(d4, b3.memoizedState) || (Ug = true);
    b3.memoizedState = d4;
    b3.baseState = g2;
    b3.baseQueue = k3;
    c3.lastRenderedState = d4;
  }
  a4 = c3.interleaved;
  if (null !== a4) {
    e3 = a4;
    do
      f2 = e3.lane, N$1.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a4);
  } else
    null === e3 && (c3.lanes = 0);
  return [b3.memoizedState, c3.dispatch];
}
function gi(a4) {
  var b3 = di(), c3 = b3.queue;
  if (null === c3)
    throw Error(p$6(311));
  c3.lastRenderedReducer = a4;
  var d4 = c3.dispatch, e3 = c3.pending, f2 = b3.memoizedState;
  if (null !== e3) {
    c3.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a4(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He(f2, b3.memoizedState) || (Ug = true);
    b3.memoizedState = f2;
    null === b3.baseQueue && (b3.baseState = f2);
    c3.lastRenderedState = f2;
  }
  return [f2, d4];
}
function hi() {
}
function ii(a4, b3) {
  var c3 = N$1, d4 = di(), e3 = b3(), f2 = !He(d4.memoizedState, e3);
  f2 && (d4.memoizedState = e3, Ug = true);
  d4 = d4.queue;
  ji(ki.bind(null, c3, d4, a4), [a4]);
  if (d4.getSnapshot !== b3 || f2 || null !== P && P.memoizedState.tag & 1) {
    c3.flags |= 2048;
    li(9, mi.bind(null, c3, d4, e3, b3), void 0, null);
    if (null === R$1)
      throw Error(p$6(349));
    0 !== (Rh & 30) || ni(c3, b3, e3);
  }
  return e3;
}
function ni(a4, b3, c3) {
  a4.flags |= 16384;
  a4 = { getSnapshot: b3, value: c3 };
  b3 = N$1.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N$1.updateQueue = b3, b3.stores = [a4]) : (c3 = b3.stores, null === c3 ? b3.stores = [a4] : c3.push(a4));
}
function mi(a4, b3, c3, d4) {
  b3.value = c3;
  b3.getSnapshot = d4;
  oi(b3) && pi(a4);
}
function ki(a4, b3, c3) {
  return c3(function() {
    oi(b3) && pi(a4);
  });
}
function oi(a4) {
  var b3 = a4.getSnapshot;
  a4 = a4.value;
  try {
    var c3 = b3();
    return !He(a4, c3);
  } catch (d4) {
    return true;
  }
}
function pi(a4) {
  var b3 = Zg(a4, 1);
  null !== b3 && mh(b3, a4, 1, -1);
}
function qi(a4) {
  var b3 = ci();
  "function" === typeof a4 && (a4 = a4());
  b3.memoizedState = b3.baseState = a4;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a4 };
  b3.queue = a4;
  a4 = a4.dispatch = ri.bind(null, N$1, a4);
  return [b3.memoizedState, a4];
}
function li(a4, b3, c3, d4) {
  a4 = { tag: a4, create: b3, destroy: c3, deps: d4, next: null };
  b3 = N$1.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N$1.updateQueue = b3, b3.lastEffect = a4.next = a4) : (c3 = b3.lastEffect, null === c3 ? b3.lastEffect = a4.next = a4 : (d4 = c3.next, c3.next = a4, a4.next = d4, b3.lastEffect = a4));
  return a4;
}
function si() {
  return di().memoizedState;
}
function ti(a4, b3, c3, d4) {
  var e3 = ci();
  N$1.flags |= a4;
  e3.memoizedState = li(1 | b3, c3, void 0, void 0 === d4 ? null : d4);
}
function ui(a4, b3, c3, d4) {
  var e3 = di();
  d4 = void 0 === d4 ? null : d4;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d4 && Wh(d4, g2.deps)) {
      e3.memoizedState = li(b3, c3, f2, d4);
      return;
    }
  }
  N$1.flags |= a4;
  e3.memoizedState = li(1 | b3, c3, f2, d4);
}
function vi(a4, b3) {
  return ti(8390656, 8, a4, b3);
}
function ji(a4, b3) {
  return ui(2048, 8, a4, b3);
}
function wi(a4, b3) {
  return ui(4, 2, a4, b3);
}
function xi(a4, b3) {
  return ui(4, 4, a4, b3);
}
function yi(a4, b3) {
  if ("function" === typeof b3)
    return a4 = a4(), b3(a4), function() {
      b3(null);
    };
  if (null !== b3 && void 0 !== b3)
    return a4 = a4(), b3.current = a4, function() {
      b3.current = null;
    };
}
function zi(a4, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return ui(4, 4, yi.bind(null, b3, a4), c3);
}
function Ai() {
}
function Bi(a4, b3) {
  var c3 = di();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Wh(b3, d4[1]))
    return d4[0];
  c3.memoizedState = [a4, b3];
  return a4;
}
function Ci(a4, b3) {
  var c3 = di();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Wh(b3, d4[1]))
    return d4[0];
  a4 = a4();
  c3.memoizedState = [a4, b3];
  return a4;
}
function Di(a4, b3, c3) {
  if (0 === (Rh & 21))
    return a4.baseState && (a4.baseState = false, Ug = true), a4.memoizedState = c3;
  He(c3, b3) || (c3 = yc(), N$1.lanes |= c3, hh |= c3, a4.baseState = true);
  return b3;
}
function Ei(a4, b3) {
  var c3 = C$1;
  C$1 = 0 !== c3 && 4 > c3 ? c3 : 4;
  a4(true);
  var d4 = Qh.transition;
  Qh.transition = {};
  try {
    a4(false), b3();
  } finally {
    C$1 = c3, Qh.transition = d4;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a4, b3, c3) {
  var d4 = lh(a4);
  c3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a4))
    Ii(b3, c3);
  else if (c3 = Yg(a4, b3, c3, d4), null !== c3) {
    var e3 = L();
    mh(c3, a4, d4, e3);
    Ji(c3, b3, d4);
  }
}
function ri(a4, b3, c3) {
  var d4 = lh(a4), e3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a4))
    Ii(b3, e3);
  else {
    var f2 = a4.alternate;
    if (0 === a4.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b3.lastRenderedReducer, null !== f2))
      try {
        var g2 = b3.lastRenderedState, h4 = f2(g2, c3);
        e3.hasEagerState = true;
        e3.eagerState = h4;
        if (He(h4, g2)) {
          var k3 = b3.interleaved;
          null === k3 ? (e3.next = e3, Xg(b3)) : (e3.next = k3.next, k3.next = e3);
          b3.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c3 = Yg(a4, b3, e3, d4);
    null !== c3 && (e3 = L(), mh(c3, a4, d4, e3), Ji(c3, b3, d4));
  }
}
function Hi(a4) {
  var b3 = a4.alternate;
  return a4 === N$1 || null !== b3 && b3 === N$1;
}
function Ii(a4, b3) {
  Th = Sh = true;
  var c3 = a4.pending;
  null === c3 ? b3.next = b3 : (b3.next = c3.next, c3.next = b3);
  a4.pending = b3;
}
function Ji(a4, b3, c3) {
  if (0 !== (c3 & 4194240)) {
    var d4 = b3.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a4, c3);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a4, b3) {
  ci().memoizedState = [a4, void 0 === b3 ? null : b3];
  return a4;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a4, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b3, a4),
    c3
  );
}, useLayoutEffect: function(a4, b3) {
  return ti(4194308, 4, a4, b3);
}, useInsertionEffect: function(a4, b3) {
  return ti(4, 2, a4, b3);
}, useMemo: function(a4, b3) {
  var c3 = ci();
  b3 = void 0 === b3 ? null : b3;
  a4 = a4();
  c3.memoizedState = [a4, b3];
  return a4;
}, useReducer: function(a4, b3, c3) {
  var d4 = ci();
  b3 = void 0 !== c3 ? c3(b3) : b3;
  d4.memoizedState = d4.baseState = b3;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a4, lastRenderedState: b3 };
  d4.queue = a4;
  a4 = a4.dispatch = Gi.bind(null, N$1, a4);
  return [d4.memoizedState, a4];
}, useRef: function(a4) {
  var b3 = ci();
  a4 = { current: a4 };
  return b3.memoizedState = a4;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a4) {
  return ci().memoizedState = a4;
}, useTransition: function() {
  var a4 = qi(false), b3 = a4[0];
  a4 = Ei.bind(null, a4[1]);
  ci().memoizedState = a4;
  return [b3, a4];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a4, b3, c3) {
  var d4 = N$1, e3 = ci();
  if (I$2) {
    if (void 0 === c3)
      throw Error(p$6(407));
    c3 = c3();
  } else {
    c3 = b3();
    if (null === R$1)
      throw Error(p$6(349));
    0 !== (Rh & 30) || ni(d4, b3, c3);
  }
  e3.memoizedState = c3;
  var f2 = { value: c3, getSnapshot: b3 };
  e3.queue = f2;
  vi(ki.bind(
    null,
    d4,
    f2,
    a4
  ), [a4]);
  d4.flags |= 2048;
  li(9, mi.bind(null, d4, f2, c3, b3), void 0, null);
  return c3;
}, useId: function() {
  var a4 = ci(), b3 = R$1.identifierPrefix;
  if (I$2) {
    var c3 = sg;
    var d4 = rg;
    c3 = (d4 & ~(1 << 32 - oc(d4) - 1)).toString(32) + c3;
    b3 = ":" + b3 + "R" + c3;
    c3 = Uh++;
    0 < c3 && (b3 += "H" + c3.toString(32));
    b3 += ":";
  } else
    c3 = Vh++, b3 = ":" + b3 + "r" + c3.toString(32) + ":";
  return a4.memoizedState = b3;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a4) {
    var b3 = di();
    return Di(b3, O.memoizedState, a4);
  },
  useTransition: function() {
    var a4 = fi(ei)[0], b3 = di().memoizedState;
    return [a4, b3];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a4) {
  var b3 = di();
  return null === O ? b3.memoizedState = a4 : Di(b3, O.memoizedState, a4);
}, useTransition: function() {
  var a4 = gi(ei)[0], b3 = di().memoizedState;
  return [a4, b3];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a4, b3) {
  try {
    var c3 = "", d4 = b3;
    do
      c3 += Pa(d4), d4 = d4.return;
    while (d4);
    var e3 = c3;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a4, source: b3, stack: e3, digest: null };
}
function Li(a4, b3, c3) {
  return { value: a4, source: null, stack: null != c3 ? c3 : null, digest: null != b3 ? b3 : null };
}
function Mi(a4, b3) {
  try {
    console.error(b3.value);
  } catch (c3) {
    setTimeout(function() {
      throw c3;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a4, b3, c3) {
  c3 = ch(-1, c3);
  c3.tag = 3;
  c3.payload = { element: null };
  var d4 = b3.value;
  c3.callback = function() {
    Pi || (Pi = true, Qi = d4);
    Mi(a4, b3);
  };
  return c3;
}
function Ri(a4, b3, c3) {
  c3 = ch(-1, c3);
  c3.tag = 3;
  var d4 = a4.type.getDerivedStateFromError;
  if ("function" === typeof d4) {
    var e3 = b3.value;
    c3.payload = function() {
      return d4(e3);
    };
    c3.callback = function() {
      Mi(a4, b3);
    };
  }
  var f2 = a4.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c3.callback = function() {
    Mi(a4, b3);
    "function" !== typeof d4 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c4 = b3.stack;
    this.componentDidCatch(b3.value, { componentStack: null !== c4 ? c4 : "" });
  });
  return c3;
}
function Ti(a4, b3, c3) {
  var d4 = a4.pingCache;
  if (null === d4) {
    d4 = a4.pingCache = new Ni();
    var e3 = /* @__PURE__ */ new Set();
    d4.set(b3, e3);
  } else
    e3 = d4.get(b3), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d4.set(b3, e3));
  e3.has(c3) || (e3.add(c3), a4 = Ui.bind(null, a4, b3, c3), b3.then(a4, a4));
}
function Vi(a4) {
  do {
    var b3;
    if (b3 = 13 === a4.tag)
      b3 = a4.memoizedState, b3 = null !== b3 ? null !== b3.dehydrated ? true : false : true;
    if (b3)
      return a4;
    a4 = a4.return;
  } while (null !== a4);
  return null;
}
function Wi(a4, b3, c3, d4, e3) {
  if (0 === (a4.mode & 1))
    return a4 === b3 ? a4.flags |= 65536 : (a4.flags |= 128, c3.flags |= 131072, c3.flags &= -52805, 1 === c3.tag && (null === c3.alternate ? c3.tag = 17 : (b3 = ch(-1, 1), b3.tag = 2, dh(c3, b3, 1))), c3.lanes |= 1), a4;
  a4.flags |= 65536;
  a4.lanes = e3;
  return a4;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a4, b3, c3, d4) {
  b3.child = null === a4 ? Ch(b3, null, c3, d4) : Bh(b3, a4.child, c3, d4);
}
function Zi(a4, b3, c3, d4, e3) {
  c3 = c3.render;
  var f2 = b3.ref;
  Tg(b3, e3);
  d4 = Xh(a4, b3, c3, d4, f2, e3);
  c3 = bi();
  if (null !== a4 && !Ug)
    return b3.updateQueue = a4.updateQueue, b3.flags &= -2053, a4.lanes &= ~e3, $i(a4, b3, e3);
  I$2 && c3 && vg(b3);
  b3.flags |= 1;
  Yi(a4, b3, d4, e3);
  return b3.child;
}
function aj(a4, b3, c3, d4, e3) {
  if (null === a4) {
    var f2 = c3.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c3.compare && void 0 === c3.defaultProps)
      return b3.tag = 15, b3.type = f2, cj(a4, b3, f2, d4, e3);
    a4 = yh(c3.type, null, d4, b3, b3.mode, e3);
    a4.ref = b3.ref;
    a4.return = b3;
    return b3.child = a4;
  }
  f2 = a4.child;
  if (0 === (a4.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c3 = c3.compare;
    c3 = null !== c3 ? c3 : Ie;
    if (c3(g2, d4) && a4.ref === b3.ref)
      return $i(a4, b3, e3);
  }
  b3.flags |= 1;
  a4 = wh(f2, d4);
  a4.ref = b3.ref;
  a4.return = b3;
  return b3.child = a4;
}
function cj(a4, b3, c3, d4, e3) {
  if (null !== a4) {
    var f2 = a4.memoizedProps;
    if (Ie(f2, d4) && a4.ref === b3.ref)
      if (Ug = false, b3.pendingProps = d4 = f2, 0 !== (a4.lanes & e3))
        0 !== (a4.flags & 131072) && (Ug = true);
      else
        return b3.lanes = a4.lanes, $i(a4, b3, e3);
  }
  return dj(a4, b3, c3, d4, e3);
}
function ej(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.children, f2 = null !== a4 ? a4.memoizedState : null;
  if ("hidden" === d4.mode)
    if (0 === (b3.mode & 1))
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c3;
    else {
      if (0 === (c3 & 1073741824))
        return a4 = null !== f2 ? f2.baseLanes | c3 : c3, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = { baseLanes: a4, cachePool: null, transitions: null }, b3.updateQueue = null, G$1(fj, gj), gj |= a4, null;
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d4 = null !== f2 ? f2.baseLanes : c3;
      G$1(fj, gj);
      gj |= d4;
    }
  else
    null !== f2 ? (d4 = f2.baseLanes | c3, b3.memoizedState = null) : d4 = c3, G$1(fj, gj), gj |= d4;
  Yi(a4, b3, e3, c3);
  return b3.child;
}
function hj(a4, b3) {
  var c3 = b3.ref;
  if (null === a4 && null !== c3 || null !== a4 && a4.ref !== c3)
    b3.flags |= 512, b3.flags |= 2097152;
}
function dj(a4, b3, c3, d4, e3) {
  var f2 = Zf(c3) ? Xf : H$2.current;
  f2 = Yf(b3, f2);
  Tg(b3, e3);
  c3 = Xh(a4, b3, c3, d4, f2, e3);
  d4 = bi();
  if (null !== a4 && !Ug)
    return b3.updateQueue = a4.updateQueue, b3.flags &= -2053, a4.lanes &= ~e3, $i(a4, b3, e3);
  I$2 && d4 && vg(b3);
  b3.flags |= 1;
  Yi(a4, b3, c3, e3);
  return b3.child;
}
function ij(a4, b3, c3, d4, e3) {
  if (Zf(c3)) {
    var f2 = true;
    cg(b3);
  } else
    f2 = false;
  Tg(b3, e3);
  if (null === b3.stateNode)
    jj(a4, b3), ph(b3, c3, d4), rh(b3, c3, d4, e3), d4 = true;
  else if (null === a4) {
    var g2 = b3.stateNode, h4 = b3.memoizedProps;
    g2.props = h4;
    var k3 = g2.context, l2 = c3.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c3) ? Xf : H$2.current, l2 = Yf(b3, l2));
    var m4 = c3.getDerivedStateFromProps, q3 = "function" === typeof m4 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q3 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== d4 || k3 !== l2) && qh(b3, g2, d4, l2);
    $g = false;
    var r3 = b3.memoizedState;
    g2.state = r3;
    gh(b3, d4, g2, e3);
    k3 = b3.memoizedState;
    h4 !== d4 || r3 !== k3 || Wf.current || $g ? ("function" === typeof m4 && (kh(b3, c3, m4, d4), k3 = b3.memoizedState), (h4 = $g || oh(b3, c3, h4, d4, r3, k3, l2)) ? (q3 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b3.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), b3.memoizedProps = d4, b3.memoizedState = k3), g2.props = d4, g2.state = k3, g2.context = l2, d4 = h4) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), d4 = false);
  } else {
    g2 = b3.stateNode;
    bh(a4, b3);
    h4 = b3.memoizedProps;
    l2 = b3.type === b3.elementType ? h4 : Lg(b3.type, h4);
    g2.props = l2;
    q3 = b3.pendingProps;
    r3 = g2.context;
    k3 = c3.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = Vg(k3) : (k3 = Zf(c3) ? Xf : H$2.current, k3 = Yf(b3, k3));
    var y4 = c3.getDerivedStateFromProps;
    (m4 = "function" === typeof y4 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== q3 || r3 !== k3) && qh(b3, g2, d4, k3);
    $g = false;
    r3 = b3.memoizedState;
    g2.state = r3;
    gh(b3, d4, g2, e3);
    var n2 = b3.memoizedState;
    h4 !== q3 || r3 !== n2 || Wf.current || $g ? ("function" === typeof y4 && (kh(b3, c3, y4, d4), n2 = b3.memoizedState), (l2 = $g || oh(b3, c3, l2, d4, r3, n2, k3) || false) ? (m4 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d4, n2, k3), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d4, n2, k3)), "function" === typeof g2.componentDidUpdate && (b3.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b3.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b3.flags |= 1024), b3.memoizedProps = d4, b3.memoizedState = n2), g2.props = d4, g2.state = n2, g2.context = k3, d4 = l2) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b3.flags |= 1024), d4 = false);
  }
  return kj(a4, b3, c3, d4, f2, e3);
}
function kj(a4, b3, c3, d4, e3, f2) {
  hj(a4, b3);
  var g2 = 0 !== (b3.flags & 128);
  if (!d4 && !g2)
    return e3 && dg(b3, c3, false), $i(a4, b3, f2);
  d4 = b3.stateNode;
  Xi.current = b3;
  var h4 = g2 && "function" !== typeof c3.getDerivedStateFromError ? null : d4.render();
  b3.flags |= 1;
  null !== a4 && g2 ? (b3.child = Bh(b3, a4.child, null, f2), b3.child = Bh(b3, null, h4, f2)) : Yi(a4, b3, h4, f2);
  b3.memoizedState = d4.state;
  e3 && dg(b3, c3, true);
  return b3.child;
}
function lj(a4) {
  var b3 = a4.stateNode;
  b3.pendingContext ? ag(a4, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && ag(a4, b3.context, false);
  Ih(a4, b3.containerInfo);
}
function mj(a4, b3, c3, d4, e3) {
  Ig();
  Jg(e3);
  b3.flags |= 256;
  Yi(a4, b3, c3, d4);
  return b3.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a4) {
  return { baseLanes: a4, cachePool: null, transitions: null };
}
function pj(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = M$2.current, f2 = false, g2 = 0 !== (b3.flags & 128), h4;
  (h4 = g2) || (h4 = null !== a4 && null === a4.memoizedState ? false : 0 !== (e3 & 2));
  if (h4)
    f2 = true, b3.flags &= -129;
  else if (null === a4 || null !== a4.memoizedState)
    e3 |= 1;
  G$1(M$2, e3 & 1);
  if (null === a4) {
    Eg(b3);
    a4 = b3.memoizedState;
    if (null !== a4 && (a4 = a4.dehydrated, null !== a4))
      return 0 === (b3.mode & 1) ? b3.lanes = 1 : "$!" === a4.data ? b3.lanes = 8 : b3.lanes = 1073741824, null;
    g2 = d4.children;
    a4 = d4.fallback;
    return f2 ? (d4 = b3.mode, f2 = b3.child, g2 = { mode: "hidden", children: g2 }, 0 === (d4 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d4, 0, null), a4 = Ah(a4, d4, c3, null), f2.return = b3, a4.return = b3, f2.sibling = a4, b3.child = f2, b3.child.memoizedState = oj(c3), b3.memoizedState = nj, a4) : rj(b3, g2);
  }
  e3 = a4.memoizedState;
  if (null !== e3 && (h4 = e3.dehydrated, null !== h4))
    return sj(a4, b3, g2, d4, h4, e3, c3);
  if (f2) {
    f2 = d4.fallback;
    g2 = b3.mode;
    e3 = a4.child;
    h4 = e3.sibling;
    var k3 = { mode: "hidden", children: d4.children };
    0 === (g2 & 1) && b3.child !== e3 ? (d4 = b3.child, d4.childLanes = 0, d4.pendingProps = k3, b3.deletions = null) : (d4 = wh(e3, k3), d4.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h4 ? f2 = wh(h4, f2) : (f2 = Ah(f2, g2, c3, null), f2.flags |= 2);
    f2.return = b3;
    d4.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    d4 = f2;
    f2 = b3.child;
    g2 = a4.child.memoizedState;
    g2 = null === g2 ? oj(c3) : { baseLanes: g2.baseLanes | c3, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a4.childLanes & ~c3;
    b3.memoizedState = nj;
    return d4;
  }
  f2 = a4.child;
  a4 = f2.sibling;
  d4 = wh(f2, { mode: "visible", children: d4.children });
  0 === (b3.mode & 1) && (d4.lanes = c3);
  d4.return = b3;
  d4.sibling = null;
  null !== a4 && (c3 = b3.deletions, null === c3 ? (b3.deletions = [a4], b3.flags |= 16) : c3.push(a4));
  b3.child = d4;
  b3.memoizedState = null;
  return d4;
}
function rj(a4, b3) {
  b3 = qj({ mode: "visible", children: b3 }, a4.mode, 0, null);
  b3.return = a4;
  return a4.child = b3;
}
function tj(a4, b3, c3, d4) {
  null !== d4 && Jg(d4);
  Bh(b3, a4.child, null, c3);
  a4 = rj(b3, b3.pendingProps.children);
  a4.flags |= 2;
  b3.memoizedState = null;
  return a4;
}
function sj(a4, b3, c3, d4, e3, f2, g2) {
  if (c3) {
    if (b3.flags & 256)
      return b3.flags &= -257, d4 = Li(Error(p$6(422))), tj(a4, b3, g2, d4);
    if (null !== b3.memoizedState)
      return b3.child = a4.child, b3.flags |= 128, null;
    f2 = d4.fallback;
    e3 = b3.mode;
    d4 = qj({ mode: "visible", children: d4.children }, e3, 0, null);
    f2 = Ah(f2, e3, g2, null);
    f2.flags |= 2;
    d4.return = b3;
    f2.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    0 !== (b3.mode & 1) && Bh(b3, a4.child, null, g2);
    b3.child.memoizedState = oj(g2);
    b3.memoizedState = nj;
    return f2;
  }
  if (0 === (b3.mode & 1))
    return tj(a4, b3, g2, null);
  if ("$!" === e3.data) {
    d4 = e3.nextSibling && e3.nextSibling.dataset;
    if (d4)
      var h4 = d4.dgst;
    d4 = h4;
    f2 = Error(p$6(419));
    d4 = Li(f2, d4, void 0);
    return tj(a4, b3, g2, d4);
  }
  h4 = 0 !== (g2 & a4.childLanes);
  if (Ug || h4) {
    d4 = R$1;
    if (null !== d4) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d4.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a4, e3), mh(d4, a4, e3, -1));
    }
    uj();
    d4 = Li(Error(p$6(421)));
    return tj(a4, b3, g2, d4);
  }
  if ("$?" === e3.data)
    return b3.flags |= 128, b3.child = a4.child, b3 = vj.bind(null, a4), e3._reactRetry = b3, null;
  a4 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b3;
  I$2 = true;
  zg = null;
  null !== a4 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a4.id, sg = a4.overflow, qg = b3);
  b3 = rj(b3, d4.children);
  b3.flags |= 4096;
  return b3;
}
function wj(a4, b3, c3) {
  a4.lanes |= b3;
  var d4 = a4.alternate;
  null !== d4 && (d4.lanes |= b3);
  Sg(a4.return, b3, c3);
}
function xj(a4, b3, c3, d4, e3) {
  var f2 = a4.memoizedState;
  null === f2 ? a4.memoizedState = { isBackwards: b3, rendering: null, renderingStartTime: 0, last: d4, tail: c3, tailMode: e3 } : (f2.isBackwards = b3, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d4, f2.tail = c3, f2.tailMode = e3);
}
function yj(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.revealOrder, f2 = d4.tail;
  Yi(a4, b3, d4.children, c3);
  d4 = M$2.current;
  if (0 !== (d4 & 2))
    d4 = d4 & 1 | 2, b3.flags |= 128;
  else {
    if (null !== a4 && 0 !== (a4.flags & 128))
      a:
        for (a4 = b3.child; null !== a4; ) {
          if (13 === a4.tag)
            null !== a4.memoizedState && wj(a4, c3, b3);
          else if (19 === a4.tag)
            wj(a4, c3, b3);
          else if (null !== a4.child) {
            a4.child.return = a4;
            a4 = a4.child;
            continue;
          }
          if (a4 === b3)
            break a;
          for (; null === a4.sibling; ) {
            if (null === a4.return || a4.return === b3)
              break a;
            a4 = a4.return;
          }
          a4.sibling.return = a4.return;
          a4 = a4.sibling;
        }
    d4 &= 1;
  }
  G$1(M$2, d4);
  if (0 === (b3.mode & 1))
    b3.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c3 = b3.child;
        for (e3 = null; null !== c3; )
          a4 = c3.alternate, null !== a4 && null === Mh(a4) && (e3 = c3), c3 = c3.sibling;
        c3 = e3;
        null === c3 ? (e3 = b3.child, b3.child = null) : (e3 = c3.sibling, c3.sibling = null);
        xj(b3, false, e3, c3, f2);
        break;
      case "backwards":
        c3 = null;
        e3 = b3.child;
        for (b3.child = null; null !== e3; ) {
          a4 = e3.alternate;
          if (null !== a4 && null === Mh(a4)) {
            b3.child = e3;
            break;
          }
          a4 = e3.sibling;
          e3.sibling = c3;
          c3 = e3;
          e3 = a4;
        }
        xj(b3, true, c3, null, f2);
        break;
      case "together":
        xj(b3, false, null, null, void 0);
        break;
      default:
        b3.memoizedState = null;
    }
  return b3.child;
}
function jj(a4, b3) {
  0 === (b3.mode & 1) && null !== a4 && (a4.alternate = null, b3.alternate = null, b3.flags |= 2);
}
function $i(a4, b3, c3) {
  null !== a4 && (b3.dependencies = a4.dependencies);
  hh |= b3.lanes;
  if (0 === (c3 & b3.childLanes))
    return null;
  if (null !== a4 && b3.child !== a4.child)
    throw Error(p$6(153));
  if (null !== b3.child) {
    a4 = b3.child;
    c3 = wh(a4, a4.pendingProps);
    b3.child = c3;
    for (c3.return = b3; null !== a4.sibling; )
      a4 = a4.sibling, c3 = c3.sibling = wh(a4, a4.pendingProps), c3.return = b3;
    c3.sibling = null;
  }
  return b3.child;
}
function zj(a4, b3, c3) {
  switch (b3.tag) {
    case 3:
      lj(b3);
      Ig();
      break;
    case 5:
      Kh(b3);
      break;
    case 1:
      Zf(b3.type) && cg(b3);
      break;
    case 4:
      Ih(b3, b3.stateNode.containerInfo);
      break;
    case 10:
      var d4 = b3.type._context, e3 = b3.memoizedProps.value;
      G$1(Mg, d4._currentValue);
      d4._currentValue = e3;
      break;
    case 13:
      d4 = b3.memoizedState;
      if (null !== d4) {
        if (null !== d4.dehydrated)
          return G$1(M$2, M$2.current & 1), b3.flags |= 128, null;
        if (0 !== (c3 & b3.child.childLanes))
          return pj(a4, b3, c3);
        G$1(M$2, M$2.current & 1);
        a4 = $i(a4, b3, c3);
        return null !== a4 ? a4.sibling : null;
      }
      G$1(M$2, M$2.current & 1);
      break;
    case 19:
      d4 = 0 !== (c3 & b3.childLanes);
      if (0 !== (a4.flags & 128)) {
        if (d4)
          return yj(a4, b3, c3);
        b3.flags |= 128;
      }
      e3 = b3.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$1(M$2, M$2.current);
      if (d4)
        break;
      else
        return null;
    case 22:
    case 23:
      return b3.lanes = 0, ej(a4, b3, c3);
  }
  return $i(a4, b3, c3);
}
var Aj, Bj, Cj, Dj;
Aj = function(a4, b3) {
  for (var c3 = b3.child; null !== c3; ) {
    if (5 === c3.tag || 6 === c3.tag)
      a4.appendChild(c3.stateNode);
    else if (4 !== c3.tag && null !== c3.child) {
      c3.child.return = c3;
      c3 = c3.child;
      continue;
    }
    if (c3 === b3)
      break;
    for (; null === c3.sibling; ) {
      if (null === c3.return || c3.return === b3)
        return;
      c3 = c3.return;
    }
    c3.sibling.return = c3.return;
    c3 = c3.sibling;
  }
};
Bj = function() {
};
Cj = function(a4, b3, c3, d4) {
  var e3 = a4.memoizedProps;
  if (e3 !== d4) {
    a4 = b3.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c3) {
      case "input":
        e3 = Ya(a4, e3);
        d4 = Ya(a4, d4);
        f2 = [];
        break;
      case "select":
        e3 = A$2({}, e3, { value: void 0 });
        d4 = A$2({}, d4, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a4, e3);
        d4 = gb(a4, d4);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d4.onClick && (a4.onclick = Bf);
    }
    ub(c3, d4);
    var g2;
    c3 = null;
    for (l2 in e3)
      if (!d4.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h4 = e3[l2];
          for (g2 in h4)
            h4.hasOwnProperty(g2) && (c3 || (c3 = {}), c3[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d4) {
      var k3 = d4[l2];
      h4 = null != e3 ? e3[l2] : void 0;
      if (d4.hasOwnProperty(l2) && k3 !== h4 && (null != k3 || null != h4))
        if ("style" === l2)
          if (h4) {
            for (g2 in h4)
              !h4.hasOwnProperty(g2) || k3 && k3.hasOwnProperty(g2) || (c3 || (c3 = {}), c3[g2] = "");
            for (g2 in k3)
              k3.hasOwnProperty(g2) && h4[g2] !== k3[g2] && (c3 || (c3 = {}), c3[g2] = k3[g2]);
          } else
            c3 || (f2 || (f2 = []), f2.push(
              l2,
              c3
            )), c3 = k3;
        else
          "dangerouslySetInnerHTML" === l2 ? (k3 = k3 ? k3.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k3 && h4 !== k3 && (f2 = f2 || []).push(l2, k3)) : "children" === l2 ? "string" !== typeof k3 && "number" !== typeof k3 || (f2 = f2 || []).push(l2, "" + k3) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k3 && "onScroll" === l2 && D$2("scroll", a4), f2 || h4 === k3 || (f2 = [])) : (f2 = f2 || []).push(l2, k3));
    }
    c3 && (f2 = f2 || []).push("style", c3);
    var l2 = f2;
    if (b3.updateQueue = l2)
      b3.flags |= 4;
  }
};
Dj = function(a4, b3, c3, d4) {
  c3 !== d4 && (b3.flags |= 4);
};
function Ej(a4, b3) {
  if (!I$2)
    switch (a4.tailMode) {
      case "hidden":
        b3 = a4.tail;
        for (var c3 = null; null !== b3; )
          null !== b3.alternate && (c3 = b3), b3 = b3.sibling;
        null === c3 ? a4.tail = null : c3.sibling = null;
        break;
      case "collapsed":
        c3 = a4.tail;
        for (var d4 = null; null !== c3; )
          null !== c3.alternate && (d4 = c3), c3 = c3.sibling;
        null === d4 ? b3 || null === a4.tail ? a4.tail = null : a4.tail.sibling = null : d4.sibling = null;
    }
}
function S$2(a4) {
  var b3 = null !== a4.alternate && a4.alternate.child === a4.child, c3 = 0, d4 = 0;
  if (b3)
    for (var e3 = a4.child; null !== e3; )
      c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags & 14680064, d4 |= e3.flags & 14680064, e3.return = a4, e3 = e3.sibling;
  else
    for (e3 = a4.child; null !== e3; )
      c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags, d4 |= e3.flags, e3.return = a4, e3 = e3.sibling;
  a4.subtreeFlags |= d4;
  a4.childLanes = c3;
  return b3;
}
function Fj(a4, b3, c3) {
  var d4 = b3.pendingProps;
  wg(b3);
  switch (b3.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b3), null;
    case 1:
      return Zf(b3.type) && $f(), S$2(b3), null;
    case 3:
      d4 = b3.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$2);
      Oh();
      d4.pendingContext && (d4.context = d4.pendingContext, d4.pendingContext = null);
      if (null === a4 || null === a4.child)
        Gg(b3) ? b3.flags |= 4 : null === a4 || a4.memoizedState.isDehydrated && 0 === (b3.flags & 256) || (b3.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a4, b3);
      S$2(b3);
      return null;
    case 5:
      Lh(b3);
      var e3 = Hh(Gh.current);
      c3 = b3.type;
      if (null !== a4 && null != b3.stateNode)
        Cj(a4, b3, c3, d4, e3), a4.ref !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      else {
        if (!d4) {
          if (null === b3.stateNode)
            throw Error(p$6(166));
          S$2(b3);
          return null;
        }
        a4 = Hh(Eh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.type;
          var f2 = b3.memoizedProps;
          d4[Of] = b3;
          d4[Pf] = f2;
          a4 = 0 !== (b3.mode & 1);
          switch (c3) {
            case "dialog":
              D$2("cancel", d4);
              D$2("close", d4);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d4);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$2(lf[e3], d4);
              break;
            case "source":
              D$2("error", d4);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d4
              );
              D$2("load", d4);
              break;
            case "details":
              D$2("toggle", d4);
              break;
            case "input":
              Za(d4, f2);
              D$2("invalid", d4);
              break;
            case "select":
              d4._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d4);
              break;
            case "textarea":
              hb(d4, f2), D$2("invalid", d4);
          }
          ub(c3, f2);
          e3 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h4 = f2[g2];
              "children" === g2 ? "string" === typeof h4 ? d4.textContent !== h4 && (true !== f2.suppressHydrationWarning && Af(d4.textContent, h4, a4), e3 = ["children", h4]) : "number" === typeof h4 && d4.textContent !== "" + h4 && (true !== f2.suppressHydrationWarning && Af(
                d4.textContent,
                h4,
                a4
              ), e3 = ["children", "" + h4]) : ea.hasOwnProperty(g2) && null != h4 && "onScroll" === g2 && D$2("scroll", d4);
            }
          switch (c3) {
            case "input":
              Va(d4);
              db(d4, f2, true);
              break;
            case "textarea":
              Va(d4);
              jb(d4);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d4.onclick = Bf);
          }
          d4 = e3;
          b3.updateQueue = d4;
          null !== d4 && (b3.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a4 && (a4 = kb(c3));
          "http://www.w3.org/1999/xhtml" === a4 ? "script" === c3 ? (a4 = g2.createElement("div"), a4.innerHTML = "<script><\/script>", a4 = a4.removeChild(a4.firstChild)) : "string" === typeof d4.is ? a4 = g2.createElement(c3, { is: d4.is }) : (a4 = g2.createElement(c3), "select" === c3 && (g2 = a4, d4.multiple ? g2.multiple = true : d4.size && (g2.size = d4.size))) : a4 = g2.createElementNS(a4, c3);
          a4[Of] = b3;
          a4[Pf] = d4;
          Aj(a4, b3, false, false);
          b3.stateNode = a4;
          a: {
            g2 = vb(c3, d4);
            switch (c3) {
              case "dialog":
                D$2("cancel", a4);
                D$2("close", a4);
                e3 = d4;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a4);
                e3 = d4;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$2(lf[e3], a4);
                e3 = d4;
                break;
              case "source":
                D$2("error", a4);
                e3 = d4;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a4
                );
                D$2("load", a4);
                e3 = d4;
                break;
              case "details":
                D$2("toggle", a4);
                e3 = d4;
                break;
              case "input":
                Za(a4, d4);
                e3 = Ya(a4, d4);
                D$2("invalid", a4);
                break;
              case "option":
                e3 = d4;
                break;
              case "select":
                a4._wrapperState = { wasMultiple: !!d4.multiple };
                e3 = A$2({}, d4, { value: void 0 });
                D$2("invalid", a4);
                break;
              case "textarea":
                hb(a4, d4);
                e3 = gb(a4, d4);
                D$2("invalid", a4);
                break;
              default:
                e3 = d4;
            }
            ub(c3, e3);
            h4 = e3;
            for (f2 in h4)
              if (h4.hasOwnProperty(f2)) {
                var k3 = h4[f2];
                "style" === f2 ? sb(a4, k3) : "dangerouslySetInnerHTML" === f2 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a4, k3)) : "children" === f2 ? "string" === typeof k3 ? ("textarea" !== c3 || "" !== k3) && ob(a4, k3) : "number" === typeof k3 && ob(a4, "" + k3) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k3 && "onScroll" === f2 && D$2("scroll", a4) : null != k3 && ta(a4, f2, k3, g2));
              }
            switch (c3) {
              case "input":
                Va(a4);
                db(a4, d4, false);
                break;
              case "textarea":
                Va(a4);
                jb(a4);
                break;
              case "option":
                null != d4.value && a4.setAttribute("value", "" + Sa(d4.value));
                break;
              case "select":
                a4.multiple = !!d4.multiple;
                f2 = d4.value;
                null != f2 ? fb(a4, !!d4.multiple, f2, false) : null != d4.defaultValue && fb(
                  a4,
                  !!d4.multiple,
                  d4.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a4.onclick = Bf);
            }
            switch (c3) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d4 = !!d4.autoFocus;
                break a;
              case "img":
                d4 = true;
                break a;
              default:
                d4 = false;
            }
          }
          d4 && (b3.flags |= 4);
        }
        null !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      }
      S$2(b3);
      return null;
    case 6:
      if (a4 && null != b3.stateNode)
        Dj(a4, b3, a4.memoizedProps, d4);
      else {
        if ("string" !== typeof d4 && null === b3.stateNode)
          throw Error(p$6(166));
        c3 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.memoizedProps;
          d4[Of] = b3;
          if (f2 = d4.nodeValue !== c3) {
            if (a4 = xg, null !== a4)
              switch (a4.tag) {
                case 3:
                  Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
                  break;
                case 5:
                  true !== a4.memoizedProps.suppressHydrationWarning && Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
              }
          }
          f2 && (b3.flags |= 4);
        } else
          d4 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d4), d4[Of] = b3, b3.stateNode = d4;
      }
      S$2(b3);
      return null;
    case 13:
      E$1(M$2);
      d4 = b3.memoizedState;
      if (null === a4 || null !== a4.memoizedState && null !== a4.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128))
          Hg(), Ig(), b3.flags |= 98560, f2 = false;
        else if (f2 = Gg(b3), null !== d4 && null !== d4.dehydrated) {
          if (null === a4) {
            if (!f2)
              throw Error(p$6(318));
            f2 = b3.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$6(317));
            f2[Of] = b3;
          } else
            Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), b3.flags |= 4;
          S$2(b3);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b3.flags & 65536 ? b3 : null;
      }
      if (0 !== (b3.flags & 128))
        return b3.lanes = c3, b3;
      d4 = null !== d4;
      d4 !== (null !== a4 && null !== a4.memoizedState) && d4 && (b3.child.flags |= 8192, 0 !== (b3.mode & 1) && (null === a4 || 0 !== (M$2.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b3.updateQueue && (b3.flags |= 4);
      S$2(b3);
      return null;
    case 4:
      return Jh(), Bj(a4, b3), null === a4 && sf(b3.stateNode.containerInfo), S$2(b3), null;
    case 10:
      return Rg(b3.type._context), S$2(b3), null;
    case 17:
      return Zf(b3.type) && $f(), S$2(b3), null;
    case 19:
      E$1(M$2);
      f2 = b3.memoizedState;
      if (null === f2)
        return S$2(b3), null;
      d4 = 0 !== (b3.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d4)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a4 && 0 !== (a4.flags & 128))
            for (a4 = b3.child; null !== a4; ) {
              g2 = Mh(a4);
              if (null !== g2) {
                b3.flags |= 128;
                Ej(f2, false);
                d4 = g2.updateQueue;
                null !== d4 && (b3.updateQueue = d4, b3.flags |= 4);
                b3.subtreeFlags = 0;
                d4 = c3;
                for (c3 = b3.child; null !== c3; )
                  f2 = c3, a4 = d4, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a4, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a4 = g2.dependencies, f2.dependencies = null === a4 ? null : { lanes: a4.lanes, firstContext: a4.firstContext }), c3 = c3.sibling;
                G$1(M$2, M$2.current & 1 | 2);
                return b3.child;
              }
              a4 = a4.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b3.flags |= 128, d4 = true, Ej(f2, false), b3.lanes = 4194304);
        }
      else {
        if (!d4)
          if (a4 = Mh(g2), null !== a4) {
            if (b3.flags |= 128, d4 = true, c3 = a4.updateQueue, null !== c3 && (b3.updateQueue = c3, b3.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$2(b3), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c3 && (b3.flags |= 128, d4 = true, Ej(f2, false), b3.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b3.child, b3.child = g2) : (c3 = f2.last, null !== c3 ? c3.sibling = g2 : b3.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b3 = f2.tail, f2.rendering = b3, f2.tail = b3.sibling, f2.renderingStartTime = B$1(), b3.sibling = null, c3 = M$2.current, G$1(M$2, d4 ? c3 & 1 | 2 : c3 & 1), b3;
      S$2(b3);
      return null;
    case 22:
    case 23:
      return Ij(), d4 = null !== b3.memoizedState, null !== a4 && null !== a4.memoizedState !== d4 && (b3.flags |= 8192), d4 && 0 !== (b3.mode & 1) ? 0 !== (gj & 1073741824) && (S$2(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192)) : S$2(b3), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$6(156, b3.tag));
}
function Jj(a4, b3) {
  wg(b3);
  switch (b3.tag) {
    case 1:
      return Zf(b3.type) && $f(), a4 = b3.flags, a4 & 65536 ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a4 = b3.flags, 0 !== (a4 & 65536) && 0 === (a4 & 128) ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 5:
      return Lh(b3), null;
    case 13:
      E$1(M$2);
      a4 = b3.memoizedState;
      if (null !== a4 && null !== a4.dehydrated) {
        if (null === b3.alternate)
          throw Error(p$6(340));
        Ig();
      }
      a4 = b3.flags;
      return a4 & 65536 ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 19:
      return E$1(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b3.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a4, b3) {
  var c3 = a4.ref;
  if (null !== c3)
    if ("function" === typeof c3)
      try {
        c3(null);
      } catch (d4) {
        W(a4, b3, d4);
      }
    else
      c3.current = null;
}
function Nj(a4, b3, c3) {
  try {
    c3();
  } catch (d4) {
    W(a4, b3, d4);
  }
}
var Oj = false;
function Pj(a4, b3) {
  Cf = dd;
  a4 = Me();
  if (Ne(a4)) {
    if ("selectionStart" in a4)
      var c3 = { start: a4.selectionStart, end: a4.selectionEnd };
    else
      a: {
        c3 = (c3 = a4.ownerDocument) && c3.defaultView || window;
        var d4 = c3.getSelection && c3.getSelection();
        if (d4 && 0 !== d4.rangeCount) {
          c3 = d4.anchorNode;
          var e3 = d4.anchorOffset, f2 = d4.focusNode;
          d4 = d4.focusOffset;
          try {
            c3.nodeType, f2.nodeType;
          } catch (F2) {
            c3 = null;
            break a;
          }
          var g2 = 0, h4 = -1, k3 = -1, l2 = 0, m4 = 0, q3 = a4, r3 = null;
          b:
            for (; ; ) {
              for (var y4; ; ) {
                q3 !== c3 || 0 !== e3 && 3 !== q3.nodeType || (h4 = g2 + e3);
                q3 !== f2 || 0 !== d4 && 3 !== q3.nodeType || (k3 = g2 + d4);
                3 === q3.nodeType && (g2 += q3.nodeValue.length);
                if (null === (y4 = q3.firstChild))
                  break;
                r3 = q3;
                q3 = y4;
              }
              for (; ; ) {
                if (q3 === a4)
                  break b;
                r3 === c3 && ++l2 === e3 && (h4 = g2);
                r3 === f2 && ++m4 === d4 && (k3 = g2);
                if (null !== (y4 = q3.nextSibling))
                  break;
                q3 = r3;
                r3 = q3.parentNode;
              }
              q3 = y4;
            }
          c3 = -1 === h4 || -1 === k3 ? null : { start: h4, end: k3 };
        } else
          c3 = null;
      }
    c3 = c3 || { start: 0, end: 0 };
  } else
    c3 = null;
  Df = { focusedElem: a4, selectionRange: c3 };
  dd = false;
  for (V = b3; null !== V; )
    if (b3 = V, a4 = b3.child, 0 !== (b3.subtreeFlags & 1028) && null !== a4)
      a4.return = b3, V = a4;
    else
      for (; null !== V; ) {
        b3 = V;
        try {
          var n2 = b3.alternate;
          if (0 !== (b3.flags & 1024))
            switch (b3.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t4 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b3.stateNode, w3 = x2.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t4 : Lg(b3.type, t4), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w3;
                }
                break;
              case 3:
                var u3 = b3.stateNode.containerInfo;
                1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$6(163));
            }
        } catch (F2) {
          W(b3, b3.return, F2);
        }
        a4 = b3.sibling;
        if (null !== a4) {
          a4.return = b3.return;
          V = a4;
          break;
        }
        V = b3.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a4, b3, c3) {
  var d4 = b3.updateQueue;
  d4 = null !== d4 ? d4.lastEffect : null;
  if (null !== d4) {
    var e3 = d4 = d4.next;
    do {
      if ((e3.tag & a4) === a4) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b3, c3, f2);
      }
      e3 = e3.next;
    } while (e3 !== d4);
  }
}
function Rj(a4, b3) {
  b3 = b3.updateQueue;
  b3 = null !== b3 ? b3.lastEffect : null;
  if (null !== b3) {
    var c3 = b3 = b3.next;
    do {
      if ((c3.tag & a4) === a4) {
        var d4 = c3.create;
        c3.destroy = d4();
      }
      c3 = c3.next;
    } while (c3 !== b3);
  }
}
function Sj(a4) {
  var b3 = a4.ref;
  if (null !== b3) {
    var c3 = a4.stateNode;
    switch (a4.tag) {
      case 5:
        a4 = c3;
        break;
      default:
        a4 = c3;
    }
    "function" === typeof b3 ? b3(a4) : b3.current = a4;
  }
}
function Tj(a4) {
  var b3 = a4.alternate;
  null !== b3 && (a4.alternate = null, Tj(b3));
  a4.child = null;
  a4.deletions = null;
  a4.sibling = null;
  5 === a4.tag && (b3 = a4.stateNode, null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]));
  a4.stateNode = null;
  a4.return = null;
  a4.dependencies = null;
  a4.memoizedProps = null;
  a4.memoizedState = null;
  a4.pendingProps = null;
  a4.stateNode = null;
  a4.updateQueue = null;
}
function Uj(a4) {
  return 5 === a4.tag || 3 === a4.tag || 4 === a4.tag;
}
function Vj(a4) {
  a:
    for (; ; ) {
      for (; null === a4.sibling; ) {
        if (null === a4.return || Uj(a4.return))
          return null;
        a4 = a4.return;
      }
      a4.sibling.return = a4.return;
      for (a4 = a4.sibling; 5 !== a4.tag && 6 !== a4.tag && 18 !== a4.tag; ) {
        if (a4.flags & 2)
          continue a;
        if (null === a4.child || 4 === a4.tag)
          continue a;
        else
          a4.child.return = a4, a4 = a4.child;
      }
      if (!(a4.flags & 2))
        return a4.stateNode;
    }
}
function Wj(a4, b3, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4)
    a4 = a4.stateNode, b3 ? 8 === c3.nodeType ? c3.parentNode.insertBefore(a4, b3) : c3.insertBefore(a4, b3) : (8 === c3.nodeType ? (b3 = c3.parentNode, b3.insertBefore(a4, c3)) : (b3 = c3, b3.appendChild(a4)), c3 = c3._reactRootContainer, null !== c3 && void 0 !== c3 || null !== b3.onclick || (b3.onclick = Bf));
  else if (4 !== d4 && (a4 = a4.child, null !== a4))
    for (Wj(a4, b3, c3), a4 = a4.sibling; null !== a4; )
      Wj(a4, b3, c3), a4 = a4.sibling;
}
function Xj(a4, b3, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4)
    a4 = a4.stateNode, b3 ? c3.insertBefore(a4, b3) : c3.appendChild(a4);
  else if (4 !== d4 && (a4 = a4.child, null !== a4))
    for (Xj(a4, b3, c3), a4 = a4.sibling; null !== a4; )
      Xj(a4, b3, c3), a4 = a4.sibling;
}
var X$1 = null, Yj = false;
function Zj(a4, b3, c3) {
  for (c3 = c3.child; null !== c3; )
    ak(a4, b3, c3), c3 = c3.sibling;
}
function ak(a4, b3, c3) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c3);
    } catch (h4) {
    }
  switch (c3.tag) {
    case 5:
      U || Mj(c3, b3);
    case 6:
      var d4 = X$1, e3 = Yj;
      X$1 = null;
      Zj(a4, b3, c3);
      X$1 = d4;
      Yj = e3;
      null !== X$1 && (Yj ? (a4 = X$1, c3 = c3.stateNode, 8 === a4.nodeType ? a4.parentNode.removeChild(c3) : a4.removeChild(c3)) : X$1.removeChild(c3.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a4 = X$1, c3 = c3.stateNode, 8 === a4.nodeType ? Kf(a4.parentNode, c3) : 1 === a4.nodeType && Kf(a4, c3), bd(a4)) : Kf(X$1, c3.stateNode));
      break;
    case 4:
      d4 = X$1;
      e3 = Yj;
      X$1 = c3.stateNode.containerInfo;
      Yj = true;
      Zj(a4, b3, c3);
      X$1 = d4;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d4 = c3.updateQueue, null !== d4 && (d4 = d4.lastEffect, null !== d4))) {
        e3 = d4 = d4.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c3, b3, g2) : 0 !== (f2 & 4) && Nj(c3, b3, g2));
          e3 = e3.next;
        } while (e3 !== d4);
      }
      Zj(a4, b3, c3);
      break;
    case 1:
      if (!U && (Mj(c3, b3), d4 = c3.stateNode, "function" === typeof d4.componentWillUnmount))
        try {
          d4.props = c3.memoizedProps, d4.state = c3.memoizedState, d4.componentWillUnmount();
        } catch (h4) {
          W(c3, b3, h4);
        }
      Zj(a4, b3, c3);
      break;
    case 21:
      Zj(a4, b3, c3);
      break;
    case 22:
      c3.mode & 1 ? (U = (d4 = U) || null !== c3.memoizedState, Zj(a4, b3, c3), U = d4) : Zj(a4, b3, c3);
      break;
    default:
      Zj(a4, b3, c3);
  }
}
function bk(a4) {
  var b3 = a4.updateQueue;
  if (null !== b3) {
    a4.updateQueue = null;
    var c3 = a4.stateNode;
    null === c3 && (c3 = a4.stateNode = new Lj());
    b3.forEach(function(b4) {
      var d4 = ck.bind(null, a4, b4);
      c3.has(b4) || (c3.add(b4), b4.then(d4, d4));
    });
  }
}
function dk(a4, b3) {
  var c3 = b3.deletions;
  if (null !== c3)
    for (var d4 = 0; d4 < c3.length; d4++) {
      var e3 = c3[d4];
      try {
        var f2 = a4, g2 = b3, h4 = g2;
        a:
          for (; null !== h4; ) {
            switch (h4.tag) {
              case 5:
                X$1 = h4.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h4.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h4.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h4 = h4.return;
          }
        if (null === X$1)
          throw Error(p$6(160));
        ak(f2, g2, e3);
        X$1 = null;
        Yj = false;
        var k3 = e3.alternate;
        null !== k3 && (k3.return = null);
        e3.return = null;
      } catch (l2) {
        W(e3, b3, l2);
      }
    }
  if (b3.subtreeFlags & 12854)
    for (b3 = b3.child; null !== b3; )
      ek(b3, a4), b3 = b3.sibling;
}
function ek(a4, b3) {
  var c3 = a4.alternate, d4 = a4.flags;
  switch (a4.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4) {
        try {
          Qj(3, a4, a4.return), Rj(3, a4);
        } catch (t4) {
          W(a4, a4.return, t4);
        }
        try {
          Qj(5, a4, a4.return);
        } catch (t4) {
          W(a4, a4.return, t4);
        }
      }
      break;
    case 1:
      dk(b3, a4);
      fk(a4);
      d4 & 512 && null !== c3 && Mj(c3, c3.return);
      break;
    case 5:
      dk(b3, a4);
      fk(a4);
      d4 & 512 && null !== c3 && Mj(c3, c3.return);
      if (a4.flags & 32) {
        var e3 = a4.stateNode;
        try {
          ob(e3, "");
        } catch (t4) {
          W(a4, a4.return, t4);
        }
      }
      if (d4 & 4 && (e3 = a4.stateNode, null != e3)) {
        var f2 = a4.memoizedProps, g2 = null !== c3 ? c3.memoizedProps : f2, h4 = a4.type, k3 = a4.updateQueue;
        a4.updateQueue = null;
        if (null !== k3)
          try {
            "input" === h4 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h4, g2);
            var l2 = vb(h4, f2);
            for (g2 = 0; g2 < k3.length; g2 += 2) {
              var m4 = k3[g2], q3 = k3[g2 + 1];
              "style" === m4 ? sb(e3, q3) : "dangerouslySetInnerHTML" === m4 ? nb(e3, q3) : "children" === m4 ? ob(e3, q3) : ta(e3, m4, q3, l2);
            }
            switch (h4) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r3 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y4 = f2.value;
                null != y4 ? fb(e3, !!f2.multiple, y4, false) : r3 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t4) {
            W(a4, a4.return, t4);
          }
      }
      break;
    case 6:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4) {
        if (null === a4.stateNode)
          throw Error(p$6(162));
        e3 = a4.stateNode;
        f2 = a4.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t4) {
          W(a4, a4.return, t4);
        }
      }
      break;
    case 3:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4 && null !== c3 && c3.memoizedState.isDehydrated)
        try {
          bd(b3.containerInfo);
        } catch (t4) {
          W(a4, a4.return, t4);
        }
      break;
    case 4:
      dk(b3, a4);
      fk(a4);
      break;
    case 13:
      dk(b3, a4);
      fk(a4);
      e3 = a4.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B$1()));
      d4 & 4 && bk(a4);
      break;
    case 22:
      m4 = null !== c3 && null !== c3.memoizedState;
      a4.mode & 1 ? (U = (l2 = U) || m4, dk(b3, a4), U = l2) : dk(b3, a4);
      fk(a4);
      if (d4 & 8192) {
        l2 = null !== a4.memoizedState;
        if ((a4.stateNode.isHidden = l2) && !m4 && 0 !== (a4.mode & 1))
          for (V = a4, m4 = a4.child; null !== m4; ) {
            for (q3 = V = m4; null !== V; ) {
              r3 = V;
              y4 = r3.child;
              switch (r3.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r3, r3.return);
                  break;
                case 1:
                  Mj(r3, r3.return);
                  var n2 = r3.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d4 = r3;
                    c3 = r3.return;
                    try {
                      b3 = d4, n2.props = b3.memoizedProps, n2.state = b3.memoizedState, n2.componentWillUnmount();
                    } catch (t4) {
                      W(d4, c3, t4);
                    }
                  }
                  break;
                case 5:
                  Mj(r3, r3.return);
                  break;
                case 22:
                  if (null !== r3.memoizedState) {
                    hk(q3);
                    continue;
                  }
              }
              null !== y4 ? (y4.return = r3, V = y4) : hk(q3);
            }
            m4 = m4.sibling;
          }
        a:
          for (m4 = null, q3 = a4; ; ) {
            if (5 === q3.tag) {
              if (null === m4) {
                m4 = q3;
                try {
                  e3 = q3.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h4 = q3.stateNode, k3 = q3.memoizedProps.style, g2 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h4.style.display = rb("display", g2));
                } catch (t4) {
                  W(a4, a4.return, t4);
                }
              }
            } else if (6 === q3.tag) {
              if (null === m4)
                try {
                  q3.stateNode.nodeValue = l2 ? "" : q3.memoizedProps;
                } catch (t4) {
                  W(a4, a4.return, t4);
                }
            } else if ((22 !== q3.tag && 23 !== q3.tag || null === q3.memoizedState || q3 === a4) && null !== q3.child) {
              q3.child.return = q3;
              q3 = q3.child;
              continue;
            }
            if (q3 === a4)
              break a;
            for (; null === q3.sibling; ) {
              if (null === q3.return || q3.return === a4)
                break a;
              m4 === q3 && (m4 = null);
              q3 = q3.return;
            }
            m4 === q3 && (m4 = null);
            q3.sibling.return = q3.return;
            q3 = q3.sibling;
          }
      }
      break;
    case 19:
      dk(b3, a4);
      fk(a4);
      d4 & 4 && bk(a4);
      break;
    case 21:
      break;
    default:
      dk(
        b3,
        a4
      ), fk(a4);
  }
}
function fk(a4) {
  var b3 = a4.flags;
  if (b3 & 2) {
    try {
      a: {
        for (var c3 = a4.return; null !== c3; ) {
          if (Uj(c3)) {
            var d4 = c3;
            break a;
          }
          c3 = c3.return;
        }
        throw Error(p$6(160));
      }
      switch (d4.tag) {
        case 5:
          var e3 = d4.stateNode;
          d4.flags & 32 && (ob(e3, ""), d4.flags &= -33);
          var f2 = Vj(a4);
          Xj(a4, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d4.stateNode.containerInfo, h4 = Vj(a4);
          Wj(a4, h4, g2);
          break;
        default:
          throw Error(p$6(161));
      }
    } catch (k3) {
      W(a4, a4.return, k3);
    }
    a4.flags &= -3;
  }
  b3 & 4096 && (a4.flags &= -4097);
}
function ik(a4, b3, c3) {
  V = a4;
  jk(a4);
}
function jk(a4, b3, c3) {
  for (var d4 = 0 !== (a4.mode & 1); null !== V; ) {
    var e3 = V, f2 = e3.child;
    if (22 === e3.tag && d4) {
      var g2 = null !== e3.memoizedState || Kj;
      if (!g2) {
        var h4 = e3.alternate, k3 = null !== h4 && null !== h4.memoizedState || U;
        h4 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k3) && !l2)
          for (V = e3; null !== V; )
            g2 = V, k3 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e3) : null !== k3 ? (k3.return = g2, V = k3) : kk(e3);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e3;
        Kj = h4;
        U = l2;
      }
      lk(a4);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V = f2) : lk(a4);
  }
}
function lk(a4) {
  for (; null !== V; ) {
    var b3 = V;
    if (0 !== (b3.flags & 8772)) {
      var c3 = b3.alternate;
      try {
        if (0 !== (b3.flags & 8772))
          switch (b3.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b3);
              break;
            case 1:
              var d4 = b3.stateNode;
              if (b3.flags & 4 && !U)
                if (null === c3)
                  d4.componentDidMount();
                else {
                  var e3 = b3.elementType === b3.type ? c3.memoizedProps : Lg(b3.type, c3.memoizedProps);
                  d4.componentDidUpdate(e3, c3.memoizedState, d4.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b3.updateQueue;
              null !== f2 && ih(b3, f2, d4);
              break;
            case 3:
              var g2 = b3.updateQueue;
              if (null !== g2) {
                c3 = null;
                if (null !== b3.child)
                  switch (b3.child.tag) {
                    case 5:
                      c3 = b3.child.stateNode;
                      break;
                    case 1:
                      c3 = b3.child.stateNode;
                  }
                ih(b3, g2, c3);
              }
              break;
            case 5:
              var h4 = b3.stateNode;
              if (null === c3 && b3.flags & 4) {
                c3 = h4;
                var k3 = b3.memoizedProps;
                switch (b3.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k3.autoFocus && c3.focus();
                    break;
                  case "img":
                    k3.src && (c3.src = k3.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b3.memoizedState) {
                var l2 = b3.alternate;
                if (null !== l2) {
                  var m4 = l2.memoizedState;
                  if (null !== m4) {
                    var q3 = m4.dehydrated;
                    null !== q3 && bd(q3);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$6(163));
          }
        U || b3.flags & 512 && Sj(b3);
      } catch (r3) {
        W(b3, b3.return, r3);
      }
    }
    if (b3 === a4) {
      V = null;
      break;
    }
    c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V = c3;
      break;
    }
    V = b3.return;
  }
}
function hk(a4) {
  for (; null !== V; ) {
    var b3 = V;
    if (b3 === a4) {
      V = null;
      break;
    }
    var c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V = c3;
      break;
    }
    V = b3.return;
  }
}
function kk(a4) {
  for (; null !== V; ) {
    var b3 = V;
    try {
      switch (b3.tag) {
        case 0:
        case 11:
        case 15:
          var c3 = b3.return;
          try {
            Rj(4, b3);
          } catch (k3) {
            W(b3, c3, k3);
          }
          break;
        case 1:
          var d4 = b3.stateNode;
          if ("function" === typeof d4.componentDidMount) {
            var e3 = b3.return;
            try {
              d4.componentDidMount();
            } catch (k3) {
              W(b3, e3, k3);
            }
          }
          var f2 = b3.return;
          try {
            Sj(b3);
          } catch (k3) {
            W(b3, f2, k3);
          }
          break;
        case 5:
          var g2 = b3.return;
          try {
            Sj(b3);
          } catch (k3) {
            W(b3, g2, k3);
          }
      }
    } catch (k3) {
      W(b3, b3.return, k3);
    }
    if (b3 === a4) {
      V = null;
      break;
    }
    var h4 = b3.sibling;
    if (null !== h4) {
      h4.return = b3.return;
      V = h4;
      break;
    }
    V = b3.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R$1 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a4) {
  if (0 === (a4.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a4 = C$1;
  if (0 !== a4)
    return a4;
  a4 = window.event;
  a4 = void 0 === a4 ? 16 : jd(a4.type);
  return a4;
}
function mh(a4, b3, c3, d4) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$6(185));
  Ac(a4, c3, d4);
  if (0 === (K & 2) || a4 !== R$1)
    a4 === R$1 && (0 === (K & 2) && (rk |= c3), 4 === T$1 && Dk(a4, Z$1)), Ek(a4, d4), 1 === c3 && 0 === K && 0 === (b3.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a4, b3) {
  var c3 = a4.callbackNode;
  wc(a4, b3);
  var d4 = uc(a4, a4 === R$1 ? Z$1 : 0);
  if (0 === d4)
    null !== c3 && bc(c3), a4.callbackNode = null, a4.callbackPriority = 0;
  else if (b3 = d4 & -d4, a4.callbackPriority !== b3) {
    null != c3 && bc(c3);
    if (1 === b3)
      0 === a4.tag ? ig(Fk.bind(null, a4)) : hg(Fk.bind(null, a4)), Jf(function() {
        0 === (K & 6) && jg();
      }), c3 = null;
    else {
      switch (Dc(d4)) {
        case 1:
          c3 = fc;
          break;
        case 4:
          c3 = gc;
          break;
        case 16:
          c3 = hc;
          break;
        case 536870912:
          c3 = jc;
          break;
        default:
          c3 = hc;
      }
      c3 = Gk(c3, Hk.bind(null, a4));
    }
    a4.callbackPriority = b3;
    a4.callbackNode = c3;
  }
}
function Hk(a4, b3) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$6(327));
  var c3 = a4.callbackNode;
  if (Ik() && a4.callbackNode !== c3)
    return null;
  var d4 = uc(a4, a4 === R$1 ? Z$1 : 0);
  if (0 === d4)
    return null;
  if (0 !== (d4 & 30) || 0 !== (d4 & a4.expiredLanes) || b3)
    b3 = Jk(a4, d4);
  else {
    b3 = d4;
    var e3 = K;
    K |= 2;
    var f2 = Kk();
    if (R$1 !== a4 || Z$1 !== b3)
      vk = null, Hj = B$1() + 500, Lk(a4, b3);
    do
      try {
        Mk();
        break;
      } catch (h4) {
        Nk(a4, h4);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e3;
    null !== Y$1 ? b3 = 0 : (R$1 = null, Z$1 = 0, b3 = T$1);
  }
  if (0 !== b3) {
    2 === b3 && (e3 = xc(a4), 0 !== e3 && (d4 = e3, b3 = Ok(a4, e3)));
    if (1 === b3)
      throw c3 = qk, Lk(a4, 0), Dk(a4, d4), Ek(a4, B$1()), c3;
    if (6 === b3)
      Dk(a4, d4);
    else {
      e3 = a4.current.alternate;
      if (0 === (d4 & 30) && !Pk(e3) && (b3 = Jk(a4, d4), 2 === b3 && (f2 = xc(a4), 0 !== f2 && (d4 = f2, b3 = Ok(a4, f2))), 1 === b3))
        throw c3 = qk, Lk(a4, 0), Dk(a4, d4), Ek(a4, B$1()), c3;
      a4.finishedWork = e3;
      a4.finishedLanes = d4;
      switch (b3) {
        case 0:
        case 1:
          throw Error(p$6(345));
        case 2:
          Qk(a4, uk, vk);
          break;
        case 3:
          Dk(a4, d4);
          if ((d4 & 130023424) === d4 && (b3 = gk + 500 - B$1(), 10 < b3)) {
            if (0 !== uc(a4, 0))
              break;
            e3 = a4.suspendedLanes;
            if ((e3 & d4) !== d4) {
              L();
              a4.pingedLanes |= a4.suspendedLanes & e3;
              break;
            }
            a4.timeoutHandle = Ff(Qk.bind(null, a4, uk, vk), b3);
            break;
          }
          Qk(a4, uk, vk);
          break;
        case 4:
          Dk(a4, d4);
          if ((d4 & 4194240) === d4)
            break;
          b3 = a4.eventTimes;
          for (e3 = -1; 0 < d4; ) {
            var g2 = 31 - oc(d4);
            f2 = 1 << g2;
            g2 = b3[g2];
            g2 > e3 && (e3 = g2);
            d4 &= ~f2;
          }
          d4 = e3;
          d4 = B$1() - d4;
          d4 = (120 > d4 ? 120 : 480 > d4 ? 480 : 1080 > d4 ? 1080 : 1920 > d4 ? 1920 : 3e3 > d4 ? 3e3 : 4320 > d4 ? 4320 : 1960 * mk(d4 / 1960)) - d4;
          if (10 < d4) {
            a4.timeoutHandle = Ff(Qk.bind(null, a4, uk, vk), d4);
            break;
          }
          Qk(a4, uk, vk);
          break;
        case 5:
          Qk(a4, uk, vk);
          break;
        default:
          throw Error(p$6(329));
      }
    }
  }
  Ek(a4, B$1());
  return a4.callbackNode === c3 ? Hk.bind(null, a4) : null;
}
function Ok(a4, b3) {
  var c3 = tk;
  a4.current.memoizedState.isDehydrated && (Lk(a4, b3).flags |= 256);
  a4 = Jk(a4, b3);
  2 !== a4 && (b3 = uk, uk = c3, null !== b3 && Gj(b3));
  return a4;
}
function Gj(a4) {
  null === uk ? uk = a4 : uk.push.apply(uk, a4);
}
function Pk(a4) {
  for (var b3 = a4; ; ) {
    if (b3.flags & 16384) {
      var c3 = b3.updateQueue;
      if (null !== c3 && (c3 = c3.stores, null !== c3))
        for (var d4 = 0; d4 < c3.length; d4++) {
          var e3 = c3[d4], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He(f2(), e3))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c3 = b3.child;
    if (b3.subtreeFlags & 16384 && null !== c3)
      c3.return = b3, b3 = c3;
    else {
      if (b3 === a4)
        break;
      for (; null === b3.sibling; ) {
        if (null === b3.return || b3.return === a4)
          return true;
        b3 = b3.return;
      }
      b3.sibling.return = b3.return;
      b3 = b3.sibling;
    }
  }
  return true;
}
function Dk(a4, b3) {
  b3 &= ~sk;
  b3 &= ~rk;
  a4.suspendedLanes |= b3;
  a4.pingedLanes &= ~b3;
  for (a4 = a4.expirationTimes; 0 < b3; ) {
    var c3 = 31 - oc(b3), d4 = 1 << c3;
    a4[c3] = -1;
    b3 &= ~d4;
  }
}
function Fk(a4) {
  if (0 !== (K & 6))
    throw Error(p$6(327));
  Ik();
  var b3 = uc(a4, 0);
  if (0 === (b3 & 1))
    return Ek(a4, B$1()), null;
  var c3 = Jk(a4, b3);
  if (0 !== a4.tag && 2 === c3) {
    var d4 = xc(a4);
    0 !== d4 && (b3 = d4, c3 = Ok(a4, d4));
  }
  if (1 === c3)
    throw c3 = qk, Lk(a4, 0), Dk(a4, b3), Ek(a4, B$1()), c3;
  if (6 === c3)
    throw Error(p$6(345));
  a4.finishedWork = a4.current.alternate;
  a4.finishedLanes = b3;
  Qk(a4, uk, vk);
  Ek(a4, B$1());
  return null;
}
function Rk(a4, b3) {
  var c3 = K;
  K |= 1;
  try {
    return a4(b3);
  } finally {
    K = c3, 0 === K && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a4) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b3 = K;
  K |= 1;
  var c3 = pk.transition, d4 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a4)
      return a4();
  } finally {
    C$1 = d4, pk.transition = c3, K = b3, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a4, b3) {
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  var c3 = a4.timeoutHandle;
  -1 !== c3 && (a4.timeoutHandle = -1, Gf(c3));
  if (null !== Y$1)
    for (c3 = Y$1.return; null !== c3; ) {
      var d4 = c3;
      wg(d4);
      switch (d4.tag) {
        case 1:
          d4 = d4.type.childContextTypes;
          null !== d4 && void 0 !== d4 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$2);
          Oh();
          break;
        case 5:
          Lh(d4);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$2);
          break;
        case 19:
          E$1(M$2);
          break;
        case 10:
          Rg(d4.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c3 = c3.return;
    }
  R$1 = a4;
  Y$1 = a4 = wh(a4.current, null);
  Z$1 = gj = b3;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b3 = 0; b3 < Wg.length; b3++)
      if (c3 = Wg[b3], d4 = c3.interleaved, null !== d4) {
        c3.interleaved = null;
        var e3 = d4.next, f2 = c3.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d4.next = g2;
        }
        c3.pending = d4;
      }
    Wg = null;
  }
  return a4;
}
function Nk(a4, b3) {
  do {
    var c3 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d4 = N$1.memoizedState; null !== d4; ) {
          var e3 = d4.queue;
          null !== e3 && (e3.pending = null);
          d4 = d4.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c3 || null === c3.return) {
        T$1 = 1;
        qk = b3;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a4, g2 = c3.return, h4 = c3, k3 = b3;
        b3 = Z$1;
        h4.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l2 = k3, m4 = h4, q3 = m4.tag;
          if (0 === (m4.mode & 1) && (0 === q3 || 11 === q3 || 15 === q3)) {
            var r3 = m4.alternate;
            r3 ? (m4.updateQueue = r3.updateQueue, m4.memoizedState = r3.memoizedState, m4.lanes = r3.lanes) : (m4.updateQueue = null, m4.memoizedState = null);
          }
          var y4 = Vi(g2);
          if (null !== y4) {
            y4.flags &= -257;
            Wi(y4, g2, h4, f2, b3);
            y4.mode & 1 && Ti(f2, l2, b3);
            b3 = y4;
            k3 = l2;
            var n2 = b3.updateQueue;
            if (null === n2) {
              var t4 = /* @__PURE__ */ new Set();
              t4.add(k3);
              b3.updateQueue = t4;
            } else
              n2.add(k3);
            break a;
          } else {
            if (0 === (b3 & 1)) {
              Ti(f2, l2, b3);
              uj();
              break a;
            }
            k3 = Error(p$6(426));
          }
        } else if (I$2 && h4.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h4, f2, b3);
            Jg(Ki(k3, h4));
            break a;
          }
        }
        f2 = k3 = Ki(k3, h4);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b3 &= -b3;
              f2.lanes |= b3;
              var x2 = Oi(f2, k3, b3);
              fh(f2, x2);
              break a;
            case 1:
              h4 = k3;
              var w3 = f2.type, u3 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Si || !Si.has(u3)))) {
                f2.flags |= 65536;
                b3 &= -b3;
                f2.lanes |= b3;
                var F2 = Ri(f2, h4, b3);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c3);
    } catch (na) {
      b3 = na;
      Y$1 === c3 && null !== c3 && (Y$1 = c3 = c3.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a4 = nk.current;
  nk.current = ai;
  return null === a4 ? ai : a4;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
}
function Jk(a4, b3) {
  var c3 = K;
  K |= 2;
  var d4 = Kk();
  if (R$1 !== a4 || Z$1 !== b3)
    vk = null, Lk(a4, b3);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a4, e3);
    }
  while (1);
  Qg();
  K = c3;
  nk.current = d4;
  if (null !== Y$1)
    throw Error(p$6(261));
  R$1 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a4) {
  var b3 = Wk(a4.alternate, a4, gj);
  a4.memoizedProps = a4.pendingProps;
  null === b3 ? Tk(a4) : Y$1 = b3;
  ok.current = null;
}
function Tk(a4) {
  var b3 = a4;
  do {
    var c3 = b3.alternate;
    a4 = b3.return;
    if (0 === (b3.flags & 32768)) {
      if (c3 = Fj(c3, b3, gj), null !== c3) {
        Y$1 = c3;
        return;
      }
    } else {
      c3 = Jj(c3, b3);
      if (null !== c3) {
        c3.flags &= 32767;
        Y$1 = c3;
        return;
      }
      if (null !== a4)
        a4.flags |= 32768, a4.subtreeFlags = 0, a4.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b3 = b3.sibling;
    if (null !== b3) {
      Y$1 = b3;
      return;
    }
    Y$1 = b3 = a4;
  } while (null !== b3);
  0 === T$1 && (T$1 = 5);
}
function Qk(a4, b3, c3) {
  var d4 = C$1, e3 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a4, b3, c3, d4);
  } finally {
    pk.transition = e3, C$1 = d4;
  }
  return null;
}
function Xk(a4, b3, c3, d4) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$6(327));
  c3 = a4.finishedWork;
  var e3 = a4.finishedLanes;
  if (null === c3)
    return null;
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  if (c3 === a4.current)
    throw Error(p$6(177));
  a4.callbackNode = null;
  a4.callbackPriority = 0;
  var f2 = c3.lanes | c3.childLanes;
  Bc(a4, f2);
  a4 === R$1 && (Y$1 = R$1 = null, Z$1 = 0);
  0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c3.flags & 15990);
  if (0 !== (c3.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h4 = K;
    K |= 4;
    ok.current = null;
    Pj(a4, c3);
    ek(c3, a4);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a4.current = c3;
    ik(c3);
    dc();
    K = h4;
    C$1 = g2;
    pk.transition = f2;
  } else
    a4.current = c3;
  wk && (wk = false, xk = a4, yk = e3);
  f2 = a4.pendingLanes;
  0 === f2 && (Si = null);
  mc(c3.stateNode);
  Ek(a4, B$1());
  if (null !== b3)
    for (d4 = a4.onRecoverableError, c3 = 0; c3 < b3.length; c3++)
      e3 = b3[c3], d4(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi)
    throw Pi = false, a4 = Qi, Qi = null, a4;
  0 !== (yk & 1) && 0 !== a4.tag && Ik();
  f2 = a4.pendingLanes;
  0 !== (f2 & 1) ? a4 === Ak ? zk++ : (zk = 0, Ak = a4) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a4 = Dc(yk), b3 = pk.transition, c3 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a4 ? 16 : a4;
      if (null === xk)
        var d4 = false;
      else {
        a4 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$6(331));
        var e3 = K;
        K |= 4;
        for (V = a4.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h4 = f2.deletions;
            if (null !== h4) {
              for (var k3 = 0; k3 < h4.length; k3++) {
                var l2 = h4[k3];
                for (V = l2; null !== V; ) {
                  var m4 = V;
                  switch (m4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m4, f2);
                  }
                  var q3 = m4.child;
                  if (null !== q3)
                    q3.return = m4, V = q3;
                  else
                    for (; null !== V; ) {
                      m4 = V;
                      var r3 = m4.sibling, y4 = m4.return;
                      Tj(m4);
                      if (m4 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r3) {
                        r3.return = y4;
                        V = r3;
                        break;
                      }
                      V = y4;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t4 = n2.child;
                if (null !== t4) {
                  n2.child = null;
                  do {
                    var J2 = t4.sibling;
                    t4.sibling = null;
                    t4 = J2;
                  } while (null !== t4);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w3 = a4.current;
        for (V = w3; null !== V; ) {
          g2 = V;
          var u3 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u3)
            u3.return = g2, V = u3;
          else
            b:
              for (g2 = w3; null !== V; ) {
                h4 = V;
                if (0 !== (h4.flags & 2048))
                  try {
                    switch (h4.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h4);
                    }
                  } catch (na) {
                    W(h4, h4.return, na);
                  }
                if (h4 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h4.sibling;
                if (null !== F2) {
                  F2.return = h4.return;
                  V = F2;
                  break b;
                }
                V = h4.return;
              }
        }
        K = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a4);
          } catch (na) {
          }
        d4 = true;
      }
      return d4;
    } finally {
      C$1 = c3, pk.transition = b3;
    }
  }
  return false;
}
function Yk(a4, b3, c3) {
  b3 = Ki(c3, b3);
  b3 = Oi(a4, b3, 1);
  a4 = dh(a4, b3, 1);
  b3 = L();
  null !== a4 && (Ac(a4, 1, b3), Ek(a4, b3));
}
function W(a4, b3, c3) {
  if (3 === a4.tag)
    Yk(a4, a4, c3);
  else
    for (; null !== b3; ) {
      if (3 === b3.tag) {
        Yk(b3, a4, c3);
        break;
      } else if (1 === b3.tag) {
        var d4 = b3.stateNode;
        if ("function" === typeof b3.type.getDerivedStateFromError || "function" === typeof d4.componentDidCatch && (null === Si || !Si.has(d4))) {
          a4 = Ki(c3, a4);
          a4 = Ri(b3, a4, 1);
          b3 = dh(b3, a4, 1);
          a4 = L();
          null !== b3 && (Ac(b3, 1, a4), Ek(b3, a4));
          break;
        }
      }
      b3 = b3.return;
    }
}
function Ui(a4, b3, c3) {
  var d4 = a4.pingCache;
  null !== d4 && d4.delete(b3);
  b3 = L();
  a4.pingedLanes |= a4.suspendedLanes & c3;
  R$1 === a4 && (Z$1 & c3) === c3 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk ? Lk(a4, 0) : sk |= c3);
  Ek(a4, b3);
}
function Zk(a4, b3) {
  0 === b3 && (0 === (a4.mode & 1) ? b3 = 1 : (b3 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c3 = L();
  a4 = Zg(a4, b3);
  null !== a4 && (Ac(a4, b3, c3), Ek(a4, c3));
}
function vj(a4) {
  var b3 = a4.memoizedState, c3 = 0;
  null !== b3 && (c3 = b3.retryLane);
  Zk(a4, c3);
}
function ck(a4, b3) {
  var c3 = 0;
  switch (a4.tag) {
    case 13:
      var d4 = a4.stateNode;
      var e3 = a4.memoizedState;
      null !== e3 && (c3 = e3.retryLane);
      break;
    case 19:
      d4 = a4.stateNode;
      break;
    default:
      throw Error(p$6(314));
  }
  null !== d4 && d4.delete(b3);
  Zk(a4, c3);
}
var Wk;
Wk = function(a4, b3, c3) {
  if (null !== a4)
    if (a4.memoizedProps !== b3.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a4.lanes & c3) && 0 === (b3.flags & 128))
        return Ug = false, zj(a4, b3, c3);
      Ug = 0 !== (a4.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index);
  b3.lanes = 0;
  switch (b3.tag) {
    case 2:
      var d4 = b3.type;
      jj(a4, b3);
      a4 = b3.pendingProps;
      var e3 = Yf(b3, H$2.current);
      Tg(b3, c3);
      e3 = Xh(null, b3, d4, a4, e3, c3);
      var f2 = bi();
      b3.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b3.tag = 1, b3.memoizedState = null, b3.updateQueue = null, Zf(d4) ? (f2 = true, cg(b3)) : f2 = false, b3.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b3), e3.updater = nh, b3.stateNode = e3, e3._reactInternals = b3, rh(b3, d4, a4, c3), b3 = kj(null, b3, d4, true, f2, c3)) : (b3.tag = 0, I$2 && f2 && vg(b3), Yi(null, b3, e3, c3), b3 = b3.child);
      return b3;
    case 16:
      d4 = b3.elementType;
      a: {
        jj(a4, b3);
        a4 = b3.pendingProps;
        e3 = d4._init;
        d4 = e3(d4._payload);
        b3.type = d4;
        e3 = b3.tag = $k(d4);
        a4 = Lg(d4, a4);
        switch (e3) {
          case 0:
            b3 = dj(null, b3, d4, a4, c3);
            break a;
          case 1:
            b3 = ij(null, b3, d4, a4, c3);
            break a;
          case 11:
            b3 = Zi(null, b3, d4, a4, c3);
            break a;
          case 14:
            b3 = aj(null, b3, d4, Lg(d4.type, a4), c3);
            break a;
        }
        throw Error(p$6(
          306,
          d4,
          ""
        ));
      }
      return b3;
    case 0:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), dj(a4, b3, d4, e3, c3);
    case 1:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), ij(a4, b3, d4, e3, c3);
    case 3:
      a: {
        lj(b3);
        if (null === a4)
          throw Error(p$6(387));
        d4 = b3.pendingProps;
        f2 = b3.memoizedState;
        e3 = f2.element;
        bh(a4, b3);
        gh(b3, d4, null, c3);
        var g2 = b3.memoizedState;
        d4 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d4, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b3.updateQueue.baseState = f2, b3.memoizedState = f2, b3.flags & 256) {
            e3 = Ki(Error(p$6(423)), b3);
            b3 = mj(a4, b3, d4, c3, e3);
            break a;
          } else if (d4 !== e3) {
            e3 = Ki(Error(p$6(424)), b3);
            b3 = mj(a4, b3, d4, c3, e3);
            break a;
          } else
            for (yg = Lf(b3.stateNode.containerInfo.firstChild), xg = b3, I$2 = true, zg = null, c3 = Ch(b3, null, d4, c3), b3.child = c3; c3; )
              c3.flags = c3.flags & -3 | 4096, c3 = c3.sibling;
        else {
          Ig();
          if (d4 === e3) {
            b3 = $i(a4, b3, c3);
            break a;
          }
          Yi(a4, b3, d4, c3);
        }
        b3 = b3.child;
      }
      return b3;
    case 5:
      return Kh(b3), null === a4 && Eg(b3), d4 = b3.type, e3 = b3.pendingProps, f2 = null !== a4 ? a4.memoizedProps : null, g2 = e3.children, Ef(d4, e3) ? g2 = null : null !== f2 && Ef(d4, f2) && (b3.flags |= 32), hj(a4, b3), Yi(a4, b3, g2, c3), b3.child;
    case 6:
      return null === a4 && Eg(b3), null;
    case 13:
      return pj(a4, b3, c3);
    case 4:
      return Ih(b3, b3.stateNode.containerInfo), d4 = b3.pendingProps, null === a4 ? b3.child = Bh(b3, null, d4, c3) : Yi(a4, b3, d4, c3), b3.child;
    case 11:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), Zi(a4, b3, d4, e3, c3);
    case 7:
      return Yi(a4, b3, b3.pendingProps, c3), b3.child;
    case 8:
      return Yi(a4, b3, b3.pendingProps.children, c3), b3.child;
    case 12:
      return Yi(a4, b3, b3.pendingProps.children, c3), b3.child;
    case 10:
      a: {
        d4 = b3.type._context;
        e3 = b3.pendingProps;
        f2 = b3.memoizedProps;
        g2 = e3.value;
        G$1(Mg, d4._currentValue);
        d4._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b3 = $i(a4, b3, c3);
              break a;
            }
          } else
            for (f2 = b3.child, null !== f2 && (f2.return = b3); null !== f2; ) {
              var h4 = f2.dependencies;
              if (null !== h4) {
                g2 = f2.child;
                for (var k3 = h4.firstContext; null !== k3; ) {
                  if (k3.context === d4) {
                    if (1 === f2.tag) {
                      k3 = ch(-1, c3 & -c3);
                      k3.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m4 = l2.pending;
                        null === m4 ? k3.next = k3 : (k3.next = m4.next, m4.next = k3);
                        l2.pending = k3;
                      }
                    }
                    f2.lanes |= c3;
                    k3 = f2.alternate;
                    null !== k3 && (k3.lanes |= c3);
                    Sg(
                      f2.return,
                      c3,
                      b3
                    );
                    h4.lanes |= c3;
                    break;
                  }
                  k3 = k3.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b3.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$6(341));
                g2.lanes |= c3;
                h4 = g2.alternate;
                null !== h4 && (h4.lanes |= c3);
                Sg(g2, c3, b3);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b3) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a4, b3, e3.children, c3);
        b3 = b3.child;
      }
      return b3;
    case 9:
      return e3 = b3.type, d4 = b3.pendingProps.children, Tg(b3, c3), e3 = Vg(e3), d4 = d4(e3), b3.flags |= 1, Yi(a4, b3, d4, c3), b3.child;
    case 14:
      return d4 = b3.type, e3 = Lg(d4, b3.pendingProps), e3 = Lg(d4.type, e3), aj(a4, b3, d4, e3, c3);
    case 15:
      return cj(a4, b3, b3.type, b3.pendingProps, c3);
    case 17:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), jj(a4, b3), b3.tag = 1, Zf(d4) ? (a4 = true, cg(b3)) : a4 = false, Tg(b3, c3), ph(b3, d4, e3), rh(b3, d4, e3, c3), kj(null, b3, d4, true, a4, c3);
    case 19:
      return yj(a4, b3, c3);
    case 22:
      return ej(a4, b3, c3);
  }
  throw Error(p$6(156, b3.tag));
};
function Gk(a4, b3) {
  return ac(a4, b3);
}
function al(a4, b3, c3, d4) {
  this.tag = a4;
  this.key = c3;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b3;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d4;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a4, b3, c3, d4) {
  return new al(a4, b3, c3, d4);
}
function bj(a4) {
  a4 = a4.prototype;
  return !(!a4 || !a4.isReactComponent);
}
function $k(a4) {
  if ("function" === typeof a4)
    return bj(a4) ? 1 : 0;
  if (void 0 !== a4 && null !== a4) {
    a4 = a4.$$typeof;
    if (a4 === Da)
      return 11;
    if (a4 === Ga)
      return 14;
  }
  return 2;
}
function wh(a4, b3) {
  var c3 = a4.alternate;
  null === c3 ? (c3 = Bg(a4.tag, b3, a4.key, a4.mode), c3.elementType = a4.elementType, c3.type = a4.type, c3.stateNode = a4.stateNode, c3.alternate = a4, a4.alternate = c3) : (c3.pendingProps = b3, c3.type = a4.type, c3.flags = 0, c3.subtreeFlags = 0, c3.deletions = null);
  c3.flags = a4.flags & 14680064;
  c3.childLanes = a4.childLanes;
  c3.lanes = a4.lanes;
  c3.child = a4.child;
  c3.memoizedProps = a4.memoizedProps;
  c3.memoizedState = a4.memoizedState;
  c3.updateQueue = a4.updateQueue;
  b3 = a4.dependencies;
  c3.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext };
  c3.sibling = a4.sibling;
  c3.index = a4.index;
  c3.ref = a4.ref;
  return c3;
}
function yh(a4, b3, c3, d4, e3, f2) {
  var g2 = 2;
  d4 = a4;
  if ("function" === typeof a4)
    bj(a4) && (g2 = 1);
  else if ("string" === typeof a4)
    g2 = 5;
  else
    a:
      switch (a4) {
        case ya:
          return Ah(c3.children, e3, f2, b3);
        case za:
          g2 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a4 = Bg(12, c3, b3, e3 | 2), a4.elementType = Aa, a4.lanes = f2, a4;
        case Ea:
          return a4 = Bg(13, c3, b3, e3), a4.elementType = Ea, a4.lanes = f2, a4;
        case Fa:
          return a4 = Bg(19, c3, b3, e3), a4.elementType = Fa, a4.lanes = f2, a4;
        case Ia:
          return qj(c3, e3, f2, b3);
        default:
          if ("object" === typeof a4 && null !== a4)
            switch (a4.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d4 = null;
                break a;
            }
          throw Error(p$6(130, null == a4 ? a4 : typeof a4, ""));
      }
  b3 = Bg(g2, c3, b3, e3);
  b3.elementType = a4;
  b3.type = d4;
  b3.lanes = f2;
  return b3;
}
function Ah(a4, b3, c3, d4) {
  a4 = Bg(7, a4, d4, b3);
  a4.lanes = c3;
  return a4;
}
function qj(a4, b3, c3, d4) {
  a4 = Bg(22, a4, d4, b3);
  a4.elementType = Ia;
  a4.lanes = c3;
  a4.stateNode = { isHidden: false };
  return a4;
}
function xh(a4, b3, c3) {
  a4 = Bg(6, a4, null, b3);
  a4.lanes = c3;
  return a4;
}
function zh(a4, b3, c3) {
  b3 = Bg(4, null !== a4.children ? a4.children : [], a4.key, b3);
  b3.lanes = c3;
  b3.stateNode = { containerInfo: a4.containerInfo, pendingChildren: null, implementation: a4.implementation };
  return b3;
}
function bl(a4, b3, c3, d4, e3) {
  this.tag = b3;
  this.containerInfo = a4;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d4;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  a4 = new bl(a4, b3, c3, h4, k3);
  1 === b3 ? (b3 = 1, true === f2 && (b3 |= 8)) : b3 = 0;
  f2 = Bg(3, null, null, b3);
  a4.current = f2;
  f2.stateNode = a4;
  f2.memoizedState = { element: d4, isDehydrated: c3, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a4;
}
function dl(a4, b3, c3) {
  var d4 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d4 ? null : "" + d4, children: a4, containerInfo: b3, implementation: c3 };
}
function el(a4) {
  if (!a4)
    return Vf;
  a4 = a4._reactInternals;
  a: {
    if (Vb(a4) !== a4 || 1 !== a4.tag)
      throw Error(p$6(170));
    var b3 = a4;
    do {
      switch (b3.tag) {
        case 3:
          b3 = b3.stateNode.context;
          break a;
        case 1:
          if (Zf(b3.type)) {
            b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b3 = b3.return;
    } while (null !== b3);
    throw Error(p$6(171));
  }
  if (1 === a4.tag) {
    var c3 = a4.type;
    if (Zf(c3))
      return bg(a4, c3, b3);
  }
  return b3;
}
function fl(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  a4 = cl(c3, d4, true, a4, e3, f2, g2, h4, k3);
  a4.context = el(null);
  c3 = a4.current;
  d4 = L();
  e3 = lh(c3);
  f2 = ch(d4, e3);
  f2.callback = void 0 !== b3 && null !== b3 ? b3 : null;
  dh(c3, f2, e3);
  a4.current.lanes = e3;
  Ac(a4, e3, d4);
  Ek(a4, d4);
  return a4;
}
function gl(a4, b3, c3, d4) {
  var e3 = b3.current, f2 = L(), g2 = lh(e3);
  c3 = el(c3);
  null === b3.context ? b3.context = c3 : b3.pendingContext = c3;
  b3 = ch(f2, g2);
  b3.payload = { element: a4 };
  d4 = void 0 === d4 ? null : d4;
  null !== d4 && (b3.callback = d4);
  a4 = dh(e3, b3, g2);
  null !== a4 && (mh(a4, e3, g2, f2), eh(a4, e3, g2));
  return g2;
}
function hl(a4) {
  a4 = a4.current;
  if (!a4.child)
    return null;
  switch (a4.child.tag) {
    case 5:
      return a4.child.stateNode;
    default:
      return a4.child.stateNode;
  }
}
function il(a4, b3) {
  a4 = a4.memoizedState;
  if (null !== a4 && null !== a4.dehydrated) {
    var c3 = a4.retryLane;
    a4.retryLane = 0 !== c3 && c3 < b3 ? c3 : b3;
  }
}
function jl(a4, b3) {
  il(a4, b3);
  (a4 = a4.alternate) && il(a4, b3);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a4) {
  console.error(a4);
};
function ml(a4) {
  this._internalRoot = a4;
}
nl.prototype.render = ml.prototype.render = function(a4) {
  var b3 = this._internalRoot;
  if (null === b3)
    throw Error(p$6(409));
  gl(a4, b3, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a4 = this._internalRoot;
  if (null !== a4) {
    this._internalRoot = null;
    var b3 = a4.containerInfo;
    Sk(function() {
      gl(null, a4, null, null);
    });
    b3[uf] = null;
  }
};
function nl(a4) {
  this._internalRoot = a4;
}
nl.prototype.unstable_scheduleHydration = function(a4) {
  if (a4) {
    var b3 = Hc();
    a4 = { blockedOn: null, target: a4, priority: b3 };
    for (var c3 = 0; c3 < Qc.length && 0 !== b3 && b3 < Qc[c3].priority; c3++)
      ;
    Qc.splice(c3, 0, a4);
    0 === c3 && Vc(a4);
  }
};
function ol(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType);
}
function pl(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType && (8 !== a4.nodeType || " react-mount-point-unstable " !== a4.nodeValue));
}
function ql() {
}
function rl(a4, b3, c3, d4, e3) {
  if (e3) {
    if ("function" === typeof d4) {
      var f2 = d4;
      d4 = function() {
        var a5 = hl(g2);
        f2.call(a5);
      };
    }
    var g2 = fl(b3, d4, a4, 0, null, false, false, "", ql);
    a4._reactRootContainer = g2;
    a4[uf] = g2.current;
    sf(8 === a4.nodeType ? a4.parentNode : a4);
    Sk();
    return g2;
  }
  for (; e3 = a4.lastChild; )
    a4.removeChild(e3);
  if ("function" === typeof d4) {
    var h4 = d4;
    d4 = function() {
      var a5 = hl(k3);
      h4.call(a5);
    };
  }
  var k3 = cl(a4, 0, false, null, null, false, false, "", ql);
  a4._reactRootContainer = k3;
  a4[uf] = k3.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  Sk(function() {
    gl(b3, k3, c3, d4);
  });
  return k3;
}
function sl(a4, b3, c3, d4, e3) {
  var f2 = c3._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h4 = e3;
      e3 = function() {
        var a5 = hl(g2);
        h4.call(a5);
      };
    }
    gl(b3, g2, a4, e3);
  } else
    g2 = rl(c3, b3, a4, e3, d4);
  return hl(g2);
}
Ec = function(a4) {
  switch (a4.tag) {
    case 3:
      var b3 = a4.stateNode;
      if (b3.current.memoizedState.isDehydrated) {
        var c3 = tc(b3.pendingLanes);
        0 !== c3 && (Cc(b3, c3 | 1), Ek(b3, B$1()), 0 === (K & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b4 = Zg(a4, 1);
        if (null !== b4) {
          var c4 = L();
          mh(b4, a4, 1, c4);
        }
      }), jl(a4, 1);
  }
};
Fc = function(a4) {
  if (13 === a4.tag) {
    var b3 = Zg(a4, 134217728);
    if (null !== b3) {
      var c3 = L();
      mh(b3, a4, 134217728, c3);
    }
    jl(a4, 134217728);
  }
};
Gc = function(a4) {
  if (13 === a4.tag) {
    var b3 = lh(a4), c3 = Zg(a4, b3);
    if (null !== c3) {
      var d4 = L();
      mh(c3, a4, b3, d4);
    }
    jl(a4, b3);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a4, b3) {
  var c3 = C$1;
  try {
    return C$1 = a4, b3();
  } finally {
    C$1 = c3;
  }
};
yb = function(a4, b3, c3) {
  switch (b3) {
    case "input":
      bb(a4, c3);
      b3 = c3.name;
      if ("radio" === c3.type && null != b3) {
        for (c3 = a4; c3.parentNode; )
          c3 = c3.parentNode;
        c3 = c3.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
        for (b3 = 0; b3 < c3.length; b3++) {
          var d4 = c3[b3];
          if (d4 !== a4 && d4.form === a4.form) {
            var e3 = Db(d4);
            if (!e3)
              throw Error(p$6(90));
            Wa(d4);
            bb(d4, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a4, c3);
      break;
    case "select":
      b3 = c3.value, null != b3 && fb(a4, !!c3.multiple, b3, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a4) {
  a4 = Zb(a4);
  return null === a4 ? null : a4.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a4) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a4, b3) {
  var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b3))
    throw Error(p$6(200));
  return dl(a4, b3, null, c3);
};
reactDom_production_min.createRoot = function(a4, b3) {
  if (!ol(a4))
    throw Error(p$6(299));
  var c3 = false, d4 = "", e3 = ll;
  null !== b3 && void 0 !== b3 && (true === b3.unstable_strictMode && (c3 = true), void 0 !== b3.identifierPrefix && (d4 = b3.identifierPrefix), void 0 !== b3.onRecoverableError && (e3 = b3.onRecoverableError));
  b3 = cl(a4, 1, false, null, null, c3, false, d4, e3);
  a4[uf] = b3.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  return new ml(b3);
};
reactDom_production_min.findDOMNode = function(a4) {
  if (null == a4)
    return null;
  if (1 === a4.nodeType)
    return a4;
  var b3 = a4._reactInternals;
  if (void 0 === b3) {
    if ("function" === typeof a4.render)
      throw Error(p$6(188));
    a4 = Object.keys(a4).join(",");
    throw Error(p$6(268, a4));
  }
  a4 = Zb(b3);
  a4 = null === a4 ? null : a4.stateNode;
  return a4;
};
reactDom_production_min.flushSync = function(a4) {
  return Sk(a4);
};
reactDom_production_min.hydrate = function(a4, b3, c3) {
  if (!pl(b3))
    throw Error(p$6(200));
  return sl(null, a4, b3, true, c3);
};
reactDom_production_min.hydrateRoot = function(a4, b3, c3) {
  if (!ol(a4))
    throw Error(p$6(405));
  var d4 = null != c3 && c3.hydratedSources || null, e3 = false, f2 = "", g2 = ll;
  null !== c3 && void 0 !== c3 && (true === c3.unstable_strictMode && (e3 = true), void 0 !== c3.identifierPrefix && (f2 = c3.identifierPrefix), void 0 !== c3.onRecoverableError && (g2 = c3.onRecoverableError));
  b3 = fl(b3, null, a4, 1, null != c3 ? c3 : null, e3, false, f2, g2);
  a4[uf] = b3.current;
  sf(a4);
  if (d4)
    for (a4 = 0; a4 < d4.length; a4++)
      c3 = d4[a4], e3 = c3._getVersion, e3 = e3(c3._source), null == b3.mutableSourceEagerHydrationData ? b3.mutableSourceEagerHydrationData = [c3, e3] : b3.mutableSourceEagerHydrationData.push(
        c3,
        e3
      );
  return new nl(b3);
};
reactDom_production_min.render = function(a4, b3, c3) {
  if (!pl(b3))
    throw Error(p$6(200));
  return sl(null, a4, b3, false, c3);
};
reactDom_production_min.unmountComponentAtNode = function(a4) {
  if (!pl(a4))
    throw Error(p$6(40));
  return a4._reactRootContainer ? (Sk(function() {
    sl(null, null, a4, false, function() {
      a4._reactRootContainer = null;
      a4[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a4, b3, c3, d4) {
  if (!pl(c3))
    throw Error(p$6(200));
  if (null == a4 || void 0 === a4._reactInternals)
    throw Error(p$6(38));
  return sl(a4, b3, c3, false, d4);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}
const index = "";
/**
 * @remix-run/router v1.8.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e3) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$3({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, index2];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant$1(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant$1(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = _extends$3({}, route, mapRouteProperties2(route), {
        id: id2
      });
      manifest[id2] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends$3({}, route, mapRouteProperties2(route), {
        id: id2,
        children: void 0
      });
      manifest[id2] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i3 = 0; matches == null && i3 < branches.length; ++i3) {
    matches = matchRouteBranch(
      branches[i3],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a4, b3) => a4.score !== b3.score ? b3.score - a4.score : compareIndexes(a4.routesMeta.map((meta) => meta.childrenIndex), b3.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s5) => s5 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s5) => !isSplat(s5)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a4, b3) {
  let siblings = a4.length === b3.length && a4.slice(0, -1).every((n2, i3) => n2 === b3[i3]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a4[a4.length - 1] - b3[b3.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i3 = 0; i3 < routesMeta.length; ++i3) {
    let meta = routesMeta[i3];
    let end = i3 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo2, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo2[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$3({}, toArg);
    invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser2;
  invariant$1(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init.mapRouteProperties) {
    mapRouteProperties2 = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties2 = defaultMapRouteProperties;
  }
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let future = _extends$3({
    v7_normalizeFormMethod: false,
    v7_prependBasename: false
  }, init.future);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions = null;
  let getScrollRestorationKey = null;
  let getScrollPosition = null;
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized = (
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    !initialMatches.some((m4) => m4.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
    (!initialMatches.some((m4) => m4.route.loader) || init.hydrationData != null)
  );
  let router2;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = [];
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeDeferreds = /* @__PURE__ */ new Map();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let ignoreNextHistoryUpdate = false;
  function initialize() {
    unlistenHistory = init.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning$1(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            });
            init.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }
    return router2;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_2, key) => deleteFetcher(key));
    state.blockers.forEach((_2, key) => deleteBlocker(key));
  }
  function subscribe2(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState) {
    state = _extends$3({}, state, newState);
    subscribers.forEach((subscriber) => subscriber(state));
  }
  function completeNavigation(location, newState) {
    var _location$state, _location$state2;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_2, k3) => blockers.set(k3, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation)
      ;
    else if (pendingAction === Action.Pop)
      ;
    else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    }
    updateState(_extends$3({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }));
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends$3({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false)
      ;
    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  }
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    }
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      request = new Request(request.url, {
        signal: request.signal
      });
    }
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, _extends$3({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  }
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    });
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties2, basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  }
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);
    cancelActiveDeferreds((routeId) => !(matches && matches.some((m4) => m4.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m4) => m4.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location, _extends$3({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}, updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      return {
        shortCircuited: true
      };
    }
    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach((rf2) => {
        let fetcher = state.fetchers.get(rf2.key);
        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
        state.fetchers.set(rf2.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends$3({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    revalidatingFetchers.forEach((rf2) => {
      if (fetchControllers.has(rf2.key)) {
        abortFetcher(rf2.key);
      }
      if (rf2.controller) {
        fetchControllers.set(rf2.key, rf2.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(state, redirect.result, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends$3({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function fetch2(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key))
      abortFetcher(key);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }));
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error);
      return;
    }
    let match2 = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match2, matches, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match2, matches, submission);
  }
  async function handleFetcherAction(key, routeId, path, match2, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match2.route.action && !match2.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId
      });
      setFetcherError(key, routeId, error);
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    let fetcher = getSubmittingFetcher(submission, existingFetcher);
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResult = await callLoaderOrAction("action", fetchRequest, match2, requestMatches, manifest, mapRouteProperties2, basename);
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      if (pendingNavigationLoadId > originatingLoadId) {
        let doneFetcher = getDoneFetcher(void 0);
        state.fetchers.set(key, doneFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return;
      } else {
        fetchRedirectIds.add(key);
        let loadingFetcher = getLoadingFetcher(submission);
        state.fetchers.set(key, loadingFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return startRedirectNavigation(state, actionResult, {
          submission,
          isFetchActionRedirect: true
        });
      }
    }
    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant$1(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      submission,
      nextLocation,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      {
        [match2.route.id]: actionResult.data
      },
      void 0
      // No need to send through errors since we short circuit above
    );
    revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
      let staleKey = rf2.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf2.controller) {
        fetchControllers.set(staleKey, rf2.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r3) => fetchControllers.delete(r3.key));
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(state, redirect.result);
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    let didAbortFetchLoads = abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant$1(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState(_extends$3({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match2, matches, submission) {
    let existingFetcher = state.fetchers.get(key);
    let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0);
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let result = await callLoaderOrAction("loader", fetchRequest, match2, matches, manifest, mapRouteProperties2, basename);
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        let doneFetcher2 = getDoneFetcher(void 0);
        state.fetchers.set(key, doneFetcher2);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(state, result);
        return;
      }
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key);
      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant$1(!isDeferredResult(result), "Unhandled fetcher deferred data");
    let doneFetcher = getDoneFetcher(result.data);
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  async function startRedirectNavigation(state2, redirect, _temp) {
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(
      state2.location,
      redirect.location,
      // TODO: This can be removed once we get rid of useTransition in Remix v2
      _extends$3({
        _isRedirect: true
      }, isFetchActionRedirect ? {
        _isFetchActionRedirect: true
      } : {})
    );
    invariant$1(redirectLocation, "Expected a location on the redirect navigation");
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect.reloadDocument) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {
        const url = init.history.createURL(redirect.location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(redirect.location);
        } else {
          routerWindow.location.assign(redirect.location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;
    let activeSubmission = submission || getSubmissionFromNavigation(state2.navigation);
    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends$3({}, activeSubmission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else if (isFetchActionRedirect) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: getLoadingNavigation(redirectLocation),
        fetcherSubmission: activeSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, activeSubmission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let results = await Promise.all([...matchesToLoad.map((match2) => callLoaderOrAction("loader", request, match2, matches, manifest, mapRouteProperties2, basename)), ...fetchersToLoad.map((f2) => {
      if (f2.matches && f2.match && f2.controller) {
        return callLoaderOrAction("loader", createClientSideRequest(init.history, f2.path, f2.controller.signal), f2.match, f2.matches, manifest, mapRouteProperties2, basename);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f2.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, fetchersToLoad.map((f2) => f2.controller ? f2.controller.signal : null), true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_2, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant$1(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant$1(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant$1(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant$1(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning$1(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y4 = getSavedScrollPosition(state.location, state.matches);
      if (y4 != null) {
        updateState({
          restoreScrollPosition: y4
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map((m4) => createUseMatchesMatch(m4, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y4 = savedScrollPositions[key];
      if (typeof y4 === "number") {
        return y4;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  router2 = {
    get basename() {
      return basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe: subscribe2,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    encodeLocation: (to) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router2;
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId != null && relative !== "path") {
    contextualMatches = [];
    for (let match2 of matches) {
      contextualMatches.push(match2);
      if (match2.route.id === fromRouteId) {
        activeRouteMatch = match2;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(to ? to : ".", getPathContributingMatches(contextualMatches).map((m4) => m4.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name, value] = _ref3;
          return "" + acc + name + "=" + value + "\n";
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e3) {
        return getInvalidBodyError();
      }
    }
  }
  invariant$1(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e3) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index2 = matches.findIndex((m4) => m4.route.id === boundaryId);
    if (index2 >= 0) {
      boundaryMatches = matches.slice(0, index2);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match2, index2) => {
    if (match2.route.lazy) {
      return true;
    }
    if (match2.route.loader == null) {
      return false;
    }
    if (isNewLoader(state.loaderData, state.matches[index2], match2) || cancelledDeferredRoutes.some((id2) => id2 === match2.route.id)) {
      return true;
    }
    let currentRouteMatch = state.matches[index2];
    let nextRouteMatch = match2;
    return shouldRevalidateLoader(match2, _extends$3({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || // Clicked the same link, resubmitted a GET form
        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f2, key) => {
    if (!matches.some((m4) => m4.route.id === f2.routeId)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$3({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate: isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match2) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match2.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match2.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match2) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant$1(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning$1(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, _extends$3({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
async function callLoaderOrAction(type, request, match2, matches, manifest, mapRouteProperties2, basename, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_2, r3) => reject = r3);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match2.params,
      context: opts.requestContext
    }), abortPromise]);
  };
  try {
    let handler = match2.route[type];
    if (match2.route.lazy) {
      if (handler) {
        let values = await Promise.all([runHandler(handler), loadLazyRouteModule(match2.route, mapRouteProperties2, manifest)]);
        result = values[0];
      } else {
        await loadLazyRouteModule(match2.route, mapRouteProperties2, manifest);
        handler = match2.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match2.route.id
          });
        } else {
          return {
            type: ResultType.data,
            data: void 0
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant$1(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match2.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e3) {
    resultType = ResultType.error;
    result = e3;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status;
    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant$1(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      if (!ABSOLUTE_URL_REGEX.test(location)) {
        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match2) + 1), basename, true, location);
      } else if (!opts.isStaticRequest) {
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      }
      if (opts.isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null,
        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
      };
    }
    if (opts.isRouteRequest) {
      let queryRouteResponse = {
        type: resultType === ResultType.error ? ResultType.error : ResultType.data,
        response: result
      };
      throw queryRouteResponse;
    }
    let data;
    let contentType = result.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  results.forEach((result, index2) => {
    let id2 = matchesToLoad[index2].route.id;
    invariant$1(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, id2);
      let error = result.error;
      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = void 0;
      }
      errors = errors || {};
      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      }
      loaderData[id2] = void 0;
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id2, result.deferredData);
        loaderData[id2] = result.deferredData.data;
      } else {
        loaderData[id2] = result.data;
      }
      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    }
  });
  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key,
      match: match2,
      controller
    } = revalidatingFetchers[index2];
    invariant$1(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
    let result = fetcherResults[index2];
    if (controller && controller.signal.aborted) {
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match2 == null ? void 0 : match2.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends$3({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant$1(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      invariant$1(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends$3({}, newLoaderData);
  for (let match2 of matches) {
    let id2 = match2.route.id;
    if (newLoaderData.hasOwnProperty(id2)) {
      if (newLoaderData[id2] !== void 0) {
        mergedLoaderData[id2] = newLoaderData[id2];
      }
    } else if (loaderData[id2] !== void 0 && match2.route.loader) {
      mergedLoaderData[id2] = loaderData[id2];
    }
    if (errors && errors.hasOwnProperty(id2)) {
      break;
    }
  }
  return mergedLoaderData;
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m4) => m4.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m4) => m4.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.find((r3) => r3.index || !r3.path || r3.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = 'No route matches URL "' + pathname + '"';
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
}
function findRedirect(results) {
  for (let i3 = results.length - 1; i3 >= 0; i3--) {
    let result = results[i3];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i3
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends$3({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a4, b3) {
  if (a4.pathname !== b3.pathname || a4.search !== b3.search) {
    return false;
  }
  if (a4.hash === "") {
    return b3.hash !== "";
  } else if (a4.hash === b3.hash) {
    return true;
  } else if (b3.hash !== "") {
    return true;
  }
  return false;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index2 = 0; index2 < results.length; index2++) {
    let result = results[index2];
    let match2 = matchesToLoad[index2];
    if (!match2) {
      continue;
    }
    let currentMatch = currentMatches.find((m4) => m4.route.id === match2.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match2) && (currentLoaderData && currentLoaderData[match2.route.id]) !== void 0;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      let signal = signals[index2];
      invariant$1(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then((result2) => {
        if (result2) {
          results[index2] = result2 || results[index2];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e3) {
      return {
        type: ResultType.error,
        error: e3
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
}
function createUseMatchesMatch(match2, loaderData) {
  let {
    route,
    pathname,
    params
  } = match2;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data,
      " _hasFetcherDoneAnything ": true
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data,
      " _hasFetcherDoneAnything ": true
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0,
    " _hasFetcherDoneAnything ": true
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data,
    " _hasFetcherDoneAnything ": true
  };
  return fetcher;
}
/**
 * React Router v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$2(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m4) => m4.route.id && (errors == null ? void 0 : errors[m4.route.id]));
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match2.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$1(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router: router2
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router2.navigate(to);
    } else {
      router2.navigate(to, _extends$2({
        fromRouteId: id2
      }, options));
    }
  }, [router2, id2]);
  return navigate;
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = e$6[START_TRANSITION];
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router: router2,
    future
  } = _ref;
  let [state, setStateImpl] = reactExports.useState(router2.state);
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
  let navigator2 = reactExports.useMemo(() => {
    return {
      createHref: router2.createHref,
      encodeLocation: router2.encodeLocation,
      go: (n2) => router2.navigate(n2),
      push: (to, state2, opts) => router2.navigate(to, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state2, opts) => router2.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router2]);
  let basename = router2.basename || "/";
  let dataRouterContext = reactExports.useMemo(() => ({
    router: router2,
    navigator: navigator2,
    static: false,
    basename
  }), [router2, navigator2, basename]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2
  }, state.initialized ? /* @__PURE__ */ reactExports.createElement(DataRoutes, {
    routes: router2.routes,
    state
  }) : fallbackElement))), null);
}
function DataRoutes(_ref2) {
  let {
    routes,
    state
  } = _ref2;
  return useRoutesImpl(routes, void 0, state);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
new Promise(() => {
});
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    Object.assign(updates, {
      element: /* @__PURE__ */ reactExports.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.ErrorBoundary) {
    Object.assign(updates, {
      errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
/**
 * React Router DOM v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends$1({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends$1({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors)
    return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e3) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
const PresenceContext = reactExports.createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect$1 = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component2, visualState, props, createVisualElement) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  reactExports.useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  const canHandoff = reactExports.useRef(Boolean(window.HandoffAppearAnimations));
  useIsomorphicLayoutEffect$1(() => {
    if (!visualElement)
      return;
    visualElement.render();
    if (canHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    visualElement.updateFeatures();
    if (!canHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    window.HandoffAppearAnimations = void 0;
    canHandoff.current = false;
  });
  return visualElement;
}
function isRefObject(ref2) {
  return typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
const LayoutGroupContext = reactExports.createContext({});
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component: Component2 }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      const isStrict = reactExports.useContext(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? reactExports.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component2;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component2, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component2, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component2)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i3 = 0; i3 < numTransforms; i3++) {
    const key = transformPropOrder[i3];
    if (transform[key] !== void 0) {
      const transformName = translateAlias[key] || key;
      transformString += `${transformName}(${transform[key]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = checkStringStartsWith("--");
const isCSSVariableToken = checkStringStartsWith("var(--");
const cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v2) {
  return typeof v2 === "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString$1(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars, transform, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin[key] = valueAsType;
    } else {
      style[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component2), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component2, props, ref2, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
    const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref: ref2
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function useConstant(init) {
  const ref2 = reactExports.useRef(null);
  if (ref2.current === null) {
    ref2.current = init();
  }
  return ref2.current;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
const noop$2 = (any) => any;
function createRenderStep(runNextFrame) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i3 = 0; i3 < numToRun; i3++) {
          const callback = toRun[i3];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const stepsOrder = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const steps2 = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {});
  const processStep = (stepId) => steps2[stepId].process(state);
  const processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    stepsOrder.forEach(processStep);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps2[key];
    acc[key] = (process, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process) => stepsOrder.forEach((key) => steps2[key].cancel(process));
  return { schedule, cancel, state, steps: steps2 };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$2, true);
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e3) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
  const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component: Component2
  };
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const combineFunctions = (a4, b3) => (v2) => b3(a4(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
function addHoverEvent(node, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave");
  const callbackName = "onHover" + (isActive ? "Start" : "End");
  const handleEvent = (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    const props = node.getProps();
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", isActive);
    }
    if (props[callbackName]) {
      frame.update(() => props[callbackName](event, info));
    }
  };
  return addPointerEvent(node.current, eventName, handleEvent, {
    passive: !node.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e3) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop$2;
    this.removeEndListeners = noop$2;
    this.removeAccessibleListeners = noop$2;
    this.startPointerPress = (startEvent, startInfo) => {
      this.removeEndListeners();
      if (this.isPressing)
        return;
      const props = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel } = this.node.getProps();
        frame.update(() => {
          !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      };
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i3 = 0; i3 < prevLength; i3++) {
    if (prev[i3] !== next[i3])
      return false;
  }
  return true;
}
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key) => current[key] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
let warning = noop$2;
let invariant = noop$2;
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
const instantAnimationState = {
  current: false
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a4, b3, c3, d4]) => `cubic-bezier(${a4}, ${b3}, ${c3}, ${d4})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index2];
}
const calcBezier = (t4, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t4 + (3 * a22 - 6 * a1)) * t4 + 3 * a1) * t4;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i3 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i3 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$2;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t4) => t4 === 0 || t4 === 1 ? t4 : calcBezier(getTForX(t4), mY1, mY2);
}
const easeIn = cubicBezier(0.42, 0, 1, 1);
const easeOut = cubicBezier(0, 0, 0.58, 1);
const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$2,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y22] = definition;
    return cubicBezier(x1, y1, x2, y22);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
const isColorString = (type, testProp) => (v2) => {
  return Boolean(isString$1(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString$1(v2))
    return v2;
  const [a4, b3, c3, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a4),
    [bName]: parseFloat(b3),
    [cName]: parseFloat(c3),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r3 = "";
  let g2 = "";
  let b3 = "";
  let a4 = "";
  if (v2.length > 5) {
    r3 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b3 = v2.substring(5, 7);
    a4 = v2.substring(7, 9);
  } else {
    r3 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b3 = v2.substring(3, 4);
    a4 = v2.substring(4, 5);
    r3 += r3;
    g2 += g2;
    b3 += b3;
    a4 += a4;
  }
  return {
    red: parseInt(r3, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b3, 16),
    alpha: a4 ? parseInt(a4, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$1(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
function hueToRgb(p2, q3, t4) {
  if (t4 < 0)
    t4 += 1;
  if (t4 > 1)
    t4 -= 1;
  if (t4 < 1 / 6)
    return p2 + (q3 - p2) * 6 * t4;
  if (t4 < 1 / 2)
    return q3;
  if (t4 < 2 / 3)
    return p2 + (q3 - p2) * (2 / 3 - t4) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q3 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q3;
    red = hueToRgb(p2, q3, hue + 1 / 3);
    green = hueToRgb(p2, q3, hue);
    blue = hueToRgb(p2, q3, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from, to, v2) => {
  const fromExpo = from * from;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
function test(v2) {
  var _a, _b;
  return isNaN(v2) && isString$1(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const cssVarTokeniser = {
  regex: cssVariableRegex,
  countKey: "Vars",
  token: "${v}",
  parse: noop$2
};
const colorTokeniser = {
  regex: colorRegex,
  countKey: "Colors",
  token: "${c}",
  parse: color.parse
};
const numberTokeniser = {
  regex: floatRegex,
  countKey: "Numbers",
  token: "${n}",
  parse: number.parse
};
function tokenise(info, { regex: regex2, countKey, token, parse }) {
  const matches = info.tokenised.match(regex2);
  if (!matches)
    return;
  info["num" + countKey] = matches.length;
  info.tokenised = info.tokenised.replace(regex2, token);
  info.values.push(...matches.map(parse));
}
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const info = {
    value: originalValue,
    tokenised: originalValue,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  if (info.value.includes("var(--"))
    tokenise(info, cssVarTokeniser);
  tokenise(info, colorTokeniser);
  tokenise(info, numberTokeniser);
  return info;
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { values, numColors, numVars, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i3 = 0; i3 < numValues; i3++) {
      if (i3 < numVars) {
        output = output.replace(cssVarTokeniser.token, v2[i3]);
      } else if (i3 < numVars + numColors) {
        output = output.replace(colorTokeniser.token, color.transform(v2[i3]));
      } else {
        output = output.replace(numberTokeniser.token, sanitize(v2[i3]));
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const mixImmediate = (origin, target) => (p2) => `${p2 > 0 ? target : origin}`;
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i3) => getMixer(fromThis, to[i3]));
  return (v2) => {
    for (let i3 = 0; i3 < numValues; i3++) {
      output[i3] = blendValue[i3](v2);
    }
    return output;
  };
};
const mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const mixNumber = (from, to) => (p2) => mix(from, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    return color.test(v2) ? mixColor : mixComplex;
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i3 = 0; i3 < numMixers; i3++) {
    let mixer = mixerFactory(output[i3], output[i3 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i3] || noop$2 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    let i3 = 0;
    if (numMixers > 1) {
      for (; i3 < input.length - 2; i3++) {
        if (v2 < input[i3 + 1])
          break;
      }
    }
    const progressInRange = progress(input[i3], input[i3 + 1], v2);
    return mixers[i3](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i3 = 1; i3 <= remaining; i3++) {
    const offsetProgress = progress(0, remaining, i3);
    offset.push(mix(min, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o3) => o3 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t4) => {
      state.value = mapTimeToKeyframe(t4);
      state.done = t4 >= duration;
      return state;
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t4, current) {
  const prevT = Math.max(t4 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t4 - prevT);
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration$1 = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration$1));
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a4 = exponentialDecay - velocity;
      const b3 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c3 = Math.exp(-delta);
      return safeMin - a4 / b3 * c3;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d4 = delta * velocity + velocity;
      const e3 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d4 - e3) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a4 = Math.exp(-undampedFreq2 * duration);
      const b3 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a4 * b3;
    };
    derivative = (undampedFreq2) => {
      const a4 = Math.exp(-undampedFreq2 * duration);
      const b3 = (velocity - undampedFreq2) * (duration * duration);
      return a4 * b3;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i3 = 1; i3 < rootIterations; i3++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin = keyframes2[0];
  const target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t4) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t4) + initialDelta * Math.cos(angularFreq * t4));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t4) => target - Math.exp(-undampedAngularFreq * t4) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t4);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t4) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4);
      const freqForT = Math.min(dampedAngularFreq * t4, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t4) => {
      const current = resolveSpring(t4);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t4 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t4, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t4 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    }
  };
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  const nearestBoundary = (v2) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t4) => -amplitude * Math.exp(-t4 / timeConstant);
  const calcLatest = (t4) => target + calcDelta(t4);
  const applyFriction = (t4) => {
    const delta = calcDelta(t4);
    const latest = calcLatest(t4);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t4) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t4;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t4, state.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t4) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t4);
        checkCatchBoundary(t4);
      }
      if (timeReachedBoundary !== void 0 && t4 > timeReachedBoundary) {
        return spring$1.next(t4 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t4);
        return state;
      }
    }
  };
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
const types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
      clamp: false
    });
    keyframes$1 = [0, 100];
  }
  const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
  let mirroredGenerator;
  if (repeatType === "mirror") {
    mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -(options.velocity || 0)
    });
  }
  let playState = "idle";
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator);
  }
  const { calculatedDuration } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp) => {
    if (startTime === null)
      return;
    if (speed > 0)
      startTime = Math.min(startTime, timestamp);
    if (speed < 0)
      startTime = Math.min(timestamp - totalDuration / speed, startTime);
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = Math.round(timestamp - startTime) * speed;
    }
    const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0);
    if (playState === "finished" && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = currentTime / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const iterationIsOdd = Boolean(currentIteration % 2);
      if (iterationIsOdd) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      let p2 = clamp(0, 1, iterationProgress);
      if (currentTime > totalDuration) {
        p2 = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
      }
      elapsed = p2 * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes$1[0] } : frameGenerator.next(elapsed);
    if (mapNumbersToKeyframes) {
      state.value = mapNumbersToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
    }
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = "idle";
    stopAnimationDriver();
    resolveFinishedPromise();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = "finished";
    onComplete && onComplete();
    stopAnimationDriver();
    resolveFinishedPromise();
  };
  const play2 = () => {
    if (hasStopped)
      return;
    if (!animationDriver)
      animationDriver = driver(tick);
    const now = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now - holdTime;
    } else if (!startTime || playState === "finished") {
      startTime = now;
    }
    if (playState === "finished") {
      updateFinishedPromise();
    }
    cancelTime = startTime;
    holdTime = null;
    playState = "running";
    animationDriver.start();
  };
  if (autoplay) {
    play2();
  }
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      if (newSpeed === speed || !animationDriver)
        return;
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime);
    },
    get state() {
      return playState;
    },
    play: play2,
    pause: () => {
      playState = "paused";
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === "idle")
        return;
      playState = "idle";
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null)
        tick(cancelTime);
      cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => {
      startTime = 0;
      return tick(elapsed);
    }
  };
  return controls;
}
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]);
const sampleDelta = 10;
const maxDuration = 2e4;
const requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
  if (!canAccelerateAnimation)
    return false;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times } = options;
  if (requiresPregeneratedKeyframes(valueName, options)) {
    const sampleAnimation = animateValue({
      ...options,
      repeat: 0,
      delay: 0
    });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t4 = 0;
    while (!state.done && t4 < maxDuration) {
      state = sampleAnimation.sample(t4);
      pregeneratedKeyframes.push(state.value);
      t4 += sampleDelta;
    }
    times = void 0;
    keyframes2 = pregeneratedKeyframes;
    duration = t4 - sampleDelta;
    ease2 = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times
  });
  const cancelAnimation = () => animation.cancel();
  const safeCancel = () => {
    frame.update(cancelAnimation);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    onComplete && onComplete();
    safeCancel();
  };
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    attachTimeline(timeline) {
      animation.timeline = timeline;
      animation.onfinish = null;
      return noop$2;
    },
    get time() {
      return millisecondsToSeconds(animation.currentTime || 0);
    },
    set time(newTime) {
      animation.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation.playbackRate;
    },
    set speed(newSpeed) {
      animation.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      if (hasStopped)
        return;
      animation.play();
      cancelFrame(cancelAnimation);
    },
    pause: () => animation.pause(),
    stop: () => {
      hasStopped = true;
      if (animation.playState === "idle")
        return;
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options,
          autoplay: false
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation.finish(),
    cancel: safeCancel
  };
  return controls;
}
function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop$2,
      pause: noop$2,
      stop: noop$2,
      then: (resolve) => {
        resolve();
        return Promise.resolve();
      },
      cancel: noop$2,
      complete: noop$2
    };
  };
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
const isAnimatable = (key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  }
}
function getKeyframes(value, valueName, target, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let keyframes2;
  if (Array.isArray(target)) {
    keyframes2 = [...target];
  } else {
    keyframes2 = [null, target];
  }
  const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i3 = 0; i3 < keyframes2.length; i3++) {
    if (keyframes2[i3] === null) {
      keyframes2[i3] = i3 === 0 ? defaultOrigin : keyframes2[i3 - 1];
    }
    if (isNone(keyframes2[i3])) {
      noneKeyframeIndexes.push(i3);
    }
    if (typeof keyframes2[i3] === "string" && keyframes2[i3] !== "none" && keyframes2[i3] !== "0") {
      animatableTemplateValue = keyframes2[i3];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i3 = 0; i3 < noneKeyframeIndexes.length; i3++) {
      const index2 = noneKeyframeIndexes[i3];
      keyframes2[index2] = getAnimatableNone(valueName, animatableTemplateValue);
    }
  }
  return keyframes2;
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
const animateMotionValue = (valueName, value, target, transition = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition, valueName) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ease: "easeOut",
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options);
    }
    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animateValue(options);
  };
};
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a4, b3, c3) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a4, b3, c3);
    } else {
      for (let i3 = 0; i3 < numSubscriptions; i3++) {
        const handler = this.subscriptions[i3];
        handler && handler(a4, b3, c3);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "10.16.1";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        frame.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const testValueType = (v2) => (type) => type.test(v2);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a, _b;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i3 = 0; i3 < numNewValues; i3++) {
    const key = newValueKeys[i3];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement.addValue(key, motionValue(value, { owner: visualElement }));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition);
    if (transitionOrigin !== void 0) {
      origin[key] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key);
      if (value) {
        origin[key] = value.get();
      }
    }
  }
  return origin;
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
      }
    }
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
    const animation = value.animation;
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i3 = 0) => i3 * staggerChildren : (i3 = 0) => maxStaggerDuration - i3 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i3) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i3)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a4, b3) {
  return a4.sortNodePosition(b3);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i3 = 0; i3 < numAnimationTypes; i3++) {
      const type = reversePriorityOrder[i3];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i3;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i3 > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate)) {
      this.unmount = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete, custom } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const distance = (a4, b3) => Math.abs(a4 - b3);
function distance2D(a4, b3) {
  const xDelta = distance(a4.x, b3.x);
  const yDelta = distance(a4.y, b3.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a4, b3) {
  return { x: a4.x - b3.x, y: a4.y - b3.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i3 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i3 >= 0) {
    timestampedPoint = history[i3];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i3--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y4 }) {
  return { top: y4.min, right: x2.max, bottom: y4.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y4 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y4.translate, y4.scale, y4.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i3 = 0; i3 < treeLength; i3++) {
    node = treePath[i3];
    delta = node.projectionDelta;
    const instance = node.instance;
    if (instance && instance.style && instance.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.update(() => onDragStart(event, info), false, true);
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout: layout2 } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase();
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mix(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop$2;
    this.removeListeners = noop$2;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$2;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.update(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$2;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
function usePresence() {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y4 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y4}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      queueMicrotask(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i3 = 0; i3 < numBorders; i3++) {
    const borderLabel = `border${borders[i3]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$2);
function compress(min, max, easing) {
  return (p2) => {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(progress(min, max, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a4, b3) {
  return a4.x.min === b3.x.min && a4.x.max === b3.x.max && a4.y.min === b3.y.min && a4.y.max === b3.y.max;
}
function boxEqualsRounded(a4, b3) {
  return Math.round(a4.x.min) === Math.round(b3.x.min) && Math.round(a4.x.max) === Math.round(b3.x.max) && Math.round(a4.y.min) === Math.round(b3.y.min) && Math.round(a4.y.max) === Math.round(b3.y.max);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i3 = indexOfNode; i3 >= 0; i3--) {
      const member = this.members[i3];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const compareByDepth = (a4, b3) => a4.depth - b3.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i3 = 0; i3 < this.path.length; i3++) {
        this.path[i3].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i3 = 0; i3 < this.path.length; i3++) {
        const node = this.path[i3];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now = performance.now();
      frameData.delta = clamp(0, 1e3 / 60, now - frameData.timestamp);
      frameData.timestamp = now;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        queueMicrotask(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      frame.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i3 = 0; i3 < this.path.length; i3++) {
          const node = this.path[i3];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll } = this.root;
      if (scroll) {
        translateAxis(box.x, scroll.offset.x);
        translateAxis(box.y, scroll.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        const node = this.path[i3];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        const node = this.path[i3];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        const node = this.path[i3];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot2 = this.snapshot;
      const snapshotLatestValues = snapshot2 ? snapshot2.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot2 ? snapshot2.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i3 = 0; i3 < transformAxes.length; i3++) {
        const key = "rotate" + transformAxes[i3];
        if (latestValues[key]) {
          resetValues[key] = latestValues[key];
          visualElement.setStaticValue(key, 0);
        }
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a, _b;
      const styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y4 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y4.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i3 = 0; i3 < num; i3++) {
            styles[applyTo[i3]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot2 = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot2 && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot2.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot2.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot2.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot2.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot2.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot2.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot: snapshot2,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  projectionFrameData.totalNodes++;
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mix(delta.translate, 0, p2);
  output.scale = mix(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mix(from.min, to.min, p2);
  output.max = mix(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2);
  mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().includes(string);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot2, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot2), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token, fallback] = match2;
  return [token, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  } else if (isCSSVariableToken(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (!transitionEnd)
      transitionEnd = {};
    if (transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
const isPositionalKey = (key) => positionalKeys.has(key);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y4 }, { paddingTop = "0", paddingBottom = "0" }) => y4.max - y4.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y4 }, { top }) => parseFloat(top) + (y4.max - y4.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value && value.jump(origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (!visualElement.hasValue(key))
      return;
    let from = origin[key];
    let fromType = findDimensionValueType(from);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i3 = fromIndex; i3 < numKeyframes; i3++) {
        if (to[i3] === null)
          break;
        if (!toType) {
          toType = findDimensionValueType(to[i3]);
        } else {
          invariant(findDimensionValueType(to[i3]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement.getValue(key).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
const numVariantProps = variantProps.length;
class VisualElement {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      this.features[key].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    for (let i3 = 0; i3 < numFeatures; i3++) {
      const name = featureNames[i3];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled(renderedProps)) {
        if (!this.features[name] && FeatureConstructor) {
          this.features[name] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i3 = 0; i3 < propEventHandlers.length; i3++) {
      const key = propEventHandlers[i3];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listener = props["on" + key];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i3 = 0; i3 < numVariantProps; i3++) {
      const name = variantProps[i3];
      const prop = this.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    if (value !== this.values.get(key)) {
      this.removeValue(key);
      this.bindToMotionValue(key, value);
    }
    this.values.set(key, value);
    this.latestValues[key] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key) {
    var _a;
    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a4, b3) {
    return a4.compareDocumentPosition(b3) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => {
  return isSVGComponent(Component2) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy((Component2, config) => createDomMotionConfig(Component2, config, preloadedFeatures, createDomVisualElement));
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i3;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      fn.call(null, obj[i3], i3, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i3 = 0; i3 < len; i3++) {
      key = keys[i3];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey$1(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i3 = keys.length;
  let _key;
  while (i3-- > 0) {
    _key = keys[i3];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey$1(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    arguments[i3] && forEach(arguments[i3], assignValue);
  }
  return result;
}
const extend = (a4, b3, thisArg, { allOwnKeys } = {}) => {
  forEach(b3, (val, key) => {
    if (thisArg && isFunction(val)) {
      a4[key] = bind(val, thisArg);
    } else {
      a4[key] = val;
    }
  }, { allOwnKeys });
  return a4;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i3;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i3 = props.length;
    while (i3-- > 0) {
      prop = props[i3];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i3 = thing.length;
  if (!isNumber(i3))
    return null;
  const arr = new Array(i3);
  while (i3-- > 0) {
    arr[i3] = thing[i3];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m4, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i3) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i3] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i3 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i3] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey: findKey$1,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i3) {
    token = removeBrackets(token);
    return !dots && i3 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index2) {
          !(utils.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el2, key) {
      const result = !(utils.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h4) {
      if (h4 !== null) {
        fn(h4);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i3;
  const len = keys.length;
  let key;
  for (i3 = 0; i3 < len; i3++) {
    key = keys[i3];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: platform.isNode ? "http" : "xhr",
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i3;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i3 = line.indexOf(":");
    key = line.substring(0, i3).trim().toLowerCase();
    val = line.substring(i3 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i3 = keys.length;
    let deleted = false;
    while (i3--) {
      const key = keys[i3];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i3 = tail;
    let bytesCount = 0;
    while (i3 !== head) {
      bytesCount += bytes[i3++];
      i3 = i3 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e3
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e3) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i3 = 0; i3 < length; i3++) {
      nameOrAdapter = adapters2[i3];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a4, b3, caseless) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(a4, b3, caseless);
    } else if (!utils.isUndefined(a4)) {
      return getMergedValue(void 0, a4, caseless);
    }
  }
  function valueFromConfig2(a4, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a4, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils.isUndefined(a4)) {
      return getMergedValue(void 0, a4);
    }
  }
  function mergeDirectKeys(a4, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a4, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a4);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a4, b3) => mergeDeepProperties(headersToObject(a4), headersToObject(b3), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.5.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i3) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i3 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i3 = keys.length;
  while (i3-- > 0) {
    const opt = keys[i3];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i3 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i3 < len) {
        promise = promise.then(chain[i3++], chain[i3++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i3 = 0;
    while (i3 < len) {
      const onFulfilled = requestInterceptorChain[i3++];
      const onRejected = requestInterceptorChain[i3++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i3 = 0;
    len = responseInterceptorChain.length;
    while (i3 < len) {
      promise = promise.then(responseInterceptorChain[i3++], responseInterceptorChain[i3++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i3 = token._listeners.length;
      while (i3-- > 0) {
        token._listeners[i3](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
const e$5 = Symbol(), t$6 = Symbol(), r$5 = "a", n$3 = "w";
let o$6 = (e3, t4) => new Proxy(e3, t4);
const s$7 = Object.getPrototypeOf, c$3 = /* @__PURE__ */ new WeakMap(), l$5 = (e3) => e3 && (c$3.has(e3) ? c$3.get(e3) : s$7(e3) === Object.prototype || s$7(e3) === Array.prototype), f$2 = (e3) => "object" == typeof e3 && null !== e3, i$6 = (e3) => {
  if (Array.isArray(e3))
    return Array.from(e3);
  const t4 = Object.getOwnPropertyDescriptors(e3);
  return Object.values(t4).forEach((e4) => {
    e4.configurable = true;
  }), Object.create(s$7(e3), t4);
}, u$5 = (e3) => e3[t$6] || e3, a$1 = (s5, c3, f2, p2) => {
  if (!l$5(s5))
    return s5;
  let g2 = p2 && p2.get(s5);
  if (!g2) {
    const e3 = u$5(s5);
    g2 = ((e4) => Object.values(Object.getOwnPropertyDescriptors(e4)).some((e5) => !e5.configurable && !e5.writable))(e3) ? [e3, i$6(e3)] : [e3], null == p2 || p2.set(s5, g2);
  }
  const [y4, h4] = g2;
  let w3 = f2 && f2.get(y4);
  return w3 && w3[1].f === !!h4 || (w3 = ((o3, s6) => {
    const c4 = { f: s6 };
    let l2 = false;
    const f3 = (e3, t4) => {
      if (!l2) {
        let s7 = c4[r$5].get(o3);
        if (s7 || (s7 = {}, c4[r$5].set(o3, s7)), e3 === n$3)
          s7[n$3] = true;
        else {
          let r3 = s7[e3];
          r3 || (r3 = /* @__PURE__ */ new Set(), s7[e3] = r3), r3.add(t4);
        }
      }
    }, i3 = { get: (e3, n2) => n2 === t$6 ? o3 : (f3("k", n2), a$1(Reflect.get(e3, n2), c4[r$5], c4.c, c4.t)), has: (t4, n2) => n2 === e$5 ? (l2 = true, c4[r$5].delete(o3), true) : (f3("h", n2), Reflect.has(t4, n2)), getOwnPropertyDescriptor: (e3, t4) => (f3("o", t4), Reflect.getOwnPropertyDescriptor(e3, t4)), ownKeys: (e3) => (f3(n$3), Reflect.ownKeys(e3)) };
    return s6 && (i3.set = i3.deleteProperty = () => false), [i3, c4];
  })(y4, !!h4), w3[1].p = o$6(h4 || y4, w3[0]), f2 && f2.set(y4, w3)), w3[1][r$5] = c3, w3[1].c = f2, w3[1].t = p2, w3[1].p;
}, p$5 = (e3, t4, r3, o3) => {
  if (Object.is(e3, t4))
    return false;
  if (!f$2(e3) || !f$2(t4))
    return true;
  const s5 = r3.get(u$5(e3));
  if (!s5)
    return true;
  if (o3) {
    const r4 = o3.get(e3);
    if (r4 && r4.n === t4)
      return r4.g;
    o3.set(e3, { n: t4, g: false });
  }
  let c3 = null;
  try {
    for (const r4 of s5.h || [])
      if (c3 = Reflect.has(e3, r4) !== Reflect.has(t4, r4), c3)
        return c3;
    if (true === s5[n$3]) {
      if (c3 = ((e4, t5) => {
        const r4 = Reflect.ownKeys(e4), n2 = Reflect.ownKeys(t5);
        return r4.length !== n2.length || r4.some((e5, t6) => e5 !== n2[t6]);
      })(e3, t4), c3)
        return c3;
    } else
      for (const r4 of s5.o || [])
        if (c3 = !!Reflect.getOwnPropertyDescriptor(e3, r4) != !!Reflect.getOwnPropertyDescriptor(t4, r4), c3)
          return c3;
    for (const n2 of s5.k || [])
      if (c3 = p$5(e3[n2], t4[n2], r3, o3), c3)
        return c3;
    return null === c3 && (c3 = true), c3;
  } finally {
    o3 && o3.set(e3, { n: t4, g: c3 });
  }
}, y$4 = (e3) => l$5(e3) && e3[t$6] || null, h$4 = (e3, t4 = true) => {
  c$3.set(e3, t4);
}, w$2 = (e3, t4, r3) => {
  const o3 = [], s5 = /* @__PURE__ */ new WeakSet(), c3 = (e4, l2) => {
    if (s5.has(e4))
      return;
    f$2(e4) && s5.add(e4);
    const i3 = f$2(e4) && t4.get(u$5(e4));
    if (i3) {
      var a4, p2;
      if (null == (a4 = i3.h) || a4.forEach((e5) => {
        const t5 = `:has(${String(e5)})`;
        o3.push(l2 ? [...l2, t5] : [t5]);
      }), true === i3[n$3]) {
        const e5 = ":ownKeys";
        o3.push(l2 ? [...l2, e5] : [e5]);
      } else {
        var g2;
        null == (g2 = i3.o) || g2.forEach((e5) => {
          const t5 = `:hasOwn(${String(e5)})`;
          o3.push(l2 ? [...l2, t5] : [t5]);
        });
      }
      null == (p2 = i3.k) || p2.forEach((t5) => {
        r3 && !("value" in (Object.getOwnPropertyDescriptor(e4, t5) || {})) || c3(e4[t5], l2 ? [...l2, t5] : [t5]);
      });
    } else
      l2 && o3.push(l2);
  };
  return c3(e3), o3;
};
const isObject = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$4(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value = Reflect.get(target, key);
    const desc = {
      value,
      enumerable: true,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h$4(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y$4(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e3) => {
          value.status = "rejected";
          value.reason = e3;
          notifyUpdate(["reject", [prop], e3]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if ("value" in desc) {
      proxyObject[key] = initialObject[key];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$4 = reactExports;
function h$3(a4, b3) {
  return a4 === b3 && (0 !== a4 || 1 / a4 === 1 / b3) || a4 !== a4 && b3 !== b3;
}
var k$1 = "function" === typeof Object.is ? Object.is : h$3, l$4 = e$4.useState, m$1 = e$4.useEffect, n$2 = e$4.useLayoutEffect, p$4 = e$4.useDebugValue;
function q$1(a4, b3) {
  var d4 = b3(), f2 = l$4({ inst: { value: d4, getSnapshot: b3 } }), c3 = f2[0].inst, g2 = f2[1];
  n$2(function() {
    c3.value = d4;
    c3.getSnapshot = b3;
    r$4(c3) && g2({ inst: c3 });
  }, [a4, d4, b3]);
  m$1(function() {
    r$4(c3) && g2({ inst: c3 });
    return a4(function() {
      r$4(c3) && g2({ inst: c3 });
    });
  }, [a4]);
  p$4(d4);
  return d4;
}
function r$4(a4) {
  var b3 = a4.getSnapshot;
  a4 = a4.value;
  try {
    var d4 = b3();
    return !k$1(a4, d4);
  } catch (f2) {
    return true;
  }
}
function t$5(a4, b3) {
  return b3();
}
var u$4 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$5 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$4.useSyncExternalStore ? e$4.useSyncExternalStore : u$4;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(shimExports);
const { use } = React;
const { useSyncExternalStore } = useSyncExternalStoreExports;
const useAffectedDebugValue = (state, affected) => {
  const pathList = reactExports.useRef();
  reactExports.useEffect(() => {
    pathList.current = w$2(state, affected, true);
  });
  reactExports.useDebugValue(pathList.current);
};
const targetCache = /* @__PURE__ */ new WeakMap();
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = reactExports.useRef();
  const lastAffected = reactExports.useRef();
  let inRender = true;
  const currSnapshot = useSyncExternalStore(
    reactExports.useCallback(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject, use);
      try {
        if (!inRender && lastSnapshot.current && lastAffected.current && !p$5(
          lastSnapshot.current,
          nextSnapshot,
          lastAffected.current,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e3) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject, use)
  );
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  reactExports.useEffect(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache = reactExports.useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return a$1(
    currSnapshot,
    currAffected,
    proxyCache,
    targetCache
  );
}
var cryptoJs = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require$$0;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i3 = 0; i3 < thatSigBytes; i3++) {
                var thatByte = thatWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                thisWords[thisSigBytes + i3 >>> 2] |= thatByte << 24 - (thisSigBytes + i3) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i3 = 0; i3 < nBytes; i3 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i3 = 0; i3 < hexStrLength; i3 += 2) {
              words[i3 >>> 3] |= parseInt(hexStr.substr(i3, 2), 16) << 24 - i3 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i3 = 0; i3 < latin1StrLength; i3++) {
              words[i3 >>> 2] |= (latin1Str.charCodeAt(i3) & 255) << 24 - i3 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e3) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core);
  return core.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core)
    return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C2.x64 = {};
        C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i3 = 0; i3 < x64WordsLength; i3++) {
              var x64Word = x64Words[i3];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i3 = 0; i3 < wordsLength; i3++) {
              words[i3] = words[i3].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays)
    return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i3 = 0; i3 < typedArrayByteLength; i3++) {
              words[i3 >>> 2] |= typedArray[i3] << 24 - i3 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16)
    return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = swapEndian(words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= swapEndian(utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64)
    return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i3 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url)
    return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe = true) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i3 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe = true) {
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5.exports;
  hasRequiredMd5 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T3 = [];
        (function() {
          for (var i3 = 0; i3 < 64; i3++) {
            T3[i3] = Math2.abs(Math2.sin(i3 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M4, offset) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset + i3;
              var M_offset_i = M4[offset_i];
              M4[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H4 = this._hash.words;
            var M_offset_0 = M4[offset + 0];
            var M_offset_1 = M4[offset + 1];
            var M_offset_2 = M4[offset + 2];
            var M_offset_3 = M4[offset + 3];
            var M_offset_4 = M4[offset + 4];
            var M_offset_5 = M4[offset + 5];
            var M_offset_6 = M4[offset + 6];
            var M_offset_7 = M4[offset + 7];
            var M_offset_8 = M4[offset + 8];
            var M_offset_9 = M4[offset + 9];
            var M_offset_10 = M4[offset + 10];
            var M_offset_11 = M4[offset + 11];
            var M_offset_12 = M4[offset + 12];
            var M_offset_13 = M4[offset + 13];
            var M_offset_14 = M4[offset + 14];
            var M_offset_15 = M4[offset + 15];
            var a4 = H4[0];
            var b3 = H4[1];
            var c3 = H4[2];
            var d4 = H4[3];
            a4 = FF(a4, b3, c3, d4, M_offset_0, 7, T3[0]);
            d4 = FF(d4, a4, b3, c3, M_offset_1, 12, T3[1]);
            c3 = FF(c3, d4, a4, b3, M_offset_2, 17, T3[2]);
            b3 = FF(b3, c3, d4, a4, M_offset_3, 22, T3[3]);
            a4 = FF(a4, b3, c3, d4, M_offset_4, 7, T3[4]);
            d4 = FF(d4, a4, b3, c3, M_offset_5, 12, T3[5]);
            c3 = FF(c3, d4, a4, b3, M_offset_6, 17, T3[6]);
            b3 = FF(b3, c3, d4, a4, M_offset_7, 22, T3[7]);
            a4 = FF(a4, b3, c3, d4, M_offset_8, 7, T3[8]);
            d4 = FF(d4, a4, b3, c3, M_offset_9, 12, T3[9]);
            c3 = FF(c3, d4, a4, b3, M_offset_10, 17, T3[10]);
            b3 = FF(b3, c3, d4, a4, M_offset_11, 22, T3[11]);
            a4 = FF(a4, b3, c3, d4, M_offset_12, 7, T3[12]);
            d4 = FF(d4, a4, b3, c3, M_offset_13, 12, T3[13]);
            c3 = FF(c3, d4, a4, b3, M_offset_14, 17, T3[14]);
            b3 = FF(b3, c3, d4, a4, M_offset_15, 22, T3[15]);
            a4 = GG(a4, b3, c3, d4, M_offset_1, 5, T3[16]);
            d4 = GG(d4, a4, b3, c3, M_offset_6, 9, T3[17]);
            c3 = GG(c3, d4, a4, b3, M_offset_11, 14, T3[18]);
            b3 = GG(b3, c3, d4, a4, M_offset_0, 20, T3[19]);
            a4 = GG(a4, b3, c3, d4, M_offset_5, 5, T3[20]);
            d4 = GG(d4, a4, b3, c3, M_offset_10, 9, T3[21]);
            c3 = GG(c3, d4, a4, b3, M_offset_15, 14, T3[22]);
            b3 = GG(b3, c3, d4, a4, M_offset_4, 20, T3[23]);
            a4 = GG(a4, b3, c3, d4, M_offset_9, 5, T3[24]);
            d4 = GG(d4, a4, b3, c3, M_offset_14, 9, T3[25]);
            c3 = GG(c3, d4, a4, b3, M_offset_3, 14, T3[26]);
            b3 = GG(b3, c3, d4, a4, M_offset_8, 20, T3[27]);
            a4 = GG(a4, b3, c3, d4, M_offset_13, 5, T3[28]);
            d4 = GG(d4, a4, b3, c3, M_offset_2, 9, T3[29]);
            c3 = GG(c3, d4, a4, b3, M_offset_7, 14, T3[30]);
            b3 = GG(b3, c3, d4, a4, M_offset_12, 20, T3[31]);
            a4 = HH(a4, b3, c3, d4, M_offset_5, 4, T3[32]);
            d4 = HH(d4, a4, b3, c3, M_offset_8, 11, T3[33]);
            c3 = HH(c3, d4, a4, b3, M_offset_11, 16, T3[34]);
            b3 = HH(b3, c3, d4, a4, M_offset_14, 23, T3[35]);
            a4 = HH(a4, b3, c3, d4, M_offset_1, 4, T3[36]);
            d4 = HH(d4, a4, b3, c3, M_offset_4, 11, T3[37]);
            c3 = HH(c3, d4, a4, b3, M_offset_7, 16, T3[38]);
            b3 = HH(b3, c3, d4, a4, M_offset_10, 23, T3[39]);
            a4 = HH(a4, b3, c3, d4, M_offset_13, 4, T3[40]);
            d4 = HH(d4, a4, b3, c3, M_offset_0, 11, T3[41]);
            c3 = HH(c3, d4, a4, b3, M_offset_3, 16, T3[42]);
            b3 = HH(b3, c3, d4, a4, M_offset_6, 23, T3[43]);
            a4 = HH(a4, b3, c3, d4, M_offset_9, 4, T3[44]);
            d4 = HH(d4, a4, b3, c3, M_offset_12, 11, T3[45]);
            c3 = HH(c3, d4, a4, b3, M_offset_15, 16, T3[46]);
            b3 = HH(b3, c3, d4, a4, M_offset_2, 23, T3[47]);
            a4 = II(a4, b3, c3, d4, M_offset_0, 6, T3[48]);
            d4 = II(d4, a4, b3, c3, M_offset_7, 10, T3[49]);
            c3 = II(c3, d4, a4, b3, M_offset_14, 15, T3[50]);
            b3 = II(b3, c3, d4, a4, M_offset_5, 21, T3[51]);
            a4 = II(a4, b3, c3, d4, M_offset_12, 6, T3[52]);
            d4 = II(d4, a4, b3, c3, M_offset_3, 10, T3[53]);
            c3 = II(c3, d4, a4, b3, M_offset_10, 15, T3[54]);
            b3 = II(b3, c3, d4, a4, M_offset_1, 21, T3[55]);
            a4 = II(a4, b3, c3, d4, M_offset_8, 6, T3[56]);
            d4 = II(d4, a4, b3, c3, M_offset_15, 10, T3[57]);
            c3 = II(c3, d4, a4, b3, M_offset_6, 15, T3[58]);
            b3 = II(b3, c3, d4, a4, M_offset_13, 21, T3[59]);
            a4 = II(a4, b3, c3, d4, M_offset_4, 6, T3[60]);
            d4 = II(d4, a4, b3, c3, M_offset_11, 10, T3[61]);
            c3 = II(c3, d4, a4, b3, M_offset_2, 15, T3[62]);
            b3 = II(b3, c3, d4, a4, M_offset_9, 21, T3[63]);
            H4[0] = H4[0] + a4 | 0;
            H4[1] = H4[1] + b3 | 0;
            H4[2] = H4[2] + c3 | 0;
            H4[3] = H4[3] + d4 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H4 = hash.words;
            for (var i3 = 0; i3 < 4; i3++) {
              var H_i = H4[i3];
              H4[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a4, b3, c3, d4, x2, s5, t4) {
          var n2 = a4 + (b3 & c3 | ~b3 & d4) + x2 + t4;
          return (n2 << s5 | n2 >>> 32 - s5) + b3;
        }
        function GG(a4, b3, c3, d4, x2, s5, t4) {
          var n2 = a4 + (b3 & d4 | c3 & ~d4) + x2 + t4;
          return (n2 << s5 | n2 >>> 32 - s5) + b3;
        }
        function HH(a4, b3, c3, d4, x2, s5, t4) {
          var n2 = a4 + (b3 ^ c3 ^ d4) + x2 + t4;
          return (n2 << s5 | n2 >>> 32 - s5) + b3;
        }
        function II(a4, b3, c3, d4, x2, s5, t4) {
          var n2 = a4 + (c3 ^ (b3 | ~d4)) + x2 + t4;
          return (n2 << s5 | n2 >>> 32 - s5) + b3;
        }
        C2.MD5 = Hasher._createHelper(MD5);
        C2.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M4, offset) {
            var H4 = this._hash.words;
            var a4 = H4[0];
            var b3 = H4[1];
            var c3 = H4[2];
            var d4 = H4[3];
            var e3 = H4[4];
            for (var i3 = 0; i3 < 80; i3++) {
              if (i3 < 16) {
                W2[i3] = M4[offset + i3] | 0;
              } else {
                var n2 = W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16];
                W2[i3] = n2 << 1 | n2 >>> 31;
              }
              var t4 = (a4 << 5 | a4 >>> 27) + e3 + W2[i3];
              if (i3 < 20) {
                t4 += (b3 & c3 | ~b3 & d4) + 1518500249;
              } else if (i3 < 40) {
                t4 += (b3 ^ c3 ^ d4) + 1859775393;
              } else if (i3 < 60) {
                t4 += (b3 & c3 | b3 & d4 | c3 & d4) - 1894007588;
              } else {
                t4 += (b3 ^ c3 ^ d4) - 899497514;
              }
              e3 = d4;
              d4 = c3;
              c3 = b3 << 30 | b3 >>> 2;
              b3 = a4;
              a4 = t4;
            }
            H4[0] = H4[0] + a4 | 0;
            H4[1] = H4[1] + b3 | 0;
            H4[2] = H4[2] + c3 | 0;
            H4[3] = H4[3] + d4 | 0;
            H4[4] = H4[4] + e3 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C2.SHA1 = Hasher._createHelper(SHA1);
        C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha256 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256.exports;
  hasRequiredSha256 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var H4 = [];
        var K3 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H4[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K3[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H4.slice(0));
          },
          _doProcessBlock: function(M4, offset) {
            var H5 = this._hash.words;
            var a4 = H5[0];
            var b3 = H5[1];
            var c3 = H5[2];
            var d4 = H5[3];
            var e3 = H5[4];
            var f2 = H5[5];
            var g2 = H5[6];
            var h4 = H5[7];
            for (var i3 = 0; i3 < 64; i3++) {
              if (i3 < 16) {
                W2[i3] = M4[offset + i3] | 0;
              } else {
                var gamma0x = W2[i3 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i3 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i3] = gamma0 + W2[i3 - 7] + gamma1 + W2[i3 - 16];
              }
              var ch2 = e3 & f2 ^ ~e3 & g2;
              var maj = a4 & b3 ^ a4 & c3 ^ b3 & c3;
              var sigma0 = (a4 << 30 | a4 >>> 2) ^ (a4 << 19 | a4 >>> 13) ^ (a4 << 10 | a4 >>> 22);
              var sigma1 = (e3 << 26 | e3 >>> 6) ^ (e3 << 21 | e3 >>> 11) ^ (e3 << 7 | e3 >>> 25);
              var t1 = h4 + sigma1 + ch2 + K3[i3] + W2[i3];
              var t22 = sigma0 + maj;
              h4 = g2;
              g2 = f2;
              f2 = e3;
              e3 = d4 + t1 | 0;
              d4 = c3;
              c3 = b3;
              b3 = a4;
              a4 = t1 + t22 | 0;
            }
            H5[0] = H5[0] + a4 | 0;
            H5[1] = H5[1] + b3 | 0;
            H5[2] = H5[2] + c3 | 0;
            H5[3] = H5[3] + d4 | 0;
            H5[4] = H5[4] + e3 | 0;
            H5[5] = H5[5] + f2 | 0;
            H5[6] = H5[6] + g2 | 0;
            H5[7] = H5[7] + h4 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C2.SHA256 = Hasher._createHelper(SHA256);
        C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  })(sha256);
  return sha256.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C2.SHA224 = SHA256._createHelper(SHA224);
        C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K3 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i3 = 0; i3 < 80; i3++) {
            W2[i3] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M4, offset) {
            var H4 = this._hash.words;
            var H0 = H4[0];
            var H1 = H4[1];
            var H22 = H4[2];
            var H32 = H4[3];
            var H42 = H4[4];
            var H5 = H4[5];
            var H6 = H4[6];
            var H7 = H4[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H32.high;
            var H3l = H32.low;
            var H4h = H42.high;
            var H4l = H42.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah2 = H0h;
            var al2 = H0l;
            var bh2 = H1h;
            var bl2 = H1l;
            var ch2 = H2h;
            var cl2 = H2l;
            var dh2 = H3h;
            var dl2 = H3l;
            var eh2 = H4h;
            var el2 = H4l;
            var fh2 = H5h;
            var fl2 = H5l;
            var gh2 = H6h;
            var gl2 = H6l;
            var hh2 = H7h;
            var hl2 = H7l;
            for (var i3 = 0; i3 < 80; i3++) {
              var Wil;
              var Wih;
              var Wi2 = W2[i3];
              if (i3 < 16) {
                Wih = Wi2.high = M4[offset + i3 * 2] | 0;
                Wil = Wi2.low = M4[offset + i3 * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i3 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i3 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i3 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i3 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi2.high = Wih;
                Wi2.low = Wil;
              }
              var chh = eh2 & fh2 ^ ~eh2 & gh2;
              var chl = el2 & fl2 ^ ~el2 & gl2;
              var majh = ah2 & bh2 ^ ah2 & ch2 ^ bh2 & ch2;
              var majl = al2 & bl2 ^ al2 & cl2 ^ bl2 & cl2;
              var sigma0h = (ah2 >>> 28 | al2 << 4) ^ (ah2 << 30 | al2 >>> 2) ^ (ah2 << 25 | al2 >>> 7);
              var sigma0l = (al2 >>> 28 | ah2 << 4) ^ (al2 << 30 | ah2 >>> 2) ^ (al2 << 25 | ah2 >>> 7);
              var sigma1h = (eh2 >>> 14 | el2 << 18) ^ (eh2 >>> 18 | el2 << 14) ^ (eh2 << 23 | el2 >>> 9);
              var sigma1l = (el2 >>> 14 | eh2 << 18) ^ (el2 >>> 18 | eh2 << 14) ^ (el2 << 23 | eh2 >>> 9);
              var Ki2 = K3[i3];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl2 + sigma1l;
              var t1h = hh2 + sigma1h + (t1l >>> 0 < hl2 >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh2 = gh2;
              hl2 = gl2;
              gh2 = fh2;
              gl2 = fl2;
              fh2 = eh2;
              fl2 = el2;
              el2 = dl2 + t1l | 0;
              eh2 = dh2 + t1h + (el2 >>> 0 < dl2 >>> 0 ? 1 : 0) | 0;
              dh2 = ch2;
              dl2 = cl2;
              ch2 = bh2;
              cl2 = bl2;
              bh2 = ah2;
              bl2 = al2;
              al2 = t1l + t2l | 0;
              ah2 = t1h + t2h + (al2 >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al2;
            H0.high = H0h + ah2 + (H0l >>> 0 < al2 >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl2;
            H1.high = H1h + bh2 + (H1l >>> 0 < bl2 >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl2;
            H22.high = H2h + ch2 + (H2l >>> 0 < cl2 >>> 0 ? 1 : 0);
            H3l = H32.low = H3l + dl2;
            H32.high = H3h + dh2 + (H3l >>> 0 < dl2 >>> 0 ? 1 : 0);
            H4l = H42.low = H4l + el2;
            H42.high = H4h + eh2 + (H4l >>> 0 < el2 >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl2;
            H5.high = H5h + fh2 + (H5l >>> 0 < fl2 >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl2;
            H6.high = H6h + gh2 + (H6l >>> 0 < gl2 >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl2;
            H7.high = H7h + hh2 + (H7l >>> 0 < hl2 >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C2.SHA512 = Hasher._createHelper(SHA512);
        C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C2.SHA384 = SHA512._createHelper(SHA384);
        C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3)
    return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var C_algo = C2.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x2 = 1, y4 = 0;
          for (var t4 = 0; t4 < 24; t4++) {
            RHO_OFFSETS[x2 + 5 * y4] = (t4 + 1) * (t4 + 2) / 2 % 64;
            var newX = y4 % 5;
            var newY = (2 * x2 + 3 * y4) % 5;
            x2 = newX;
            y4 = newY;
          }
          for (var x2 = 0; x2 < 5; x2++) {
            for (var y4 = 0; y4 < 5; y4++) {
              PI_INDEXES[x2 + 5 * y4] = y4 + (2 * x2 + 3 * y4) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i3 = 0; i3 < 24; i3++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j2 = 0; j2 < 7; j2++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j2) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i3] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T3 = [];
        (function() {
          for (var i3 = 0; i3 < 25; i3++) {
            T3[i3] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i3 = 0; i3 < 25; i3++) {
              state[i3] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M4, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i3 = 0; i3 < nBlockSizeLanes; i3++) {
              var M2i = M4[offset + 2 * i3];
              var M2i1 = M4[offset + 2 * i3 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i3];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x2 = 0; x2 < 5; x2++) {
                var tMsw = 0, tLsw = 0;
                for (var y4 = 0; y4 < 5; y4++) {
                  var lane = state[x2 + 5 * y4];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T3[x2];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                var Tx4 = T3[(x2 + 4) % 5];
                var Tx1 = T3[(x2 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y4 = 0; y4 < 5; y4++) {
                  var lane = state[x2 + 5 * y4];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T3[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T3[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y4 = 0; y4 < 5; y4++) {
                  var laneIndex = x2 + 5 * y4;
                  var lane = state[laneIndex];
                  var TLane = T3[laneIndex];
                  var Tx1Lane = T3[(x2 + 1) % 5 + 5 * y4];
                  var Tx2Lane = T3[(x2 + 2) % 5 + 5 * y4];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i3 = 0; i3 < outputLengthLanes; i3++) {
              var lane = state[i3];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i3 = 0; i3 < 25; i3++) {
              state[i3] = state[i3].clone();
            }
            return clone;
          }
        });
        C2.SHA3 = Hasher._createHelper(SHA3);
        C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M4, offset) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset + i3;
              var M_offset_i = M4[offset_i];
              M4[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H4 = this._hash.words;
            var hl2 = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl2 = _sl.words;
            var sr = _sr.words;
            var al2, bl2, cl2, dl2, el2;
            var ar, br, cr, dr, er;
            ar = al2 = H4[0];
            br = bl2 = H4[1];
            cr = cl2 = H4[2];
            dr = dl2 = H4[3];
            er = el2 = H4[4];
            var t4;
            for (var i3 = 0; i3 < 80; i3 += 1) {
              t4 = al2 + M4[offset + zl[i3]] | 0;
              if (i3 < 16) {
                t4 += f1(bl2, cl2, dl2) + hl2[0];
              } else if (i3 < 32) {
                t4 += f2(bl2, cl2, dl2) + hl2[1];
              } else if (i3 < 48) {
                t4 += f3(bl2, cl2, dl2) + hl2[2];
              } else if (i3 < 64) {
                t4 += f4(bl2, cl2, dl2) + hl2[3];
              } else {
                t4 += f5(bl2, cl2, dl2) + hl2[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sl2[i3]);
              t4 = t4 + el2 | 0;
              al2 = el2;
              el2 = dl2;
              dl2 = rotl(cl2, 10);
              cl2 = bl2;
              bl2 = t4;
              t4 = ar + M4[offset + zr[i3]] | 0;
              if (i3 < 16) {
                t4 += f5(br, cr, dr) + hr[0];
              } else if (i3 < 32) {
                t4 += f4(br, cr, dr) + hr[1];
              } else if (i3 < 48) {
                t4 += f3(br, cr, dr) + hr[2];
              } else if (i3 < 64) {
                t4 += f2(br, cr, dr) + hr[3];
              } else {
                t4 += f1(br, cr, dr) + hr[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sr[i3]);
              t4 = t4 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t4;
            }
            t4 = H4[1] + cl2 + dr | 0;
            H4[1] = H4[2] + dl2 + er | 0;
            H4[2] = H4[3] + el2 + ar | 0;
            H4[3] = H4[4] + al2 + br | 0;
            H4[4] = H4[0] + bl2 + cr | 0;
            H4[0] = t4;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H4 = hash.words;
            for (var i3 = 0; i3 < 5; i3++) {
              var H_i = H4[i3];
              H4[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x2, y4, z3) {
          return x2 ^ y4 ^ z3;
        }
        function f2(x2, y4, z3) {
          return x2 & y4 | ~x2 & z3;
        }
        function f3(x2, y4, z3) {
          return (x2 | ~y4) ^ z3;
        }
        function f4(x2, y4, z3) {
          return x2 & z3 | y4 & ~z3;
        }
        function f5(x2, y4, z3) {
          return x2 ^ (y4 | ~z3);
        }
        function rotl(x2, n2) {
          return x2 << n2 | x2 >>> 32 - n2;
        }
        C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac.exports;
  hasRequiredHmac = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i3 = 0; i3 < hasherBlockSize; i3++) {
              oKeyWords[i3] ^= 1549556828;
              iKeyWords[i3] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac);
  return hmac.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2)
    return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i3 = 1; i3 < iterations; i3++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j2 = 0; j2 < blockWordsLength; j2++) {
                  blockWords[j2] ^= intermediateWords[j2];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf)
    return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i3 = 1; i3 < iterations; i3++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore)
    return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C2.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C2.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C2.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= block[i3];
            }
          }
          return CBC2;
        }();
        var C_pad = C2.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i3 = 0; i3 < nPaddingBytes; i3 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C2.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format2) {
            if (typeof ciphertext == "string") {
              return format2.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C2.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb)
    return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i3 = 0; i3 < blockSize; i3++) {
            words[offset + i3] ^= keystream[i3];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr)
    return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman)
    return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb)
    return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb)
    return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923)
    return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126)
    return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971)
    return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding)
    return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i3 = data.sigBytes - 1;
          for (var i3 = data.sigBytes - 1; i3 >= 0; i3--) {
            if (dataWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255) {
              data.sigBytes = i3 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding)
    return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex)
    return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C2.enc;
        var Hex = C_enc.Hex;
        var C_format = C2.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes.exports;
  hasRequiredAes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d4 = [];
          for (var i3 = 0; i3 < 256; i3++) {
            if (i3 < 128) {
              d4[i3] = i3 << 1;
            } else {
              d4[i3] = i3 << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi2 = 0;
          for (var i3 = 0; i3 < 256; i3++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d4[x2];
            var x4 = d4[x22];
            var x8 = d4[x4];
            var t4 = d4[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t4 << 24 | t4 >>> 8;
            SUB_MIX_1[x2] = t4 << 16 | t4 >>> 16;
            SUB_MIX_2[x2] = t4 << 8 | t4 >>> 24;
            SUB_MIX_3[x2] = t4;
            var t4 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t4 << 24 | t4 >>> 8;
            INV_SUB_MIX_1[sx] = t4 << 16 | t4 >>> 16;
            INV_SUB_MIX_2[sx] = t4 << 8 | t4 >>> 24;
            INV_SUB_MIX_3[sx] = t4;
            if (!x2) {
              x2 = xi2 = 1;
            } else {
              x2 = x22 ^ d4[d4[d4[x8 ^ x22]]];
              xi2 ^= d4[d4[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t4;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t4 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t4 = t4 << 8 | t4 >>> 24;
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                  t4 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t4;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t4 = keySchedule[ksRow];
              } else {
                var t4 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t4;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t4 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t4 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t4 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t4 & 255]];
              }
            }
          },
          encryptBlock: function(M4, offset) {
            this._doCryptBlock(M4, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M4, offset) {
            var t4 = M4[offset + 1];
            M4[offset + 1] = M4[offset + 3];
            M4[offset + 3] = t4;
            this._doCryptBlock(M4, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t4 = M4[offset + 1];
            M4[offset + 1] = M4[offset + 3];
            M4[offset + 3] = t4;
          },
          _doCryptBlock: function(M4, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M4[offset] ^ keySchedule[0];
            var s1 = M4[offset + 1] ^ keySchedule[1];
            var s22 = M4[offset + 2] ^ keySchedule[2];
            var s32 = M4[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s32 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s32 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s32 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t32 = SUB_MIX_02[s32 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s22 = t22;
              s32 = t32;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s32 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s32 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s32 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t32 = (SBOX2[s32 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
            M4[offset] = t0;
            M4[offset + 1] = t1;
            M4[offset + 2] = t22;
            M4[offset + 3] = t32;
          },
          keySize: 256 / 32
        });
        C2.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes)
    return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i3 = 0; i3 < 56; i3++) {
              var keyBitPos = PC1[i3] - 1;
              keyBits[i3] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i3 = 0; i3 < 24; i3++) {
                subKey[i3 / 6 | 0] |= keyBits[(PC2[i3] - 1 + bitShift) % 28] << 31 - i3 % 6;
                subKey[4 + (i3 / 6 | 0)] |= keyBits[28 + (PC2[i3 + 24] - 1 + bitShift) % 28] << 31 - i3 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i3 = 1; i3 < 7; i3++) {
                subKey[i3] = subKey[i3] >>> (i3 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i3 = 0; i3 < 16; i3++) {
              invSubKeys[i3] = subKeys[15 - i3];
            }
          },
          encryptBlock: function(M4, offset) {
            this._doCryptBlock(M4, offset, this._subKeys);
          },
          decryptBlock: function(M4, offset) {
            this._doCryptBlock(M4, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M4, offset, subKeys) {
            this._lBlock = M4[offset];
            this._rBlock = M4[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i3 = 0; i3 < 8; i3++) {
                f2 |= SBOX_P[i3][((rBlock ^ subKey[i3]) & SBOX_MASK[i3]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t4 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t4;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M4[offset] = this._lBlock;
            M4[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t4 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t4;
          this._lBlock ^= t4 << offset;
        }
        function exchangeRL(offset, mask) {
          var t4 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t4;
          this._rBlock ^= t4 << offset;
        }
        C2.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M4, offset) {
            this._des1.encryptBlock(M4, offset);
            this._des2.decryptBlock(M4, offset);
            this._des3.encryptBlock(M4, offset);
          },
          decryptBlock: function(M4, offset) {
            this._des3.decryptBlock(M4, offset);
            this._des2.encryptBlock(M4, offset);
            this._des1.decryptBlock(M4, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C2.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4)
    return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S4 = this._S = [];
            for (var i3 = 0; i3 < 256; i3++) {
              S4[i3] = i3;
            }
            for (var i3 = 0, j2 = 0; i3 < 256; i3++) {
              var keyByteIndex = i3 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j2 = (j2 + S4[i3] + keyByte) % 256;
              var t4 = S4[i3];
              S4[i3] = S4[j2];
              S4[j2] = t4;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M4, offset) {
            M4[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S4 = this._S;
          var i3 = this._i;
          var j2 = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i3 = (i3 + 1) % 256;
            j2 = (j2 + S4[i3]) % 256;
            var t4 = S4[i3];
            S4[i3] = S4[j2];
            S4[j2] = t4;
            keystreamWord |= S4[(S4[i3] + S4[j2]) % 256] << 24 - n2 * 8;
          }
          this._i = i3;
          this._j = j2;
          return keystreamWord;
        }
        C2.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i3 = this.cfg.drop; i3 > 0; i3--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit)
    return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S4 = [];
        var C_ = [];
        var G3 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            for (var i3 = 0; i3 < 4; i3++) {
              K3[i3] = (K3[i3] << 8 | K3[i3] >>> 24) & 16711935 | (K3[i3] << 24 | K3[i3] >>> 8) & 4278255360;
            }
            var X3 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C3 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C3[i3] ^= X3[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i32;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M4, offset) {
            var X3 = this._X;
            nextState.call(this);
            S4[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S4[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S4[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S4[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S4[i3] = (S4[i3] << 8 | S4[i3] >>> 24) & 16711935 | (S4[i3] << 24 | S4[i3] >>> 8) & 4278255360;
              M4[offset + i3] ^= S4[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C3 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C3[i3];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X3[i3] + C3[i3];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G3[i3] = gh2 ^ gl2;
          }
          X3[0] = G3[0] + (G3[7] << 16 | G3[7] >>> 16) + (G3[6] << 16 | G3[6] >>> 16) | 0;
          X3[1] = G3[1] + (G3[0] << 8 | G3[0] >>> 24) + G3[7] | 0;
          X3[2] = G3[2] + (G3[1] << 16 | G3[1] >>> 16) + (G3[0] << 16 | G3[0] >>> 16) | 0;
          X3[3] = G3[3] + (G3[2] << 8 | G3[2] >>> 24) + G3[1] | 0;
          X3[4] = G3[4] + (G3[3] << 16 | G3[3] >>> 16) + (G3[2] << 16 | G3[2] >>> 16) | 0;
          X3[5] = G3[5] + (G3[4] << 8 | G3[4] >>> 24) + G3[3] | 0;
          X3[6] = G3[6] + (G3[5] << 16 | G3[5] >>> 16) + (G3[4] << 16 | G3[4] >>> 16) | 0;
          X3[7] = G3[7] + (G3[6] << 8 | G3[6] >>> 24) + G3[5] | 0;
        }
        C2.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy)
    return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S4 = [];
        var C_ = [];
        var G3 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            var X3 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C3 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C3[i3] ^= X3[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i32;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M4, offset) {
            var X3 = this._X;
            nextState.call(this);
            S4[0] = X3[0] ^ X3[5] >>> 16 ^ X3[3] << 16;
            S4[1] = X3[2] ^ X3[7] >>> 16 ^ X3[5] << 16;
            S4[2] = X3[4] ^ X3[1] >>> 16 ^ X3[7] << 16;
            S4[3] = X3[6] ^ X3[3] >>> 16 ^ X3[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S4[i3] = (S4[i3] << 8 | S4[i3] >>> 24) & 16711935 | (S4[i3] << 24 | S4[i3] >>> 8) & 4278255360;
              M4[offset + i3] ^= S4[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X3 = this._X;
          var C3 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C3[i3];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X3[i3] + C3[i3];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G3[i3] = gh2 ^ gl2;
          }
          X3[0] = G3[0] + (G3[7] << 16 | G3[7] >>> 16) + (G3[6] << 16 | G3[6] >>> 16) | 0;
          X3[1] = G3[1] + (G3[0] << 8 | G3[0] >>> 24) + G3[7] | 0;
          X3[2] = G3[2] + (G3[1] << 16 | G3[1] >>> 16) + (G3[0] << 16 | G3[0] >>> 16) | 0;
          X3[3] = G3[3] + (G3[2] << 8 | G3[2] >>> 24) + G3[1] | 0;
          X3[4] = G3[4] + (G3[3] << 16 | G3[3] >>> 16) + (G3[2] << 16 | G3[2] >>> 16) | 0;
          X3[5] = G3[5] + (G3[4] << 8 | G3[4] >>> 24) + G3[3] | 0;
          X3[6] = G3[6] + (G3[5] << 16 | G3[5] >>> 16) + (G3[4] << 16 | G3[4] >>> 16) | 0;
          X3[7] = G3[7] + (G3[6] << 8 | G3[6] >>> 24) + G3[5] | 0;
        }
        C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
(function(module, exports) {
  (function(root, factory, undef) {
    {
      module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy());
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number2 = Number(dirtyNumber);
  if (isNaN(number2)) {
    return number2;
  }
  return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$1(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$1(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number2, targetLength) {
  var sign = number2 < 0 ? "-" : "";
  var output = Math.abs(number2).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  // Year
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const formatters$3 = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q2(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$3.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function K2(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date, token);
  },
  // Second
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function S2(date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const formatters$1 = formatters;
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
const formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
const formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number2 = Number(dirtyNumber);
  var rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const match$2 = match$1;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const defaultLocale = locale;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format$1(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
const base64ToBlob = (base64String, mimeType) => {
  console.debug("decoding base64(truncated to 100 chars)", base64String.slice(0, 100));
  const byteCharacters = atob(base64String);
  const byteNumbers = [];
  for (let i3 = 0; i3 < byteCharacters.length; i3++) {
    byteNumbers.push(byteCharacters.charCodeAt(i3));
  }
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
};
const timeElapsedMMSS = (duration) => {
  let seconds = Math.floor(duration / 1e3);
  const minutes = Math.floor(seconds % 3600 / 60);
  seconds = seconds % 60;
  return `${padZero(minutes)}:${padZero(seconds)}`;
};
const padZero = (num) => {
  return num.toString().padStart(2, "0");
};
const formatNow = () => {
  return format$1(new Date(2014, 1, 11), "yyyy-MM-dd_HH_mm_SS");
};
function currentProtocolHostPortPath() {
  const protocol = window.location.protocol;
  const hostname = window.location.hostname;
  const port = window.location.port;
  return `${protocol}//${hostname}:${port}/`;
}
function joinUrl(...parts) {
  return parts.map((part) => part.replace(/^\/+|\/+$/g, "")).join("/");
}
function chooseAudioMimeType(mimeTypes) {
  if (MediaRecorder) {
    const found = mimeTypes.find((m4) => MediaRecorder.isTypeSupported(m4.mimeType));
    if (found) {
      return found;
    }
  }
  console.error("cannot find mimeType for recorder");
  return void 0;
}
const cx = (...classes) => {
  return classes.filter((c3) => typeof c3 === "string").join(" ");
};
function compareSlices(arr1, arr2) {
  const slice1 = arr1.slice();
  const slice2 = arr2.slice();
  return JSON.stringify(slice1) === JSON.stringify(slice2);
}
const escapeSpaceKey = (event) => {
  if (event.code === "Space") {
    event.stopPropagation();
  }
};
const randomHash16Char = () => {
  const str = v4() + randomString(10);
  return cryptoJsExports.SHA256(str).toString().slice(0, 16);
};
const randomHash32Char = () => {
  const str = v4() + randomString(10);
  return cryptoJsExports.SHA256(str).toString().slice(0, 32);
};
const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
function randomString(length) {
  let result = "";
  for (let i3 = 0; i3 < length; i3++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}
function generateHash(input) {
  return cryptoJsExports.SHA256(input).toString();
}
const networkState = proxy({
  streamId: randomHash32Char()
});
var localforage$1 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return function e3(t4, n2, r3) {
      function s5(o4, u3) {
        if (!n2[o4]) {
          if (!t4[o4]) {
            var a4 = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u3 && a4)
              return a4(o4, true);
            if (i3)
              return i3(o4, true);
            var f2 = new Error("Cannot find module '" + o4 + "'");
            throw f2.code = "MODULE_NOT_FOUND", f2;
          }
          var l2 = n2[o4] = { exports: {} };
          t4[o4][0].call(l2.exports, function(e4) {
            var n3 = t4[o4][1][e4];
            return s5(n3 ? n3 : e4);
          }, l2, l2.exports, e3, t4, n2, r3);
        }
        return n2[o4].exports;
      }
      var i3 = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o3 = 0; o3 < r3.length; o3++)
        s5(r3[o3]);
      return s5;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick, 0);
            };
          }
        }
        var draining;
        var queue = [];
        function nextTick() {
          draining = true;
          var i3, oldQueue;
          var len = queue.length;
          while (len) {
            oldQueue = queue;
            queue = [];
            i3 = -1;
            while (++i3 < len) {
              oldQueue[i3]();
            }
            len = queue.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e3) {
            return handlers.reject(promise, e3);
          }
          if (returnValue === promise) {
            handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i3 = -1;
          var len = self2.queue.length;
          while (++i3 < len) {
            self2.queue[i3].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i3 = -1;
        var len = self2.queue.length;
        while (++i3 < len) {
          self2.queue[i3].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError2(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError2);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError2(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e3) {
          out.status = "error";
          out.value = e3;
        }
        return out;
      }
      Promise2.resolve = resolve;
      function resolve(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }
      Promise2.all = all2;
      function all2(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i3 = -1;
        var promise = new this(INTERNAL);
        while (++i3 < len) {
          allResolver(iterable[i3], i3);
        }
        return promise;
        function allResolver(value, i4) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i4] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i3 = -1;
        var promise = new this(INTERNAL);
        while (++i3 < len) {
          resolver(iterable[i3]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e3) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e3) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e3) {
          if (e3.name !== "TypeError") {
            throw e3;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i3 = 0; i3 < parts.length; i3 += 1) {
            builder.append(parts[i3]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString3 = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i3 = 0; i3 < length2; i3++) {
          arr[i3] = bin.charCodeAt(i3);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e3) {
            e3.preventDefault();
            e3.stopPropagation();
            resolve(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve, reject) {
          deferredOperation.resolve = resolve;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e3) {
              var db2 = openreq.result;
              try {
                db2.createObjectStore(dbInfo.storeName);
                if (e3.oldVersion <= 1) {
                  db2.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e3.oldVersion + " to version " + e3.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e3) {
            e3.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db2 = openreq.result;
            db2.onversionchange = function(e3) {
              e3.target.close();
            };
            resolve(db2);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e3) {
            var base64 = btoa(e3.target.result || "");
            resolve({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i3 = 0; i3 < forages.length; i3++) {
          var forage = forages[i3];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          for (var i4 = 0; i4 < forages.length; i4++) {
            forages[i4]._dbInfo.db = db2;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i3 in options) {
            dbInfo[i3] = options[i3];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
          var forage = dbContext.forages[j2];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          self2._dbInfo = dbInfo;
          for (var k3 = 0; k3 < forages.length; k3++) {
            var forage2 = forages[k3];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString3.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear2(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          if (n2 < 0) {
            resolve(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve(null);
                    return;
                  }
                  if (n2 === 0) {
                    resolve(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n2);
                    } else {
                      resolve(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openKeyCursor();
                var keys2 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve(keys2);
                    return;
                  }
                  keys2.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e3) {
                reject(e3);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db2) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db2;
            for (var i3 = 0; i3 < forages.length; i3++) {
              forages[i3]._dbInfo.db = db2;
            }
            return db2;
          });
          if (!options.storeName) {
            promise = dbPromise.then(function(db2) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i3 = 0; i3 < forages.length; i3++) {
                var forage = forages[i3];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  resolve(db3);
                };
              });
              return dropDBPromise.then(function(db3) {
                dbContext.db = db3;
                for (var i4 = 0; i4 < forages.length; i4++) {
                  var _forage = forages[i4];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function(db2) {
              if (!db2.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db2.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i3 = 0; i3 < forages.length; i3++) {
                var forage = forages[i3];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db3 = req.result;
                  db3.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db3 = req.result;
                  db3.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  db3.close();
                  resolve(db3);
                };
              });
              return dropObjectPromise.then(function(db3) {
                dbContext.db = db3;
                for (var j2 = 0; j2 < forages.length; j2++) {
                  var _forage2 = forages[j2];
                  _forage2._dbInfo.db = db3;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem: removeItem2,
        clear: clear2,
        length,
        key,
        keys,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i3;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i3 = 0; i3 < len; i3 += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i3]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i3 + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i3 + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i3 + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i3;
        for (i3 = 0; i3 < bytes.length; i3 += 3) {
          base64String += BASE_CHARS[bytes[i3] >> 2];
          base64String += BASE_CHARS[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
          base64String += BASE_CHARS[bytes[i3 + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e3) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e3);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t4, dbInfo, callback, errorCallback) {
        t4.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i3 in options) {
            dbInfo[i3] = typeof options[i3] !== "string" ? options[i3].toString() : options[i3];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e3) {
            return reject(e3);
          }
          dbInfo.db.transaction(function(t4) {
            createDbTable(t4, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve();
            }, function(t5, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t4, dbInfo, sqlStatement, args, callback, errorCallback) {
        t4.executeSql(sqlStatement, args, callback, function(t5, error) {
          if (error.code === error.SYNTAX_ERR) {
            t5.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t6, results) {
              if (!results.rows.length) {
                createDbTable(t6, dbInfo, function() {
                  t6.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t6, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t5, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t5, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve(result);
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t5, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i3 = 0; i3 < length2; i3++) {
                  var item = rows.item(i3);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator(result, item.key, i3 + 1);
                  if (result !== void 0) {
                    resolve(result);
                    return;
                  }
                }
                resolve();
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t4) {
                  tryExecuteSql(t4, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve(originalValue);
                  }, function(t5, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve();
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$12(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve();
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t5, results) {
                var result = results.rows.item(0).c;
                resolve(result);
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t5, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve(result);
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t4) {
              tryExecuteSql(t4, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t5, results) {
                var keys2 = [];
                for (var i3 = 0; i3 < results.rows.length; i3++) {
                  keys2.push(results.rows.item(i3).key);
                }
                resolve(keys2);
              }, function(t5, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db2) {
        return new Promise$1(function(resolve, reject) {
          db2.transaction(function(t4) {
            t4.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t5, results) {
              var storeNames = [];
              for (var i3 = 0; i3 < results.rows.length; i3++) {
                storeNames.push(results.rows.item(i3).name);
              }
              resolve({
                db: db2,
                storeNames
              });
            }, function(t5, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve) {
            var db2;
            if (options.name === currentConfig.name) {
              db2 = self2._dbInfo.db;
            } else {
              db2 = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve(getAllStoreNames(db2));
            } else {
              resolve({
                db: db2,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve, reject) {
              operationInfo.db.transaction(function(t4) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve2, reject2) {
                    t4.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve2();
                    }, function(t5, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i3 = 0, len = operationInfo.storeNames.length; i3 < len; i3++) {
                  operations.push(dropTable(operationInfo.storeNames[i3]));
                }
                Promise$1.all(operations).then(function() {
                  resolve();
                })["catch"](function(e3) {
                  reject(e3);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$12,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e3) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e3) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i3 in options) {
            dbInfo[i3] = options[i3];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i3 = localStorage.length - 1; i3 >= 0; i3--) {
            var key2 = localStorage.key(i3);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i3 = 0; i3 < length2; i3++) {
            var key2 = localStorage.key(i3);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n2, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n2);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys2 = [];
          for (var i3 = 0; i3 < length2; i3++) {
            var itemKey = localStorage.key(i3);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys2;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys2) {
          return keys2.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve(originalValue);
                } catch (e3) {
                  if (e3.name === "QuotaExceededError" || e3.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e3);
                  }
                  reject(e3);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve) {
            if (!options.storeName) {
              resolve(options.name + "/");
            } else {
              resolve(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i3 = localStorage.length - 1; i3 >= 0; i3--) {
              var key2 = localStorage.key(i3);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x2, y4) {
        return x2 === y4 || typeof x2 === "number" && typeof y4 === "number" && isNaN(x2) && isNaN(y4);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i3 = 0;
        while (i3 < len) {
          if (sameValue(array[i3], searchElement)) {
            return true;
          }
          i3++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend2() {
        for (var i3 = 1; i3 < arguments.length; i3++) {
          var arg = arguments[i3];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck2(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend2({}, DefaultConfig);
          this._config = extend2({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i3 in options) {
              if (i3 === "storeName") {
                options[i3] = options[i3].replace(/\W/g, "_");
              }
              if (i3 === "version" && typeof options[i3] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i3] = options[i3];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i3 = 0, len = driverMethods.length; i3 < len; i3++) {
                var driverMethodName = driverMethods[i3];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e3) {
              reject(e3);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend2(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i3 = 0, len = drivers.length; i3 < len; i3++) {
            var driverName = drivers[i3];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i3 = 0, len = LibraryMethods.length; i3 < len; i3++) {
            callWhenReady(this, LibraryMethods[i3]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance2(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage$1);
var localforageExports = localforage$1.exports;
const localforage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
const talkDbName = "talk";
const appStateKey = "app-state";
localforage.config({
  version: 1
});
const appDb = localforage.createInstance({
  name: talkDbName
});
const audioDB = "audio";
const audioDb = localforage.createInstance({
  name: audioDB
});
const audioPlayerMimeType = "audio/mpeg";
const maxLoadedVoice = 6;
const messageTimeoutSeconds = 30;
const minSpeakTimeMillis = 500;
function SSEEndpoint() {
  const ep = joinUrl(APIEndpoint(), "events");
  console.debug("SSEEndpoint:", ep);
  return ep;
}
function APIEndpoint() {
  let ep = {}.VITE_REACT_APP_ENDPOINT;
  if (ep) {
    return ep;
  }
  ep = joinUrl(currentProtocolHostPortPath(), "api");
  console.debug("RestfulEndpoint:", ep);
  return ep;
}
const popularMimeTypes = [
  { mimeType: "audio/webm; codecs=vp9", fileName: "audio.webm" },
  { mimeType: "audio/webm; codecs=opus", fileName: "audio.webm" },
  { mimeType: "audio/webm", fileName: "audio.webm" },
  { mimeType: "audio/mp4", fileName: "audio.mp4" }
];
const newThinking = (id2) => ({
  id: id2,
  role: "assistant",
  status: "thinking",
  text: "",
  createdAt: Date.now(),
  lastUpdatedAt: Date.now()
});
const newSending = () => ({
  id: randomHash16Char(),
  role: "user",
  status: "sending",
  text: "",
  createdAt: Date.now(),
  lastUpdatedAt: Date.now()
});
const onSent = (message) => {
  switch (message.status) {
    case "sending":
      message.status = "sent";
      message.lastUpdatedAt = Date.now();
      break;
    case "sent":
    case "thinking":
    case "typing":
    case "received":
    case "error":
      console.error("onSent is invalid, prev status:", message.status);
      break;
  }
};
const onTyping = (message, text) => {
  switch (message.status) {
    case "thinking":
    case "typing":
      message.status = "typing";
      message.text = message.text + text;
      message.lastUpdatedAt = Date.now();
      break;
    case "sending":
    case "sent":
    case "received":
    case "error":
      console.error("onTyping is invalid, prev status:", message.status, text);
      break;
  }
};
const onEOF = (message, text) => {
  switch (message.status) {
    case "thinking":
    case "typing":
      message.status = "received";
      message.text = message.text + text;
      message.lastUpdatedAt = Date.now();
      break;
    case "sending":
    case "sent":
    case "received":
    case "error":
      console.error("onEOF is invalid, prev status:", message.status);
      break;
  }
};
const onAudio = (message, audio) => {
  switch (message.status) {
    case "sending":
    case "sent":
      message.status = "sent";
      message.audio = audio;
      message.lastUpdatedAt = Date.now();
      break;
    case "thinking":
      message.status = "received";
      message.audio = audio;
      message.lastUpdatedAt = Date.now();
      break;
    case "received":
    case "typing":
    case "error":
      console.error("onAudio is invalid, prev status:", message.status);
      break;
  }
};
const onError = (message, errMsg) => {
  switch (message.status) {
    case "sending":
    case "sent":
    case "thinking":
    case "typing":
      message.status = "error";
      message.errorMessage = errMsg;
      message.lastUpdatedAt = Date.now();
      break;
    case "error":
    case "received":
      console.error("onError is invalid, prev status:" + message.status);
      break;
  }
};
const onMarkDeleted = (message) => {
  switch (message.status) {
    case "sending":
    case "sent":
    case "thinking":
    case "typing":
    case "received":
    case "error":
      message.status = "deleted";
      message.audio = void 0;
      message.text = "";
      message.errorMessage = "";
      break;
    case "deleted":
      console.error("onDelete is invalid, prev status:", message.status);
      break;
  }
};
const pending = ["sending", "thinking", "typing"];
const setErrorIfTimeout = (prev) => {
  if (pending.includes(prev.status) && Date.now() - prev.lastUpdatedAt > messageTimeoutSeconds * 1e3) {
    onError(prev, "Time out");
    return true;
  }
  return false;
};
const inHistory = ["received", "sent"];
const isInHistory = (m4) => {
  return m4.text !== "" && inHistory.includes(m4.status);
};
const chatGPTAPIReference = {
  maxHistory: {
    rangeStart: 0,
    rangeEnd: Number.MAX_SAFE_INTEGER,
    default: 4
  },
  maxTokens: {
    rangeStart: 0,
    rangeEnd: Number.MAX_SAFE_INTEGER,
    default: 2e3
  },
  temperature: {
    rangeStart: 0,
    rangeEnd: 2,
    default: 1
  },
  topP: {
    rangeStart: 0,
    rangeEnd: 1,
    default: 1
  },
  presencePenalty: {
    rangeStart: -2,
    rangeEnd: 2,
    default: 0
  },
  frequencyPenalty: {
    rangeStart: -2,
    rangeEnd: 2,
    default: 0
  }
};
const historyChoices = [
  { value: 1, name: "1", tags: [] },
  { value: 2, name: "2", tags: [] },
  { value: 3, name: "3", tags: [] },
  { value: 4, name: "4", tags: [] },
  { value: 5, name: "5", tags: [] },
  { value: 6, name: "6", tags: [] },
  { value: 7, name: "7", tags: [] },
  { value: 8, name: "8", tags: [] },
  { value: 9, name: "9", tags: [] },
  { value: 10, name: "10", tags: [] },
  { value: 20, name: "20", tags: [] },
  { value: 30, name: "30", tags: [] },
  { value: 40, name: "40", tags: [] },
  { value: 50, name: "50", tags: [] },
  { value: 100, name: "100", tags: [] }
];
const tokenChoices = [
  { value: 50, name: "50", tags: [] },
  { value: 100, name: "100", tags: [] },
  { value: 200, name: "200", tags: [] },
  { value: 500, name: "500", tags: [] },
  { value: 1e3, name: "1k", tags: [] },
  { value: 2e3, name: "2k", tags: [] },
  { value: 4e3, name: "4k", tags: [] },
  { value: 8e3, name: "8k", tags: [] },
  { value: 16e3, name: "16k", tags: [] },
  { value: 32e3, name: "32k", tags: [] },
  { value: Number.MAX_SAFE_INTEGER, name: "∞", tags: [] }
];
var GoogleTTSGender = /* @__PURE__ */ ((GoogleTTSGender2) => {
  GoogleTTSGender2[GoogleTTSGender2["unspecified"] = 0] = "unspecified";
  GoogleTTSGender2[GoogleTTSGender2["male"] = 1] = "male";
  GoogleTTSGender2[GoogleTTSGender2["female"] = 2] = "female";
  GoogleTTSGender2[GoogleTTSGender2["neutral"] = 3] = "neutral";
  return GoogleTTSGender2;
})(GoogleTTSGender || {});
const googleSTTLanguageSettings = [
  {
    value: "af-ZA",
    name: "Afrikaans (Suid-Afrika)",
    tags: []
  },
  {
    value: "am-ET",
    name: "አማርኛ (ኢትዮጵያ)",
    tags: []
  },
  {
    value: "hy-AM",
    name: "Հայ (Հայաստան)",
    tags: []
  },
  {
    value: "az-AZ",
    name: "Azərbaycan (Azərbaycan)(Azerbaijan)",
    tags: []
  },
  {
    value: "id-ID",
    name: "Bahasa Indonesia (Indonesia)",
    tags: []
  },
  {
    value: "ms-MY",
    name: "Bahasa Melayu (Malaysia)",
    tags: []
  },
  {
    value: "bn-BD",
    name: "বাংলা (বাংলাদেশ)",
    tags: []
  },
  {
    value: "bn-IN",
    name: "বাংলা (ভারত)",
    tags: []
  },
  {
    value: "ca-ES",
    name: "Català (Espanya)",
    tags: []
  },
  {
    value: "cs-CZ",
    name: "Čeština (Česká republika)",
    tags: []
  },
  {
    value: "da-DK",
    name: "Dansk (Danmark)",
    tags: []
  },
  {
    value: "de-DE",
    name: "Deutsch (Deutschland)",
    tags: []
  },
  {
    value: "en-AU",
    name: "English (Australia)",
    tags: []
  },
  {
    value: "en-CA",
    name: "English (Canada)",
    tags: []
  },
  {
    value: "en-GH",
    name: "English (Ghana)",
    tags: []
  },
  {
    value: "en-GB",
    name: "English (Great Britain)",
    tags: []
  },
  {
    value: "en-IN",
    name: "English (India)",
    tags: []
  },
  {
    value: "en-IE",
    name: "English (Ireland)",
    tags: []
  },
  {
    value: "en-KE",
    name: "English (Kenya)",
    tags: []
  },
  {
    value: "en-NZ",
    name: "English (New Zealand)",
    tags: []
  },
  {
    value: "en-NG",
    name: "English (Nigeria)",
    tags: []
  },
  {
    value: "en-PH",
    name: "English (Philippines)",
    tags: []
  },
  {
    value: "en-ZA",
    name: "English (South Africa)",
    tags: []
  },
  {
    value: "en-TZ",
    name: "English (Tanzania)",
    tags: []
  },
  {
    value: "en-US",
    name: "English (United States)",
    tags: []
  },
  {
    value: "es-AR",
    name: "Español (Argentina)",
    tags: []
  },
  {
    value: "es-BO",
    name: "Español (Bolivia)",
    tags: []
  },
  {
    value: "es-CL",
    name: "Español (Chile)",
    tags: []
  },
  {
    value: "es-CO",
    name: "Español (Colombia)",
    tags: []
  },
  {
    value: "es-CR",
    name: "Español (Costa Rica)",
    tags: []
  },
  {
    value: "es-EC",
    name: "Español (Ecuador)",
    tags: []
  },
  {
    value: "es-SV",
    name: "Español (El Salvador)",
    tags: []
  },
  {
    value: "es-ES",
    name: "Español (España)",
    tags: []
  },
  {
    value: "es-US",
    name: "Español (Estados Unidos)",
    tags: []
  },
  {
    value: "es-GT",
    name: "Español (Guatemala)",
    tags: []
  },
  {
    value: "es-HN",
    name: "Español (Honduras)",
    tags: []
  },
  {
    value: "es-MX",
    name: "Español (México)",
    tags: []
  },
  {
    value: "es-NI",
    name: "Español (Nicaragua)",
    tags: []
  },
  {
    value: "es-PA",
    name: "Español (Panamá)",
    tags: []
  },
  {
    value: "es-PY",
    name: "Español (Paraguay)",
    tags: []
  },
  {
    value: "es-PE",
    name: "Español (Perú)",
    tags: []
  },
  {
    value: "es-PR",
    name: "Español (Puerto Rico)",
    tags: []
  },
  {
    value: "es-DO",
    name: "Español (República Dominicana)",
    tags: []
  },
  {
    value: "es-UY",
    name: "Español (Uruguay)",
    tags: []
  },
  {
    value: "es-VE",
    name: "Español (Venezuela)",
    tags: []
  },
  {
    value: "eu-ES",
    name: "Euskara (Espainia)",
    tags: []
  },
  {
    value: "fil-PH",
    name: "Filipino (Pilipinas)",
    tags: []
  },
  {
    value: "fr-CA",
    name: "Français (Canada)",
    tags: []
  },
  {
    value: "fr-FR",
    name: "Français (France)",
    tags: []
  },
  {
    value: "gl-ES",
    name: "Galego (España)",
    tags: []
  },
  {
    value: "ka-GE",
    name: "ქართული (საქართველო)",
    tags: []
  },
  {
    value: "gu-IN",
    name: "ગુજરાતી (ભારત)",
    tags: []
  },
  {
    value: "hr-HR",
    name: "Hrvatski (Hrvatska)",
    tags: []
  },
  {
    value: "zu-Z",
    name: "IsiZulu (Ningizimu Afrika)",
    tags: []
  },
  {
    value: "is-IS",
    name: "Íslenska (Ísland)",
    tags: []
  },
  {
    value: "it-IT",
    name: "Italiano (Italia)",
    tags: []
  },
  {
    value: "jv-ID",
    name: "Jawa (Indonesia)",
    tags: []
  },
  {
    value: "kn-IN",
    name: "ಕನ್ನಡ (ಭಾರತ)",
    tags: []
  },
  {
    value: "km-KH",
    name: "ភាសាខ្មែរ (កម្ពុជា)",
    tags: []
  },
  {
    value: "lo-LA",
    name: "ລາວ (ລາວ)",
    tags: []
  },
  {
    value: "lv-LV",
    name: "Latviešu (latviešu)",
    tags: []
  },
  {
    value: "lt-LT",
    name: "Lietuvių (Lietuva)",
    tags: []
  },
  {
    value: "hu-HU",
    name: "Magyar (Magyarország)",
    tags: []
  },
  {
    value: "ml-IN",
    name: "മലയാളം (ഇന്ത്യ)",
    tags: []
  },
  {
    value: "mr-IN",
    name: "मराठी (भारत)",
    tags: []
  },
  {
    value: "nl-NL",
    name: "Nederlands (Nederland)",
    tags: []
  },
  {
    value: "ne-NP",
    name: "नेपाली (नेपाल)",
    tags: []
  },
  {
    value: "nb-NO",
    name: "Norsk bokmål (Norge)",
    tags: []
  },
  {
    value: "pl-PL",
    name: "Polski (Polska)",
    tags: []
  },
  {
    value: "pt-BR",
    name: "Português (Brasil)",
    tags: []
  },
  {
    value: "pt-PT",
    name: "Português (Portugal)",
    tags: []
  },
  {
    value: "ro-RO",
    name: "Română (România)",
    tags: []
  },
  {
    value: "si-LK",
    name: "සිංහල (ශ්රී ලංකාව)",
    tags: []
  },
  {
    value: "sk-SK",
    name: "Slovenčina (Slovensko)",
    tags: []
  },
  {
    value: "sl-SI",
    name: "Slovenščina (Slovenija)",
    tags: []
  },
  {
    value: "su-ID",
    name: "Urang (Indonesia)",
    tags: []
  },
  {
    value: "sw-TZ",
    name: "Swahili (Tanzania)",
    tags: []
  },
  {
    value: "sw-KE",
    name: "Swahili (Kenya)",
    tags: []
  },
  {
    value: "fi-FI",
    name: "Suomi (Suomi)",
    tags: []
  },
  {
    value: "sv-SE",
    name: "Svenska (Sverige)",
    tags: []
  },
  {
    value: "ta-IN",
    name: "தமிழ் (இந்தியா)",
    tags: []
  },
  {
    value: "ta-SG",
    name: "தமிழ் (சிங்கப்பூர்)",
    tags: []
  },
  {
    value: "ta-LK",
    name: "தமிழ் (இலங்கை)",
    tags: []
  },
  {
    value: "ta-MY",
    name: "தமிழ் (மலேசியா)",
    tags: []
  },
  {
    value: "te-IN",
    name: "తెలుగు (భారతదేశం)",
    tags: []
  },
  {
    value: "vi-VN",
    name: "Tiếng Việt (Việt Nam)",
    tags: []
  },
  {
    value: "tr-TR",
    name: "Türkçe (Türkiye)",
    tags: []
  },
  {
    value: "ur-PK",
    name: "اردو (پاکستان)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ur-IN",
    name: "اردو (بھارت)",
    // rtl: !0,
    tags: []
  },
  {
    value: "el-GR",
    name: "Ελληνικά (Ελλάδα)",
    tags: []
  },
  {
    value: "bg-BG",
    name: "Български (България)",
    tags: []
  },
  {
    value: "ru-RU",
    name: "Русский (Россия)",
    tags: []
  },
  {
    value: "sr-RS",
    name: "Српски (Србија)",
    tags: []
  },
  {
    value: "uk-UA",
    name: "Українська (Україна)",
    tags: []
  },
  {
    value: "he-IL",
    name: "עברית (ישראל)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-IL",
    name: "العربية (إسرائيل)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-XA",
    name: "Arabic, multi-region",
    tags: []
  },
  {
    value: "ar-JO",
    name: "العربية (الأردن)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-AE",
    name: "العربية (الإمارات)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-BH",
    name: "العربية (البحرين)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-DZ",
    name: "العربية (الجزائر)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-SA",
    name: "العربية (السعودية)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-IQ",
    name: "العربية (العراق)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-KW",
    name: "العربية (الكويت)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-MA",
    name: "العربية (المغرب)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-TN",
    name: "العربية (تونس)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-OM",
    name: "العربية (عُمان)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-PS",
    name: "العربية (فلسطين)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-QA",
    name: "العربية (قطر)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-LB",
    name: "العربية (لبنان)",
    // rtl: !0,
    tags: []
  },
  {
    value: "ar-EG",
    name: "العربية (مصر)",
    // rtl: !0,
    tags: []
  },
  {
    value: "fa-IR",
    name: "فارسی (ایران)",
    // rtl: !0,
    tags: []
  },
  {
    value: "hi-IN",
    name: "हिन्दी (भारत)",
    tags: []
  },
  {
    value: "th-TH",
    name: "ไทย (ประเทศไทย)",
    tags: []
  },
  {
    value: "ko-KR",
    name: "한국어 (대한민국)",
    tags: []
  },
  {
    value: "cmn-Hant-TW",
    name: "國語 (台灣)",
    tags: []
  },
  {
    value: "yue-Hant-HK",
    name: "廣東話 (香港)",
    tags: []
  },
  {
    value: "ja-JP",
    name: "日本語（日本)",
    tags: []
  },
  {
    value: "cmn-Hans-HK",
    name: "普通話 (香港)",
    tags: []
  },
  {
    value: "cmn-Hans-CN",
    name: "普通话 (中国大陆)",
    tags: []
  },
  {
    value: "cmn-CN",
    name: "普通话 (中国大陆)",
    tags: []
  },
  {
    value: "yue-HK",
    name: "廣東話 (香港)",
    tags: []
  },
  {
    value: "cmn-TW",
    name: "國語 (台灣)",
    tags: []
  }
];
const googleTTSLanguageStrings = googleSTTLanguageSettings;
const googleTTSAPIReference = {
  language: {
    choices: googleTTSLanguageStrings,
    default: {
      value: "en-US",
      name: "English (United States)",
      tags: []
    }
  },
  gender: {
    choices: [
      {
        name: "unspecified",
        value: GoogleTTSGender.unspecified,
        tags: []
      },
      {
        name: "male",
        value: GoogleTTSGender.male,
        tags: []
      },
      {
        name: "female",
        value: GoogleTTSGender.female,
        tags: []
      },
      {
        name: "neutral",
        value: GoogleTTSGender.neutral,
        tags: []
      }
    ],
    default: {
      name: "unspecified",
      value: GoogleTTSGender.unspecified,
      tags: []
    }
  },
  speakingRate: {
    rangeStart: 0.25,
    rangeEnd: 4,
    default: 1
  },
  pitch: {
    rangeStart: -20,
    rangeEnd: 20,
    default: 0
  },
  volumeGainDb: {
    rangeStart: -96,
    rangeEnd: 16,
    default: 0
  }
};
const elevenlabsAPIReference = {
  stability: {
    rangeStart: 0,
    rangeEnd: 1,
    default: 0.5
  },
  clarity: {
    rangeStart: 0,
    rangeEnd: 1,
    default: 0.75
  }
};
const defaultOption = () => ({
  llm: {
    chatGPT: {
      available: false,
      enabled: true,
      maxTokens: chatGPTAPIReference.maxTokens.default,
      temperature: chatGPTAPIReference.temperature.default,
      topP: chatGPTAPIReference.topP.default,
      presencePenalty: chatGPTAPIReference.presencePenalty.default,
      frequencyPenalty: chatGPTAPIReference.frequencyPenalty.default
    },
    claude: {
      available: false,
      enabled: true
    },
    maxHistory: 1e3
  },
  tts: {
    google: {
      available: false,
      enabled: true,
      languageCode: googleTTSAPIReference.language.default.value,
      gender: googleTTSAPIReference.gender.default.value,
      speakingRate: googleTTSAPIReference.speakingRate.default,
      pitch: googleTTSAPIReference.pitch.default,
      volumeGainDb: googleTTSAPIReference.volumeGainDb.default
    },
    elevenlabs: {
      available: false,
      enabled: true,
      stability: elevenlabsAPIReference.stability.default,
      clarity: elevenlabsAPIReference.clarity.default
    }
  },
  stt: {
    whisper: {
      available: false,
      enabled: true
    }
  }
});
const adjustOption = (c3, s5) => {
  c3.llm.chatGPT.available = s5.llm.chatGPT.available;
  c3.llm.chatGPT.model = pickOne(c3.llm.chatGPT.model, s5.llm.chatGPT.models);
  c3.tts.google.available = s5.tts.google.available;
  c3.tts.elevenlabs.available = s5.tts.elevenlabs.available;
  c3.tts.elevenlabs.voiceId = pickOne(c3.tts.elevenlabs.voiceId, s5.tts.elevenlabs.voices, (voice) => voice.id);
  c3.stt.whisper.available = s5.stt.whisper.available;
  c3.stt.whisper.model = pickOne(c3.stt.whisper.model, s5.stt.whisper.models);
};
const toRestfulAPIOption = (c3) => {
  const opt = {
    toSpeech: false,
    // maybe enable in the future
    toText: true,
    completion: true,
    completionToSpeech: true
  };
  const chatGPT = c3.llm.chatGPT;
  if (chatGPT.available && chatGPT.enabled && chatGPT.model) {
    opt.llmOption = {
      chatGPT: {
        ...chatGPT,
        model: chatGPT.model
      }
    };
  }
  const google = c3.tts.google;
  const elevenlabs = c3.tts.elevenlabs;
  if (google.available && google.enabled) {
    opt.ttsOption = {
      google: {
        ...google
      }
    };
  } else if (elevenlabs.available && elevenlabs.enabled && elevenlabs.voiceId) {
    opt.ttsOption = {
      elevenlabs: {
        ...elevenlabs,
        voiceId: elevenlabs.voiceId
      }
    };
  }
  const whisper = c3.stt.whisper;
  if (whisper.available && whisper.enabled && whisper.model) {
    opt.sttOption = {
      whisper: {
        ...whisper,
        model: whisper.model
      }
    };
  }
  return opt;
};
const pickOne = (current, pool, getValue) => {
  if (getValue === void 0) {
    getValue = (t4) => t4;
  }
  if (pool && pool.length > 0) {
    const values = pool.map(getValue);
    if (current && values.includes(current)) {
      return current;
    } else {
      return values[0];
    }
  }
  return void 0;
};
const defaultServerAbility = () => {
  return {
    llm: {
      available: false,
      chatGPT: {
        available: false
      }
    },
    tts: {
      available: false,
      google: {
        available: false
      },
      elevenlabs: {
        available: false
      }
    },
    stt: {
      available: false,
      whisper: {
        available: false
      },
      google: {
        available: false
      }
    }
  };
};
const hydrationState = proxy({
  hydrated: false
});
const appState = proxy({
  auth: {
    passwordHash: "",
    loggedIn: false
  },
  ability: defaultServerAbility(),
  option: defaultOption(),
  chats: {},
  currentChatId: "",
  panelSelection: "chats"
});
const defaultAppState = () => ({
  auth: {
    passwordHash: "",
    loggedIn: false
  },
  ability: defaultServerAbility(),
  option: defaultOption(),
  chats: {},
  currentChatId: "",
  panelSelection: "chats"
});
const clearSettings = () => {
  const dft = defaultAppState();
  appState.auth = dft.auth;
  appState.ability = dft.ability;
  appState.option = dft.option;
  appState.panelSelection = dft.panelSelection;
};
const clearChats = () => {
  const dft = defaultAppState();
  appState.chats = dft.chats;
  appState.currentChatId = dft.currentChatId;
};
const resetAppState = () => {
  const dft = defaultAppState();
  appState.auth = dft.auth;
  appState.ability = dft.ability;
  appState.option = dft.option;
  appState.chats = dft.chats;
  appState.currentChatId = dft.currentChatId;
  appState.panelSelection = dft.panelSelection;
};
appDb.getItem(appStateKey).then((as) => {
  console.debug("restoring from db:", as);
  if (as !== null) {
    Object.keys(appState).forEach((key) => {
      appState[key] = as[key];
    });
  }
  console.debug("restored");
  hydrationState.hydrated = true;
});
subscribe(appState, () => {
  const hySnp = snapshot(hydrationState);
  if (!hySnp.hydrated) {
    console.debug("skipping subscription due to not hydrated");
    return;
  }
  const as = snapshot(appState);
  console.debug("saving appState:", as);
  appDb.setItem(appStateKey, as).then(() => {
    console.debug("saved");
  });
});
const findMessage = (chatProxy, messageId) => {
  return chatProxy.messages.find((m4) => m4.id === messageId);
};
const markMessageAsDeleted = (chatId, messageId) => {
  const chat = appState.chats[chatId];
  if (!chat) {
    console.error("failed to mark the message as deleted, because the chat is gone. this usually happens when the chat is deleted. chatId,messageId:", chatId, messageId);
    return;
  }
  for (let i3 = chat.messages.length - 1; i3 >= 0; i3--) {
    const message = chat.messages[i3];
    if (message.id === messageId) {
      onMarkDeleted(message);
    }
  }
};
const savePassAsHash = (password) => {
  appState.auth.passwordHash = password;
};
const setLoggedIn = (loggedIn) => {
  appState.auth.loggedIn = loggedIn;
};
const deleteChat = (id2) => {
  const chats = appState.chats;
  const currentChatId = appState.currentChatId;
  if (currentChatId === "" || id2 != currentChatId) {
    delete chats[id2];
  } else if (!chats[currentChatId]) {
    appState.currentChatId = "";
  } else {
    const keys = Object.keys(chats);
    if (keys.length === 0) {
      appState.currentChatId = "";
    } else if (keys.length === 1) {
      delete chats[id2];
      appState.currentChatId = "";
    } else {
      let i3 = keys.length - 1;
      for (; i3 >= 0; i3--) {
        if (keys[i3] === currentChatId) {
          break;
        }
      }
      if (i3 < 0) {
        throw new Error("impossible");
      } else if (i3 < keys.length - 1) {
        const newId = keys[i3 + 1];
        delete chats[currentChatId];
        appState.currentChatId = newId;
      } else if (i3 === keys.length - 1) {
        const newId = keys[i3 - 1];
        delete chats[currentChatId];
        appState.currentChatId = newId;
      } else {
        throw new Error("impossible");
      }
    }
  }
};
const axiosInstance = axios$1.create({
  baseURL: APIEndpoint(),
  timeout: 5e3
});
axiosInstance.interceptors.request.use((config) => {
  const networkSnp = snapshot(networkState);
  const authSnp = snapshot(appState.auth);
  config.headers["Stream-ID"] = networkSnp.streamId;
  if (!config.headers["Authorization"]) {
    config.headers["Authorization"] = "Bearer " + authSnp.passwordHash;
  }
  return config;
});
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response && error.response.status === 401) {
      setLoggedIn(false);
      console.info("Unauthorized", error.response);
    }
    return Promise.reject(error);
  }
);
const postChat = (chat) => {
  return axiosInstance.post("chat", chat);
};
const postAudioChat = (audio, fileName, chat) => {
  const formData = new FormData();
  formData.append("audio", audio, fileName);
  formData.append("chat", JSON.stringify(chat));
  return axiosInstance.postForm("audio-chat", formData);
};
const login = (password) => {
  return axiosInstance.get("health", {
    headers: password ? {
      "Authorization": "Bearer " + generateHash(password)
    } : {}
  });
};
var animateColors = function(timestamp) {
  var wasWindowIdled = timestamp - this.previousTimeStamp > 100;
  var isLoop = this.states[this.activeState].loop !== void 0 ? this.states[this.activeState].loop : true;
  var progressPercent, isLooping, nextGradient;
  if (this.previousTimeStamp === null || wasWindowIdled) {
    this.previousTimeStamp = timestamp;
  }
  this.progress = this.progress + (timestamp - this.previousTimeStamp);
  progressPercent = (this.progress / this.activetransitionSpeed * 100).toFixed(2);
  this.previousTimeStamp = timestamp;
  this.refreshColorsAndPos(progressPercent);
  if (progressPercent < 100) {
    this.animation = requestAnimationFrame(this.animateColors.bind(this));
  } else {
    if (this.channelsIndex < this.states[this.activeState].gradients.length - 2 || isLoop) {
      if (this.isChangingState) {
        this.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5e3;
        this.isChangingState = false;
      }
      this.previousTimeStamp = null;
      this.progress = 0;
      this.channelsIndex++;
      isLooping = false;
      if (this.channelsIndex === this.states[this.activeState].gradients.length - 1) {
        isLooping = true;
      } else if (this.channelsIndex === this.states[this.activeState].gradients.length) {
        this.channelsIndex = 0;
      }
      nextGradient = this.states[this.activeState].gradients[this.channelsIndex + 1] === void 0 ? this.states[this.activeState].gradients[0] : this.states[this.activeState].gradients[this.channelsIndex + 1];
      this.setColors();
      this.animation = requestAnimationFrame(this.animateColors.bind(this));
      if (this.callbacks.onGradientChange) {
        this.callbacks.onGradientChange({
          isLooping,
          colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],
          colorsTo: nextGradient,
          activeState: this.activeState
        });
      }
      this.canvas.dispatchEvent(this.events.gradientChange({
        isLooping,
        colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],
        colorsTo: nextGradient,
        activeState: this.activeState
      }));
    } else {
      cancelAnimationFrame(this.animation);
      if (this.callbacks.onEnd)
        this.callbacks.onEnd();
      this.canvas.dispatchEvent(new CustomEvent("granim:end"));
    }
  }
};
var changeBlendingMode = function(newBlendingMode) {
  this.context.clearRect(0, 0, this.x1, this.y1);
  this.context.globalCompositeOperation = this.image.blendingMode = newBlendingMode;
  this.validateInput("blendingMode");
  if (this.isPaused)
    this.refreshColorsAndPos();
};
var changeDirection = function(newDirection) {
  this.context.clearRect(0, 0, this.x1, this.y1);
  this.direction = newDirection;
  this.validateInput("direction");
  if (this.isPaused)
    this.refreshColorsAndPos();
};
var changeState = function(newState) {
  var _this = this;
  if (this.activeState === newState) {
    return;
  }
  if (!this.isPaused) {
    this.isPaused = true;
    this.pause();
  }
  this.channelsIndex = -1;
  this.activetransitionSpeed = this.stateTransitionSpeed;
  this.activeColorsDiff = [];
  this.activeColorsPosDiff = [];
  this.activeColors = this.getCurrentColors();
  this.activeColorsPos = this.getCurrentColorsPos();
  this.progress = 0;
  this.previousTimeStamp = null;
  this.isChangingState = true;
  this.states[newState].gradients[0].forEach(function(gradientColor, i3, arr) {
    var nextColors = _this.convertColorToRgba(_this.getColor(gradientColor));
    var nextColorsPos = _this.getColorPos(gradientColor, i3);
    var colorDiff = _this.getColorDiff(_this.activeColors[i3], nextColors);
    var colorPosDiff = _this.getColorPosDiff(_this.activeColorsPos[i3], nextColorsPos);
    _this.activeColorsDiff.push(colorDiff);
    _this.activeColorsPosDiff.push(colorPosDiff);
  });
  this.activeState = newState;
  this.play();
};
var clear$1 = function() {
  if (!this.isPaused) {
    cancelAnimationFrame(this.animation);
  } else {
    this.isPaused = false;
  }
  this.isCleared = true;
  this.context.clearRect(0, 0, this.x1, this.y1);
};
var regex = {
  hexa: /^#(?:[0-9a-fA-F]{3}){1,2}$/,
  rgba: /^rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(.?\d{1,3})\)$/,
  rgb: /^rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)$/,
  hsla: /^hsla\((\d{1,3}), ?(\d{1,3})%, ?(\d{1,3})%, ?(.?\d{1,3})\)$/,
  hsl: /^hsl\((\d{1,3}), ?(\d{1,3})%, ?(\d{1,3})%\)$/
}, match;
var convertColorToRgba = function(color2) {
  switch (identifyColorType(color2)) {
    default:
      this.triggerError("colorType");
    case "hexa":
      return hexToRgba(color2);
    case "rgba":
      return [
        parseInt(match[1], 10),
        parseInt(match[2], 10),
        parseInt(match[3], 10),
        parseFloat(match[4])
      ];
    case "rgb":
      return [
        parseInt(match[1], 10),
        parseInt(match[2], 10),
        parseInt(match[3], 10),
        1
      ];
    case "hsla":
      return hslaToRgb(
        parseInt(match[1], 10) / 360,
        parseInt(match[2], 10) / 100,
        parseInt(match[3], 10) / 100,
        parseFloat(match[4])
      );
    case "hsl":
      return hslaToRgb(
        parseInt(match[1], 10) / 360,
        parseInt(match[2], 10) / 100,
        parseInt(match[3], 10) / 100,
        1
      );
  }
};
function identifyColorType(color2) {
  var colorTypes2 = Object.keys(regex);
  var i3 = 0;
  for (i3; i3 < colorTypes2.length; i3++) {
    match = regex[colorTypes2[i3]].exec(color2);
    if (match)
      return colorTypes2[i3];
  }
  return false;
}
function hexToRgba(hex2) {
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex2 = hex2.replace(shorthandRegex, function(m4, r3, g2, b3) {
    return r3 + r3 + g2 + g2 + b3 + b3;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex2);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16),
    1
  ] : null;
}
function hue2rgb(p2, q3, t4) {
  if (t4 < 0)
    t4 += 1;
  if (t4 > 1)
    t4 -= 1;
  if (t4 < 1 / 6)
    return p2 + (q3 - p2) * 6 * t4;
  if (t4 < 1 / 2)
    return q3;
  if (t4 < 2 / 3)
    return p2 + (q3 - p2) * (2 / 3 - t4) * 6;
  return p2;
}
function hslaToRgb(h4, s5, l2, a4) {
  var r3, g2, b3, q3, p2;
  if (s5 === 0) {
    r3 = g2 = b3 = l2;
  } else {
    q3 = l2 < 0.5 ? l2 * (1 + s5) : l2 + s5 - l2 * s5;
    p2 = 2 * l2 - q3;
    r3 = hue2rgb(p2, q3, h4 + 1 / 3);
    g2 = hue2rgb(p2, q3, h4);
    b3 = hue2rgb(p2, q3, h4 - 1 / 3);
  }
  return [Math.round(r3 * 255), Math.round(g2 * 255), Math.round(b3 * 255), a4];
}
var destroy = function() {
  this.onResize("removeListeners");
  this.onScroll("removeListeners");
  this.clear();
};
var eventPolyfill = function() {
  if (typeof window.CustomEvent === "function")
    return;
  function CustomEvent2(event, params) {
    params = params || { bubbles: false, cancelable: false, detail: void 0 };
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }
  CustomEvent2.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent2;
};
var getColor = function(gradientColor) {
  if (typeof gradientColor === "string") {
    return gradientColor;
  } else if (typeof gradientColor === "object" && gradientColor.color) {
    return gradientColor.color;
  } else {
    this.triggerError("gradient.color");
  }
};
var getColorDiff = function(colorA, colorB) {
  var i3 = 0;
  var colorDiff = [];
  for (i3; i3 < 4; i3++) {
    colorDiff.push(colorB[i3] - colorA[i3]);
  }
  return colorDiff;
};
var getColorPos = function(gradientColor, i3) {
  if (typeof gradientColor === "object" && gradientColor.pos) {
    return gradientColor.pos;
  } else {
    return parseFloat(!i3 ? 0 : (1 / (this.gradientLength - 1) * i3).toFixed(2));
  }
};
var getColorPosDiff = function(posA, posB) {
  return posB - posA;
};
var getCurrentColors = function() {
  var i3, j2;
  var currentColors = [];
  for (i3 = 0; i3 < this.currentColors.length; i3++) {
    currentColors.push([]);
    for (j2 = 0; j2 < 4; j2++) {
      currentColors[i3].push(this.currentColors[i3][j2]);
    }
  }
  return currentColors;
};
var getCurrentColorsPos = function() {
  var currentColorsPos = [], i3;
  for (i3 = 0; i3 < this.currentColorsPos.length; i3++) {
    currentColorsPos.push(this.currentColorsPos[i3]);
  }
  return currentColorsPos;
};
var getDimensions = function() {
  this.x1 = this.canvas.offsetWidth;
  this.y1 = this.canvas.offsetHeight;
};
var getElement = function(element) {
  if (element instanceof HTMLCanvasElement) {
    this.canvas = element;
  } else if (typeof element === "string") {
    this.canvas = document.querySelector(element);
  } else {
    throw new Error("The element you used is neither a String, nor a HTMLCanvasElement");
  }
  if (!this.canvas) {
    throw new Error("`" + element + "` could not be found in the DOM");
  }
};
var getLightness = function() {
  var currentColors = this.getCurrentColors();
  var gradientAverage = null;
  var lightnessAverage, i3;
  var colorsAverage = currentColors.map(function(el2) {
    return Math.max(el2[0], el2[1], el2[2]);
  });
  for (i3 = 0; i3 < colorsAverage.length; i3++) {
    gradientAverage = gradientAverage === null ? colorsAverage[i3] : gradientAverage + colorsAverage[i3];
    if (i3 === colorsAverage.length - 1) {
      lightnessAverage = Math.round(gradientAverage / (i3 + 1));
    }
  }
  return lightnessAverage >= 128 ? "light" : "dark";
};
var makeGradient = function() {
  var gradient = this.setDirection();
  var elToSetClassOnClass = document.querySelector(this.elToSetClassOn).classList;
  var i3 = 0;
  this.context.clearRect(0, 0, this.x1, this.y1);
  if (this.image) {
    this.context.drawImage(
      this.imageNode,
      this.imagePosition.x,
      this.imagePosition.y,
      this.imagePosition.width,
      this.imagePosition.height
    );
  }
  for (i3; i3 < this.currentColors.length; i3++) {
    gradient.addColorStop(
      this.currentColorsPos[i3],
      "rgba(" + this.currentColors[i3][0] + ", " + this.currentColors[i3][1] + ", " + this.currentColors[i3][2] + ", " + this.currentColors[i3][3] + ")"
    );
  }
  if (this.name) {
    if (this.getLightness() === "light") {
      elToSetClassOnClass.remove(this.name + "-dark");
      elToSetClassOnClass.add(this.name + "-light");
    } else {
      elToSetClassOnClass.remove(this.name + "-light");
      elToSetClassOnClass.add(this.name + "-dark");
    }
  }
  this.context.fillStyle = gradient;
  this.context.fillRect(0, 0, this.x1, this.y1);
};
var onResize = function(type) {
  if (type === "removeListeners") {
    window.removeEventListener("resize", this.setSizeAttributesNameSpace);
    return;
  }
  window.addEventListener("resize", this.setSizeAttributesNameSpace);
};
var onScroll = function(type) {
  if (type === "removeListeners") {
    window.removeEventListener("scroll", this.pauseWhenNotInViewNameSpace);
    return;
  }
  window.addEventListener("scroll", this.pauseWhenNotInViewNameSpace);
  this.pauseWhenNotInViewNameSpace();
};
var pause$1 = function(state) {
  var isPausedBecauseNotInView = state === "isPausedBecauseNotInView";
  if (this.isCleared)
    return;
  if (!isPausedBecauseNotInView)
    this.isPaused = true;
  cancelAnimationFrame(this.animation);
  this.animating = false;
};
var pauseWhenNotInView = function() {
  var _this = this;
  if (this.scrollDebounceTimeout)
    clearTimeout(this.scrollDebounceTimeout);
  this.scrollDebounceTimeout = setTimeout(function() {
    var elPos = _this.canvas.getBoundingClientRect();
    _this.isCanvasInWindowView = !(elPos.bottom < 0 || elPos.right < 0 || elPos.left > window.innerWidth || elPos.top > window.innerHeight);
    if (_this.isCanvasInWindowView) {
      if (!_this.isPaused || _this.firstScrollInit) {
        if (_this.image && !_this.isImgLoaded) {
          return;
        }
        _this.isPausedBecauseNotInView = false;
        _this.play("isPlayedBecauseInView");
        _this.firstScrollInit = false;
      }
    } else {
      if (!_this.image && _this.firstScrollInit) {
        _this.refreshColorsAndPos();
        _this.firstScrollInit = false;
      }
      if (!_this.isPaused && !_this.isPausedBecauseNotInView) {
        _this.isPausedBecauseNotInView = true;
        _this.pause("isPausedBecauseNotInView");
      }
    }
  }, this.scrollDebounceThreshold);
};
var play$1 = function(state) {
  var isPlayedBecauseInView = state === "isPlayedBecauseInView";
  if (!isPlayedBecauseInView)
    this.isPaused = false;
  this.isCleared = false;
  if (!this.animating) {
    this.animation = requestAnimationFrame(this.animateColors.bind(this));
    this.animating = true;
  }
};
var prepareImage = function() {
  var _this = this;
  if (!this.imagePosition) {
    this.imagePosition = { x: 0, y: 0, width: 0, height: 0 };
  }
  if (this.image.blendingMode) {
    this.context.globalCompositeOperation = this.image.blendingMode;
  }
  if (this.imageNode) {
    setImagePosition();
    return;
  }
  this.imageNode = new Image();
  this.imageNode.onerror = function() {
    throw new Error("Granim: The image source is invalid.");
  };
  this.imageNode.onload = function() {
    _this.imgOriginalWidth = _this.imageNode.width;
    _this.imgOriginalHeight = _this.imageNode.height;
    setImagePosition();
    _this.refreshColorsAndPos();
    if (!_this.isPausedWhenNotInView || _this.isCanvasInWindowView) {
      _this.animation = requestAnimationFrame(_this.animateColors.bind(_this));
    }
    _this.isImgLoaded = true;
  };
  this.imageNode.src = this.image.source;
  function setImagePosition() {
    var i3, currentAxis;
    for (i3 = 0; i3 < 2; i3++) {
      currentAxis = !i3 ? "x" : "y";
      setImageAxisPosition(currentAxis);
    }
    function setImageAxisPosition(axis) {
      var canvasWidthOrHeight = _this[axis + "1"];
      var imgOriginalWidthOrHeight = _this[axis === "x" ? "imgOriginalWidth" : "imgOriginalHeight"];
      var imageAlignIndex = axis === "x" ? _this.image.position[0] : _this.image.position[1];
      var imageAxisPosition;
      switch (imageAlignIndex) {
        case "center":
          imageAxisPosition = imgOriginalWidthOrHeight > canvasWidthOrHeight ? -(imgOriginalWidthOrHeight - canvasWidthOrHeight) / 2 : (canvasWidthOrHeight - imgOriginalWidthOrHeight) / 2;
          _this.imagePosition[axis] = imageAxisPosition;
          _this.imagePosition[axis === "x" ? "width" : "height"] = imgOriginalWidthOrHeight;
          break;
        case "top":
          _this.imagePosition["y"] = 0;
          _this.imagePosition["height"] = imgOriginalWidthOrHeight;
          break;
        case "bottom":
          _this.imagePosition["y"] = canvasWidthOrHeight - imgOriginalWidthOrHeight;
          _this.imagePosition["height"] = imgOriginalWidthOrHeight;
          break;
        case "right":
          _this.imagePosition["x"] = canvasWidthOrHeight - imgOriginalWidthOrHeight;
          _this.imagePosition["width"] = imgOriginalWidthOrHeight;
          break;
        case "left":
          _this.imagePosition["x"] = 0;
          _this.imagePosition["width"] = imgOriginalWidthOrHeight;
          break;
      }
      if (_this.image.stretchMode) {
        imageAlignIndex = axis === "x" ? _this.image.stretchMode[0] : _this.image.stretchMode[1];
        switch (imageAlignIndex) {
          case "none":
            break;
          case "stretch":
            _this.imagePosition[axis] = 0;
            _this.imagePosition[axis === "x" ? "width" : "height"] = canvasWidthOrHeight;
            break;
          case "stretch-if-bigger":
            if (imgOriginalWidthOrHeight < canvasWidthOrHeight)
              break;
            _this.imagePosition[axis] = 0;
            _this.imagePosition[axis === "x" ? "width" : "height"] = canvasWidthOrHeight;
            break;
          case "stretch-if-smaller":
            if (imgOriginalWidthOrHeight > canvasWidthOrHeight)
              break;
            _this.imagePosition[axis] = 0;
            _this.imagePosition[axis === "x" ? "width" : "height"] = canvasWidthOrHeight;
            break;
        }
      }
    }
  }
};
var refreshColorsAndPos = function(progressPercent) {
  var _this = this, activeChannel, activeChannelPos, i3, j2;
  for (i3 = 0; i3 < this.activeColors.length; i3++) {
    for (j2 = 0; j2 < 4; j2++) {
      activeChannel = _this.activeColors[i3][j2] + (j2 !== 3 ? Math.ceil(_this.activeColorsDiff[i3][j2] / 100 * progressPercent) : Math.round(_this.activeColorsDiff[i3][j2] / 100 * progressPercent * 100) / 100);
      if (activeChannel <= 255 && activeChannel >= 0) {
        _this.currentColors[i3][j2] = activeChannel;
      }
    }
    activeChannelPos = parseFloat((_this.activeColorsPos[i3] + _this.activeColorsPosDiff[i3] / 100 * progressPercent).toFixed(4));
    if (activeChannelPos <= 1 && activeChannelPos >= 0) {
      _this.currentColorsPos[i3] = activeChannelPos;
    }
  }
  this.makeGradient();
};
var setColors = function() {
  var _this = this, colorDiff, colorPosDiff, nextColors, nextColorsPos;
  if (!this.channels[this.activeState])
    this.channels[this.activeState] = [];
  if (this.channels[this.activeState][this.channelsIndex] !== void 0) {
    this.activeColors = this.channels[this.activeState][this.channelsIndex].colors;
    this.activeColorsDiff = this.channels[this.activeState][this.channelsIndex].colorsDiff;
    this.activeColorsPos = this.channels[this.activeState][this.channelsIndex].colorsPos;
    this.activeColorsPosDiff = this.channels[this.activeState][this.channelsIndex].colorsPosDiff;
    return;
  }
  this.channels[this.activeState].push([{}]);
  this.channels[this.activeState][this.channelsIndex].colors = [];
  this.channels[this.activeState][this.channelsIndex].colorsDiff = [];
  this.channels[this.activeState][this.channelsIndex].colorsPos = [];
  this.channels[this.activeState][this.channelsIndex].colorsPosDiff = [];
  this.activeColors = [];
  this.activeColorsDiff = [];
  this.activeColorsPos = [];
  this.activeColorsPosDiff = [];
  this.states[this.activeState].gradients[this.channelsIndex].forEach(function(color2, i3) {
    var colorPos = _this.getColorPos(color2, i3);
    var color2 = _this.getColor(color2);
    var rgbaColor = _this.convertColorToRgba(color2);
    var activeChannel = _this.channels[_this.activeState];
    activeChannel[_this.channelsIndex].colors.push(rgbaColor);
    _this.activeColors.push(rgbaColor);
    activeChannel[_this.channelsIndex].colorsPos.push(colorPos);
    _this.activeColorsPos.push(colorPos);
    if (!_this.isCurrentColorsSet) {
      _this.currentColors.push(_this.convertColorToRgba(color2));
      _this.currentColorsPos.push(colorPos);
    }
    if (_this.channelsIndex === _this.states[_this.activeState].gradients.length - 1) {
      colorDiff = _this.getColorDiff(
        activeChannel[_this.channelsIndex].colors[i3],
        activeChannel[0].colors[i3]
      );
      colorPosDiff = _this.getColorPosDiff(
        activeChannel[_this.channelsIndex].colorsPos[i3],
        activeChannel[0].colorsPos[i3]
      );
    } else {
      nextColors = _this.convertColorToRgba(_this.getColor(_this.states[_this.activeState].gradients[_this.channelsIndex + 1][i3]));
      nextColorsPos = _this.getColorPos(_this.states[_this.activeState].gradients[_this.channelsIndex + 1][i3], i3);
      colorDiff = _this.getColorDiff(activeChannel[_this.channelsIndex].colors[i3], nextColors);
      colorPosDiff = _this.getColorPosDiff(activeChannel[_this.channelsIndex].colorsPos[i3], nextColorsPos);
    }
    activeChannel[_this.channelsIndex].colorsDiff.push(colorDiff);
    _this.activeColorsDiff.push(colorDiff);
    activeChannel[_this.channelsIndex].colorsPosDiff.push(colorPosDiff);
    _this.activeColorsPosDiff.push(colorPosDiff);
  });
  this.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5e3;
  this.isCurrentColorsSet = true;
};
var setDirection = function() {
  var ctx = this.context;
  switch (this.direction) {
    case "diagonal":
      return ctx.createLinearGradient(0, 0, this.x1, this.y1);
    case "left-right":
      return ctx.createLinearGradient(0, 0, this.x1, 0);
    case "top-bottom":
      return ctx.createLinearGradient(this.x1 / 2, 0, this.x1 / 2, this.y1);
    case "radial":
      return ctx.createRadialGradient(this.x1 / 2, this.y1 / 2, this.x1 / 2, this.x1 / 2, this.y1 / 2, 0);
    case "custom":
      return ctx.createLinearGradient(
        getCustomCoordinateInPixels(this.customDirection.x0, this.x1),
        getCustomCoordinateInPixels(this.customDirection.y0, this.y1),
        getCustomCoordinateInPixels(this.customDirection.x1, this.x1),
        getCustomCoordinateInPixels(this.customDirection.y1, this.y1)
      );
  }
};
function getCustomCoordinateInPixels(coordinate, size) {
  return coordinate.indexOf("%") > -1 ? size / 100 * parseInt(coordinate.split("%")[0], 10) : parseInt(coordinate.split("px")[0], 10);
}
var setSizeAttributes = function() {
  this.getDimensions();
  this.canvas.setAttribute("width", this.x1);
  this.canvas.setAttribute("height", this.y1);
  if (this.image)
    this.prepareImage();
  this.refreshColorsAndPos();
};
var triggerError = function(element) {
  var siteURL = "https://sarcadass.github.io/granim.js/api.html";
  throw new Error('Granim: Input error on "' + element + '" option.\nCheck the API ' + siteURL + ".");
};
var validateInput = function(inputType) {
  var xPositionValues = ["left", "center", "right"];
  var yPositionValues = ["top", "center", "bottom"];
  var stretchModeValues = ["none", "stretch", "stretch-if-smaller", "stretch-if-bigger"];
  var blendingModeValues = [
    "multiply",
    "screen",
    "normal",
    "overlay",
    "darken",
    "lighten",
    "lighter",
    "color-dodge",
    "color-burn",
    "hard-light",
    "soft-light",
    "difference",
    "exclusion",
    "hue",
    "saturation",
    "color",
    "luminosity"
  ];
  var directionValues = ["diagonal", "left-right", "top-bottom", "radial", "custom"];
  switch (inputType) {
    case "image":
      if (!Array.isArray(this.image.position) || this.image.position.length !== 2 || xPositionValues.indexOf(this.image.position[0]) === -1 || yPositionValues.indexOf(this.image.position[1]) === -1) {
        this.triggerError("image.position");
      }
      if (this.image.stretchMode) {
        if (!Array.isArray(this.image.stretchMode) || this.image.stretchMode.length !== 2 || stretchModeValues.indexOf(this.image.stretchMode[0]) === -1 || stretchModeValues.indexOf(this.image.stretchMode[1]) === -1) {
          this.triggerError("image.stretchMode");
        }
      }
      break;
    case "blendingMode":
      if (blendingModeValues.indexOf(this.image.blendingMode) === -1) {
        this.clear();
        this.triggerError("blendingMode");
      }
      break;
    case "direction":
      if (directionValues.indexOf(this.direction) === -1) {
        this.triggerError("direction");
      } else {
        if (this.direction === "custom") {
          if (!areDefinedInPixelsOrPercentage([
            this.customDirection.x0,
            this.customDirection.x1,
            this.customDirection.y0,
            this.customDirection.y1
          ])) {
            this.triggerError("customDirection");
          }
        }
      }
      break;
  }
};
function areDefinedInPixelsOrPercentage(array) {
  var definedInPixelsOrPercentage = true, i3 = 0, value;
  while (definedInPixelsOrPercentage && i3 < array.length) {
    value = array[i3];
    if (typeof value !== "string") {
      definedInPixelsOrPercentage = false;
    } else {
      var splittedValue = null;
      var unit = null;
      if (value.indexOf("px") !== -1)
        unit = "px";
      if (value.indexOf("%") !== -1)
        unit = "%";
      splittedValue = value.split(unit).filter(function(value2) {
        return value2.length > 0;
      });
      if (!unit || splittedValue.length > 2 || !splittedValue[0] || splittedValue[1] || !/^-?\d+\.?\d*$/.test(splittedValue[0])) {
        definedInPixelsOrPercentage = false;
      }
    }
    i3++;
  }
  return definedInPixelsOrPercentage;
}
function Granim$1(options) {
  this.getElement(options.element);
  this.x1 = 0;
  this.y1 = 0;
  this.name = options.name || false;
  this.elToSetClassOn = options.elToSetClassOn || "body";
  this.direction = options.direction || "diagonal";
  this.customDirection = options.customDirection || {};
  this.validateInput("direction");
  this.isPausedWhenNotInView = options.isPausedWhenNotInView || false;
  this.states = options.states;
  this.stateTransitionSpeed = options.stateTransitionSpeed || 1e3;
  this.previousTimeStamp = null;
  this.progress = 0;
  this.isPaused = false;
  this.isCleared = false;
  this.isPausedBecauseNotInView = false;
  this.context = this.canvas.getContext("2d");
  this.channels = {};
  this.channelsIndex = 0;
  this.activeState = options.defaultStateName || "default-state";
  this.isChangingState = false;
  this.currentColors = [];
  this.currentColorsPos = [];
  this.activetransitionSpeed = null;
  this.eventPolyfill();
  this.scrollDebounceThreshold = options.scrollDebounceThreshold || 300;
  this.scrollDebounceTimeout = null;
  this.isImgLoaded = false;
  this.isCanvasInWindowView = false;
  this.firstScrollInit = true;
  this.animating = false;
  this.gradientLength = this.states[this.activeState].gradients[0].length;
  if (options.image && options.image.source) {
    this.image = {
      source: options.image.source,
      position: options.image.position || ["center", "center"],
      stretchMode: options.image.stretchMode || false,
      blendingMode: options.image.blendingMode || false
    };
  }
  this.events = {
    start: new CustomEvent("granim:start"),
    end: new CustomEvent("granim:end"),
    gradientChange: function(details) {
      return new CustomEvent("granim:gradientChange", {
        detail: {
          isLooping: details.isLooping,
          colorsFrom: details.colorsFrom,
          colorsTo: details.colorsTo,
          activeState: details.activeState
        },
        bubbles: false,
        cancelable: false
      });
    }
  };
  this.callbacks = {
    onStart: typeof options.onStart === "function" ? options.onStart : false,
    onGradientChange: typeof options.onGradientChange === "function" ? options.onGradientChange : false,
    onEnd: typeof options.onEnd === "function" ? options.onEnd : false
  };
  this.getDimensions();
  this.canvas.setAttribute("width", this.x1);
  this.canvas.setAttribute("height", this.y1);
  this.setColors();
  if (this.image) {
    this.validateInput("image");
    this.prepareImage();
  }
  this.pauseWhenNotInViewNameSpace = this.pauseWhenNotInView.bind(this);
  this.setSizeAttributesNameSpace = this.setSizeAttributes.bind(this);
  this.onResize();
  if (this.isPausedWhenNotInView) {
    this.onScroll();
  } else {
    if (!this.image) {
      this.refreshColorsAndPos();
      this.animation = requestAnimationFrame(this.animateColors.bind(this));
      this.animating = true;
    }
  }
  if (this.callbacks.onStart)
    this.callbacks.onStart();
  this.canvas.dispatchEvent(this.events.start);
}
Granim$1.prototype.animateColors = animateColors;
Granim$1.prototype.changeBlendingMode = changeBlendingMode;
Granim$1.prototype.changeDirection = changeDirection;
Granim$1.prototype.changeState = changeState;
Granim$1.prototype.clear = clear$1;
Granim$1.prototype.convertColorToRgba = convertColorToRgba;
Granim$1.prototype.destroy = destroy;
Granim$1.prototype.eventPolyfill = eventPolyfill;
Granim$1.prototype.getColor = getColor;
Granim$1.prototype.getColorDiff = getColorDiff;
Granim$1.prototype.getColorPos = getColorPos;
Granim$1.prototype.getColorPosDiff = getColorPosDiff;
Granim$1.prototype.getCurrentColors = getCurrentColors;
Granim$1.prototype.getCurrentColorsPos = getCurrentColorsPos;
Granim$1.prototype.getDimensions = getDimensions;
Granim$1.prototype.getElement = getElement;
Granim$1.prototype.getLightness = getLightness;
Granim$1.prototype.makeGradient = makeGradient;
Granim$1.prototype.onResize = onResize;
Granim$1.prototype.onScroll = onScroll;
Granim$1.prototype.pause = pause$1;
Granim$1.prototype.pauseWhenNotInView = pauseWhenNotInView;
Granim$1.prototype.play = play$1;
Granim$1.prototype.prepareImage = prepareImage;
Granim$1.prototype.refreshColorsAndPos = refreshColorsAndPos;
Granim$1.prototype.setColors = setColors;
Granim$1.prototype.setDirection = setDirection;
Granim$1.prototype.setSizeAttributes = setSizeAttributes;
Granim$1.prototype.triggerError = triggerError;
Granim$1.prototype.validateInput = validateInput;
var Granim_1 = Granim$1;
var granim = Granim_1;
const Granim = /* @__PURE__ */ getDefaultExportFromCjs(granim);
const WallpaperGranim = ({ onDark }) => {
  const canvasRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const darkColor = ["#000428", "#004e92"];
    let granim2;
    if (canvasRef.current) {
      granim2 = new Granim({
        element: canvasRef.current,
        direction: "diagonal",
        states: {
          "default-state": {
            gradients: [
              ["#00d2ff", "#3a7bd5"],
              ["#4776E6", "#8E54E9"],
              darkColor,
              ["#FF512F", "#DD2476"],
              ["#fd746c", "#ff9068"],
              ["#6a3093", "#a044ff"],
              ["#76b852", "#8DC26F"],
              ["#005C97", "#363795"]
            ]
          }
        },
        onGradientChange: (e3) => {
          const isDark = compareSlices(e3.colorsTo, darkColor);
          if (onDark !== void 0) {
            onDark(isDark);
          }
        }
      });
    }
    return () => {
      if (granim2) {
        granim2.destroy();
      }
    };
  }, [onDark]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "canvas",
      {
        ref: canvasRef,
        className: "inset-0 h-screen w-screen fixed -z-50 brightness-50"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inset-0 bg-noise opacity-80 fixed h-screen w-screen contrast-200 brightness-200 -z-50" })
  ] });
};
function WallpaperSimultaneousCounter() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "bg-simultaneous-counter-composition-1930 bg-center bg-cover fixed -mt-5 -ml-5\n            w-screen-105 h-screen-105 blur-lg brightness-75 -z-50"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-noise opacity-80 fixed h-full w-full contrast-200 brightness-200 -z-50" })
  ] });
}
const detectDelay = 1e3;
const fadeOutDuration = 1500;
const shakeAnimation = {
  x: [0, -500, 500, -500, 500, 0],
  y: [0, 0, 0, 0, 0, 0]
};
function Auth() {
  const navigate = useNavigate();
  const [textLight, setTextLight] = reactExports.useState(false);
  const [inputValue, setInputValue] = reactExports.useState("");
  const [shake, setShake] = reactExports.useState(false);
  const [startFadeOut, setStartFadeOut] = reactExports.useState(false);
  const [startFadeIn, setStartFadeIn] = reactExports.useState(false);
  const detectPassword = reactExports.useCallback((shake2, password) => {
    setShake(false);
    login(password).then((r3) => {
      console.info("login is successful", r3.status, r3.data);
      if (password) {
        savePassAsHash(password);
      }
      setLoggedIn(true);
      setStartFadeOut(true);
      setTimeout(() => navigate("/chat"), fadeOutDuration);
    }).catch((e3) => {
      console.info("failed to login", e3);
      setShake(shake2);
      setInputValue("");
    });
  }, [navigate]);
  const handleSubmit = reactExports.useCallback((event) => {
    event.preventDefault();
    detectPassword(true, inputValue);
  }, [detectPassword, inputValue]);
  const onDark = reactExports.useCallback((isDark) => {
    setTextLight(isDark);
  }, []);
  reactExports.useEffect(() => {
    const t4 = setTimeout(
      () => detectPassword(false),
      detectDelay
    );
    return () => clearTimeout(t4);
  }, [detectPassword]);
  reactExports.useEffect(() => {
    setStartFadeIn(true);
  }, []);
  return (
    // fadeOutDuration is shorter than duration-2000 to avoid staying in a white page
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cx("transition-opacity duration-2000", startFadeOut ? "opacity-0" : "opacity-100"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cx("transition-opacity duration-300", startFadeIn ? "opacity-100" : "opacity-0"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WallpaperGranim, { onDark }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex h-screen w-screen flex-col items-center justify-center gap-14 overflow-hidden transition-colors",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cx(
              "select-none font-borel text-7xl md:text-8xl lg:text-9xl tracking-widest transition duration-5000",
              textLight ? "text-neutral-200" : "text-neutral-800"
            ), children: "Let's talk" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("form", { className: "w-96 max-w-3/4 mb-[25vh]", onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.input,
              {
                type: "password",
                inputMode: "url",
                id: "password",
                value: inputValue,
                autoComplete: "current-password",
                animate: shake ? shakeAnimation : {},
                transition: { stiffness: 300, damping: 30 },
                onChange: (e3) => {
                  setInputValue(e3.target.value);
                  setShake(false);
                },
                className: cx(
                  "appearance-none w-full h-16 rounded-lg outline-0 caret-transparent",
                  "text-6xl text-center tracking-widest bg-white backdrop-blur bg-opacity-10 transition duration-5000",
                  textLight ? "text-neutral-200" : "text-neutral-800"
                )
              }
            ) })
          ]
        }
      )
    ] }) })
  );
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o3) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$1(o3);
}
function _setPrototypeOf$1(o3, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$1(o3, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
    arr2[i3] = arr[i3];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function zeroPad(value) {
  var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var strValue = String(value);
  if (length === 0)
    return strValue;
  var match2 = strValue.match(/(.*?)([0-9]+)(.*)/);
  var prefix = match2 ? match2[1] : "";
  var suffix = match2 ? match2[3] : "";
  var strNo = match2 ? match2[2] : strValue;
  var paddedNo = strNo.length >= length ? strNo : (_toConsumableArray(Array(length)).map(function() {
    return "0";
  }).join("") + strNo).slice(length * -1);
  return "".concat(prefix).concat(paddedNo).concat(suffix);
}
var timeDeltaFormatOptionsDefaults = {
  daysInHours: false,
  zeroPadTime: 2
};
function calcTimeDelta(date) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$now = options.now, now = _options$now === void 0 ? Date.now : _options$now, _options$precision = options.precision, precision = _options$precision === void 0 ? 0 : _options$precision, controlled = options.controlled, _options$offsetTime = options.offsetTime, offsetTime = _options$offsetTime === void 0 ? 0 : _options$offsetTime, overtime = options.overtime;
  var startTimestamp;
  if (typeof date === "string") {
    startTimestamp = new Date(date).getTime();
  } else if (date instanceof Date) {
    startTimestamp = date.getTime();
  } else {
    startTimestamp = date;
  }
  if (!controlled) {
    startTimestamp += offsetTime;
  }
  var timeLeft = controlled ? startTimestamp : startTimestamp - now();
  var clampedPrecision = Math.min(20, Math.max(0, precision));
  var total = Math.round(parseFloat(((overtime ? timeLeft : Math.max(0, timeLeft)) / 1e3).toFixed(clampedPrecision)) * 1e3);
  var seconds = Math.abs(total) / 1e3;
  return {
    total,
    days: Math.floor(seconds / (3600 * 24)),
    hours: Math.floor(seconds / 3600 % 24),
    minutes: Math.floor(seconds / 60 % 60),
    seconds: Math.floor(seconds % 60),
    milliseconds: Number((seconds % 1 * 1e3).toFixed()),
    completed: total <= 0
  };
}
function formatTimeDelta(timeDelta, options) {
  var days = timeDelta.days, hours = timeDelta.hours, minutes = timeDelta.minutes, seconds = timeDelta.seconds;
  var _Object$assign = Object.assign(Object.assign({}, timeDeltaFormatOptionsDefaults), options), daysInHours = _Object$assign.daysInHours, zeroPadTime = _Object$assign.zeroPadTime, _Object$assign$zeroPa = _Object$assign.zeroPadDays, zeroPadDays = _Object$assign$zeroPa === void 0 ? zeroPadTime : _Object$assign$zeroPa;
  var zeroPadTimeLength = Math.min(2, zeroPadTime);
  var formattedHours = daysInHours ? zeroPad(hours + days * 24, zeroPadTime) : zeroPad(hours, zeroPadTimeLength);
  return {
    days: daysInHours ? "" : zeroPad(days, zeroPadDays),
    hours: formattedHours,
    minutes: zeroPad(minutes, zeroPadTimeLength),
    seconds: zeroPad(seconds, zeroPadTimeLength)
  };
}
var Countdown = function(_React$Component) {
  _inherits$1(Countdown2, _React$Component);
  var _super = _createSuper$1(Countdown2);
  function Countdown2() {
    var _this;
    _classCallCheck$1(this, Countdown2);
    _this = _super.apply(this, arguments);
    _this.state = {
      count: _this.props.count || 3
    };
    _this.startCountdown = function() {
      _this.interval = window.setInterval(function() {
        var count = _this.state.count - 1;
        if (count === 0) {
          _this.stopCountdown();
          _this.props.onComplete && _this.props.onComplete();
        } else {
          _this.setState(function(prevState) {
            return {
              count: prevState.count - 1
            };
          });
        }
      }, 1e3);
    };
    _this.stopCountdown = function() {
      clearInterval(_this.interval);
    };
    _this.addTime = function(seconds) {
      _this.stopCountdown();
      _this.setState(function(prevState) {
        return {
          count: prevState.count + seconds
        };
      }, _this.startCountdown);
    };
    return _this;
  }
  _createClass$1(Countdown2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startCountdown();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearInterval(this.interval);
    }
  }, {
    key: "render",
    value: function render() {
      return this.props.children ? reactExports.cloneElement(this.props.children, {
        count: this.state.count
      }) : null;
    }
  }]);
  return Countdown2;
}(reactExports.Component);
Countdown.propTypes = {
  count: propTypesExports.number,
  children: propTypesExports.element,
  onComplete: propTypesExports.func
};
var Countdown$1 = function(_React$Component) {
  _inherits$1(Countdown$12, _React$Component);
  var _super = _createSuper$1(Countdown$12);
  function Countdown$12(props) {
    var _this;
    _classCallCheck$1(this, Countdown$12);
    _this = _super.call(this, props);
    _this.mounted = false;
    _this.initialTimestamp = _this.calcOffsetStartTimestamp();
    _this.offsetStartTimestamp = _this.props.autoStart ? 0 : _this.initialTimestamp;
    _this.offsetTime = 0;
    _this.legacyMode = false;
    _this.legacyCountdownRef = reactExports.createRef();
    _this.tick = function() {
      var timeDelta2 = _this.calcTimeDelta();
      var callback = timeDelta2.completed && !_this.props.overtime ? void 0 : _this.props.onTick;
      _this.setTimeDeltaState(timeDelta2, void 0, callback);
    };
    _this.start = function() {
      if (_this.isStarted())
        return;
      var prevOffsetStartTimestamp = _this.offsetStartTimestamp;
      _this.offsetStartTimestamp = 0;
      _this.offsetTime += prevOffsetStartTimestamp ? _this.calcOffsetStartTimestamp() - prevOffsetStartTimestamp : 0;
      var timeDelta2 = _this.calcTimeDelta();
      _this.setTimeDeltaState(timeDelta2, "STARTED", _this.props.onStart);
      if (!_this.props.controlled && (!timeDelta2.completed || _this.props.overtime)) {
        _this.clearTimer();
        _this.interval = window.setInterval(_this.tick, _this.props.intervalDelay);
      }
    };
    _this.pause = function() {
      if (_this.isPaused())
        return;
      _this.clearTimer();
      _this.offsetStartTimestamp = _this.calcOffsetStartTimestamp();
      _this.setTimeDeltaState(_this.state.timeDelta, "PAUSED", _this.props.onPause);
    };
    _this.stop = function() {
      if (_this.isStopped())
        return;
      _this.clearTimer();
      _this.offsetStartTimestamp = _this.calcOffsetStartTimestamp();
      _this.offsetTime = _this.offsetStartTimestamp - _this.initialTimestamp;
      _this.setTimeDeltaState(_this.calcTimeDelta(), "STOPPED", _this.props.onStop);
    };
    _this.isStarted = function() {
      return _this.isStatus("STARTED");
    };
    _this.isPaused = function() {
      return _this.isStatus("PAUSED");
    };
    _this.isStopped = function() {
      return _this.isStatus("STOPPED");
    };
    _this.isCompleted = function() {
      return _this.isStatus("COMPLETED");
    };
    if (props.date) {
      var timeDelta = _this.calcTimeDelta();
      _this.state = {
        timeDelta,
        status: timeDelta.completed ? "COMPLETED" : "STOPPED"
      };
    } else {
      _this.legacyMode = true;
    }
    return _this;
  }
  _createClass$1(Countdown$12, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.legacyMode) {
        return;
      }
      this.mounted = true;
      if (this.props.onMount)
        this.props.onMount(this.calcTimeDelta());
      if (this.props.autoStart)
        this.start();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.legacyMode) {
        return;
      }
      if (this.props.date !== prevProps.date) {
        this.initialTimestamp = this.calcOffsetStartTimestamp();
        this.offsetStartTimestamp = this.initialTimestamp;
        this.offsetTime = 0;
        this.setTimeDeltaState(this.calcTimeDelta());
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.legacyMode) {
        return;
      }
      this.mounted = false;
      this.clearTimer();
    }
  }, {
    key: "calcTimeDelta",
    value: function calcTimeDelta$1() {
      var _this$props = this.props, date = _this$props.date, now = _this$props.now, precision = _this$props.precision, controlled = _this$props.controlled, overtime = _this$props.overtime;
      return calcTimeDelta(date, {
        now,
        precision,
        controlled,
        offsetTime: this.offsetTime,
        overtime
      });
    }
  }, {
    key: "calcOffsetStartTimestamp",
    value: function calcOffsetStartTimestamp() {
      return Date.now();
    }
  }, {
    key: "addTime",
    value: function addTime(seconds) {
      this.legacyCountdownRef.current.addTime(seconds);
    }
  }, {
    key: "clearTimer",
    value: function clearTimer() {
      window.clearInterval(this.interval);
    }
  }, {
    key: "isStatus",
    value: function isStatus(status) {
      return this.state.status === status;
    }
  }, {
    key: "setTimeDeltaState",
    value: function setTimeDeltaState(timeDelta, status, callback) {
      var _this2 = this;
      if (!this.mounted)
        return;
      var completing = timeDelta.completed && !this.state.timeDelta.completed;
      var completedOnStart = timeDelta.completed && status === "STARTED";
      if (completing && !this.props.overtime) {
        this.clearTimer();
      }
      var onDone = function onDone2() {
        if (callback)
          callback(_this2.state.timeDelta);
        if (_this2.props.onComplete && (completing || completedOnStart)) {
          _this2.props.onComplete(timeDelta, completedOnStart);
        }
      };
      return this.setState(function(prevState) {
        var newStatus = status || prevState.status;
        if (timeDelta.completed && !_this2.props.overtime) {
          newStatus = "COMPLETED";
        } else if (!status && newStatus === "COMPLETED") {
          newStatus = "STOPPED";
        }
        return {
          timeDelta,
          status: newStatus
        };
      }, onDone);
    }
  }, {
    key: "getApi",
    value: function getApi() {
      return this.api = this.api || {
        start: this.start,
        pause: this.pause,
        stop: this.stop,
        isStarted: this.isStarted,
        isPaused: this.isPaused,
        isStopped: this.isStopped,
        isCompleted: this.isCompleted
      };
    }
  }, {
    key: "getRenderProps",
    value: function getRenderProps() {
      var _this$props2 = this.props, daysInHours = _this$props2.daysInHours, zeroPadTime = _this$props2.zeroPadTime, zeroPadDays = _this$props2.zeroPadDays;
      var timeDelta = this.state.timeDelta;
      return Object.assign(Object.assign({}, timeDelta), {
        api: this.getApi(),
        props: this.props,
        formatted: formatTimeDelta(timeDelta, {
          daysInHours,
          zeroPadTime,
          zeroPadDays
        })
      });
    }
  }, {
    key: "render",
    value: function render() {
      if (this.legacyMode) {
        var _this$props3 = this.props, count = _this$props3.count, _children = _this$props3.children, onComplete = _this$props3.onComplete;
        return reactExports.createElement(Countdown, {
          ref: this.legacyCountdownRef,
          count,
          onComplete
        }, _children);
      }
      var _this$props4 = this.props, className = _this$props4.className, overtime = _this$props4.overtime, children = _this$props4.children, renderer = _this$props4.renderer;
      var renderProps = this.getRenderProps();
      if (renderer) {
        return renderer(renderProps);
      }
      if (children && this.state.timeDelta.completed && !overtime) {
        return reactExports.cloneElement(children, {
          countdown: renderProps
        });
      }
      var _renderProps$formatte = renderProps.formatted, days = _renderProps$formatte.days, hours = _renderProps$formatte.hours, minutes = _renderProps$formatte.minutes, seconds = _renderProps$formatte.seconds;
      return reactExports.createElement("span", {
        className
      }, renderProps.total < 0 ? "-" : "", days, days ? ":" : "", hours, ":", minutes, ":", seconds);
    }
  }]);
  return Countdown$12;
}(reactExports.Component);
Countdown$1.defaultProps = Object.assign(Object.assign({}, timeDeltaFormatOptionsDefaults), {
  controlled: false,
  intervalDelay: 1e3,
  precision: 0,
  autoStart: true
});
Countdown$1.propTypes = {
  date: propTypesExports.oneOfType([propTypesExports.instanceOf(Date), propTypesExports.string, propTypesExports.number]),
  daysInHours: propTypesExports.bool,
  zeroPadTime: propTypesExports.number,
  zeroPadDays: propTypesExports.number,
  controlled: propTypesExports.bool,
  intervalDelay: propTypesExports.number,
  precision: propTypesExports.number,
  autoStart: propTypesExports.bool,
  overtime: propTypesExports.bool,
  className: propTypesExports.string,
  children: propTypesExports.element,
  renderer: propTypesExports.func,
  now: propTypesExports.func,
  onMount: propTypesExports.func,
  onStart: propTypesExports.func,
  onPause: propTypesExports.func,
  onStop: propTypesExports.func,
  onTick: propTypesExports.func,
  onComplete: propTypesExports.func
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t4) {
    for (var s5, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s5 = arguments[i3];
      for (var p2 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p2))
          t4[p2] = s5[p2];
    }
    return t4;
  };
  return __assign$1.apply(this, arguments);
};
var __rest$1 = globalThis && globalThis.__rest || function(s5, e3) {
  var t4 = {};
  for (var p2 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p2) && e3.indexOf(p2) < 0)
      t4[p2] = s5[p2];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s5); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p2[i3]))
        t4[p2[i3]] = s5[p2[i3]];
    }
  return t4;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i3) {
    return React.createElement(node.tag, __assign$1({
      key: i3
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React.createElement(IconBase, __assign$1({
      attr: __assign$1({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest$1(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign$1({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign$1(__assign$1({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function BsBootstrapReboot(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M1.161 8a6.84 6.84 0 1 0 6.842-6.84.58.58 0 1 1 0-1.16 8 8 0 1 1-6.556 3.412l-.663-.577a.58.58 0 0 1 .227-.997l2.52-.69a.58.58 0 0 1 .728.633l-.332 2.592a.58.58 0 0 1-.956.364l-.643-.56A6.812 6.812 0 0 0 1.16 8z" } }, { "tag": "path", "attr": { "d": "M6.641 11.671V8.843h1.57l1.498 2.828h1.314L9.377 8.665c.897-.3 1.427-1.106 1.427-2.1 0-1.37-.943-2.246-2.456-2.246H5.5v7.352h1.141zm0-3.75V5.277h1.57c.881 0 1.416.499 1.416 1.32 0 .84-.504 1.324-1.386 1.324h-1.6z" } }] })(props);
}
function BsEmojiExpressionless(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" } }, { "tag": "path", "attr": { "d": "M4 10.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5zm5 0a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5z" } }] })(props);
}
function BsSoundwave(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M8.5 2a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5zm-2 2a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm-6 1.5A.5.5 0 0 1 5 6v4a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm8 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm-10 1A.5.5 0 0 1 3 7v2a.5.5 0 0 1-1 0V7a.5.5 0 0 1 .5-.5zm12 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0V7a.5.5 0 0 1 .5-.5z" } }] })(props);
}
function BsTrash3(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5ZM11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H2.506a.58.58 0 0 0-.01 0H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1h-.995a.59.59 0 0 0-.01 0H11Zm1.958 1-.846 10.58a1 1 0 0 1-.997.92h-6.23a1 1 0 0 1-.997-.92L3.042 3.5h9.916Zm-7.487 1a.5.5 0 0 1 .528.47l.5 8.5a.5.5 0 0 1-.998.06L5 5.03a.5.5 0 0 1 .47-.53Zm5.058 0a.5.5 0 0 1 .47.53l-.5 8.5a.5.5 0 1 1-.998-.06l.5-8.5a.5.5 0 0 1 .528-.47ZM8 4.5a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-1 0V5a.5.5 0 0 1 .5-.5Z" } }] })(props);
}
const CountDownButton = ({
  text,
  countDownMs,
  icon,
  color: color2,
  action
}) => {
  const [holding, setHolding] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cx(
        "cursor-pointer flex items-center bg-white bg-opacity-60 rounded-lg gap-1 px-2 py-0.5",
        "hover:text-neutral-100 hover:border-transparent transition duration-300 border select-none",
        color2 === "red" && "border-red-600 text-red-600 hover:bg-red-600",
        color2 === "blue" && "border-blue-600 text-blue-600 hover:bg-blue-600",
        color2 === "black" && "border-black text-black hover:bg-black",
        holding && "scale-110"
      ),
      onMouseDown: (e3) => {
        if (e3.button === 0) {
          setHolding(true);
        }
      },
      onMouseUp: () => setHolding(false),
      onMouseLeave: () => setHolding(false),
      onContextMenu: (e3) => {
        e3.preventDefault();
        setHolding(false);
      },
      children: [
        icon,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transform", children: holding && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Countdown$1,
            {
              date: Date.now() + countDownMs,
              onComplete: () => {
                setHolding(false);
                if (action) {
                  action();
                }
              },
              intervalDelay: 0,
              precision: 1,
              autoStart: true,
              renderer: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  className: "whitespace-nowrap text-center font-light",
                  children: props.total / 1e3
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cx("whitespace-nowrap text-center font-light", holding && "opacity-0"), children: text })
        ] })
      ]
    }
  );
};
const ResetButton = ({ countDownMs = 2e3 }) => {
  const navigate = useNavigate();
  const reset = reactExports.useCallback(() => {
    audioDb.clear(() => {
    }).catch(
      (e3) => {
        console.error("failed to clear audio blobs:", e3);
      }
    ).finally(
      () => {
        resetAppState();
        console.info("reset");
        navigate("/");
      }
    );
  }, [navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CountDownButton,
    {
      text: "Reset Everything",
      countDownMs,
      color: "black",
      action: reset,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BsBootstrapReboot, { className: "text-lg" })
    }
  );
};
function IoRefreshSharp(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "fill": "none", "strokeLinecap": "square", "strokeMiterlimit": "10", "strokeWidth": "32", "d": "M320 146s24.36-12-64-12a160 160 0 10160 160" } }, { "tag": "path", "attr": { "fill": "none", "strokeLinecap": "square", "strokeMiterlimit": "10", "strokeWidth": "32", "d": "M256 58l80 80-80 80" } }] })(props);
}
function Error$1() {
  const [textLight, setTextLight] = reactExports.useState(false);
  const navigate = useNavigate();
  const location = useLocation();
  const error = useRouteError();
  const onDark = reactExports.useCallback((isDark) => {
    setTextLight(isDark);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-screen w-screen flex-col items-center justify-around gap-3 p-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WallpaperGranim, { onDark }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "w-[50%] max-h-[60%] flex flex-col items-center justify-center gap-5 rounded-xl py-3 px-5\n                bg-white bg-opacity-20 backdrop-blur",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cx(
            "flex flex-col gap-2 text-xl transition duration-5000",
            textLight ? "text-neutral-200" : "text-neutral-800"
          ), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: "We're sorry that something went wrong." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: "Here is something you can try to fix it." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: "Try them one by one until back to normal." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CountDownButton,
            {
              text: "Refresh",
              countDownMs: 0,
              color: "blue",
              action: () => navigate(location.pathname, { replace: true }),
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IoRefreshSharp, { className: "text-lg" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CountDownButton,
            {
              text: "Clear Messages of Current Chat",
              countDownMs: 1e3,
              color: "red",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BsTrash3, { className: "text-lg" }),
              action: () => {
                const chat = appState.chats[appState.currentChatId];
                if (chat) {
                  chat.messages = [];
                }
                navigate("/", { replace: true });
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CountDownButton,
            {
              text: "Clear All Chats",
              countDownMs: 1e3,
              color: "red",
              icon: void 0,
              action: () => {
                clearChats();
                navigate("/", { replace: true });
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CountDownButton,
            {
              text: "Clear Settings (Keep All Chats)",
              countDownMs: 1e3,
              color: "red",
              icon: void 0,
              action: () => {
                clearSettings();
                navigate("/", { replace: true });
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ResetButton, { countDownMs: 2e3 })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cx(
      "relative flex w-full max-h-[50%] flex-col gap-2 overflow-auto text-black ",
      "backdrop-blur-sm border-2 border-neutral-800 rounded-xl border-dashed p-2",
      "scrollbar-visible-neutral-300"
    ), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 whitespace-pre-line", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-[#AA2C2C] brightness-75", children: "Version" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: "Not Available" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 whitespace-pre-line", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-[#AA2C2C] brightness-75", children: "Status" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "", children: [
          (error == null ? void 0 : error["statusCode"]) ?? "None",
          " ",
          (error == null ? void 0 : error["statusText"]) ?? ""
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 whitespace-pre-line", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-[#AA2C2C] brightness-75", children: "Error Message" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: (error == null ? void 0 : error["message"]) ?? "None" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 whitespace-pre-line", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-[#AA2C2C] brightness-75", children: "Stack trace" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: (error == null ? void 0 : error["stack"]) ?? "None" })
      ] }),
      (error == null ? void 0 : error["stack"]) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "https://github.com/proxoar/talk/issues/new?assignees=&labels=&projects=&template=bug_report.md&title=",
          target: "_blank",
          className: "sticky self-end right-0 bottom-0  border-neutral-800 border-dashed rounded-xl\n                       px-2 py-1 text-neutral-300 opacity-80 hover:opacity-100 hover:text-neutral-100 transition duration-300",
          children: " Report this on GitHub"
        }
      )
    ] })
  ] });
}
function e$3(e3, t4, s5, i3) {
  return new (s5 || (s5 = Promise))(function(r3, n2) {
    function o3(e4) {
      try {
        c3(i3.next(e4));
      } catch (e5) {
        n2(e5);
      }
    }
    function a4(e4) {
      try {
        c3(i3.throw(e4));
      } catch (e5) {
        n2(e5);
      }
    }
    function c3(e4) {
      var t5;
      e4.done ? r3(e4.value) : (t5 = e4.value, t5 instanceof s5 ? t5 : new s5(function(e5) {
        e5(t5);
      })).then(o3, a4);
    }
    c3((i3 = i3.apply(e3, t4 || [])).next());
  });
}
"function" == typeof SuppressedError && SuppressedError;
let t$4 = class t2 {
  constructor() {
    this.listeners = {};
  }
  on(e3, t4) {
    return this.listeners[e3] || (this.listeners[e3] = /* @__PURE__ */ new Set()), this.listeners[e3].add(t4), () => this.un(e3, t4);
  }
  once(e3, t4) {
    const s5 = this.on(e3, t4), i3 = this.on(e3, () => {
      s5(), i3();
    });
    return s5;
  }
  un(e3, t4) {
    this.listeners[e3] && (t4 ? this.listeners[e3].delete(t4) : delete this.listeners[e3]);
  }
  unAll() {
    this.listeners = {};
  }
  emit(e3, ...t4) {
    this.listeners[e3] && this.listeners[e3].forEach((e4) => e4(...t4));
  }
};
let s$6 = class s3 extends t$4 {
  constructor(e3) {
    super(), this.subscriptions = [], this.options = e3;
  }
  onInit() {
  }
  init(e3) {
    this.wavesurfer = e3, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((e3) => e3());
  }
};
const i$5 = ["audio/webm", "audio/wav", "audio/mpeg", "audio/mp4", "audio/mp3"];
let r$3 = class r extends s$6 {
  constructor(e3) {
    var t4;
    super(Object.assign(Object.assign({}, e3), { audioBitsPerSecond: null !== (t4 = e3.audioBitsPerSecond) && void 0 !== t4 ? t4 : 128e3 })), this.stream = null, this.mediaRecorder = null;
  }
  static create(e3) {
    return new r(e3 || {});
  }
  renderMicStream(e3) {
    const t4 = new AudioContext(), s5 = t4.createMediaStreamSource(e3), i3 = t4.createAnalyser();
    s5.connect(i3);
    const r3 = i3.frequencyBinCount, n2 = new Float32Array(r3), o3 = r3 / t4.sampleRate;
    let a4;
    const c3 = () => {
      i3.getFloatTimeDomainData(n2), this.wavesurfer && (this.wavesurfer.options.cursorWidth = 0, this.wavesurfer.options.interact = false, this.wavesurfer.load("", [n2], o3)), a4 = requestAnimationFrame(c3);
    };
    return c3(), () => {
      cancelAnimationFrame(a4), null == s5 || s5.disconnect(), null == t4 || t4.close();
    };
  }
  startMic() {
    return e$3(this, void 0, void 0, function* () {
      let e3;
      try {
        e3 = yield navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e4) {
        throw new Error("Error accessing the microphone: " + e4.message);
      }
      const t4 = this.renderMicStream(e3);
      return this.subscriptions.push(this.once("destroy", t4)), this.stream = e3, e3;
    });
  }
  stopMic() {
    this.stream && (this.stream.getTracks().forEach((e3) => e3.stop()), this.stream = null);
  }
  startRecording() {
    return e$3(this, void 0, void 0, function* () {
      const e3 = this.stream || (yield this.startMic()), t4 = this.mediaRecorder || new MediaRecorder(e3, { mimeType: this.options.mimeType || i$5.find((e4) => MediaRecorder.isTypeSupported(e4)), audioBitsPerSecond: this.options.audioBitsPerSecond });
      this.mediaRecorder = t4, this.stopRecording();
      const s5 = [];
      t4.ondataavailable = (e4) => {
        e4.data.size > 0 && s5.push(e4.data);
      }, t4.onstop = () => {
        var e4;
        const i3 = new Blob(s5, { type: t4.mimeType });
        this.emit("record-end", i3), false !== this.options.renderRecordedAudio && (null === (e4 = this.wavesurfer) || void 0 === e4 || e4.load(URL.createObjectURL(i3)));
      }, t4.start(), this.emit("record-start");
    });
  }
  isRecording() {
    var e3;
    return "recording" === (null === (e3 = this.mediaRecorder) || void 0 === e3 ? void 0 : e3.state);
  }
  stopRecording() {
    var e3;
    this.isRecording() && (null === (e3 = this.mediaRecorder) || void 0 === e3 || e3.stop());
  }
  destroy() {
    super.destroy(), this.stopRecording(), this.stopMic();
  }
};
class EnhancedRecorder {
  constructor(stopMicToo, recordingMimeType) {
    __publicField(this, "r");
    /**
     *  Considerations for ceasing microphone use post-recording
     *
     * In the majority of browsers, a red microphone symbol is displayed as recording commences.
     * Typically, this symbol remains red even after the RecordPlugin has ceased recording.
     * This standard browser behaviour can mislead users into believing that our website continues to access their microphone,
     * potentially causing undue worry.
     * To eliminate the red microphone symbol in browsers, invoke this.r.stopMic().
     *
     * Potential drawbacks of invoking stopMic():
     * 1. Certain browsers may prompt for microphone permission each time a recording begins.
     * 2. Initiating a new recording may be subject to a delay.
     **/
    __publicField(this, "stopMicToo");
    // todo cannot start RecordPlugin after calling stopMic once, RecordPlugin should be replaced
    /**
     * Callers should not access recodingStatus field. Callers can only be notified about recodingStatus in callbacks.
     * The reason is that recodingStatus does not reflect the real state RecordPlugin
     */
    __publicField(this, "recodingStatus");
    __publicField(this, "startedAt");
    /**
     * A context whose life cycle is just between the beginning and ending of a recording
     * Callers have full control to this context in its life cycle
     */
    __publicField(this, "context");
    __publicField(this, "startListeners");
    __publicField(this, "doneListeners");
    __publicField(this, "cancelListeners");
    this.recodingStatus = "init-idle";
    this.stopMicToo = stopMicToo;
    this.startListeners = [];
    this.doneListeners = [];
    this.cancelListeners = [];
    this.r = r$3.create({
      mimeType: recordingMimeType == null ? void 0 : recordingMimeType.mimeType,
      audioBitsPerSecond: 1e5
    });
    this.r.on("record-start", () => {
      var _a;
      switch (this.recodingStatus) {
        case "recording":
          this.startedAt = /* @__PURE__ */ new Date();
          (_a = this.startListeners) == null ? void 0 : _a.forEach((f2) => f2(this.context));
          break;
        case "init-idle":
        case "done":
        case "canceled":
          throw new Error("recorder has not started");
      }
    });
    this.r.on("record-end", (blob) => {
      switch (this.recodingStatus) {
        case "recording":
          throw new Error("recorder has not stopped");
        case "init-idle":
          throw new Error("recorder is at illegal state");
        case "done":
          this.doneListeners.forEach((f2) => f2(blob, this.currentRecordingDuration(), this.context));
          this.cleanUp();
          break;
        case "canceled":
          this.cancelListeners.forEach((f2) => f2(blob, this.currentRecordingDuration(), this.context));
          this.cleanUp();
          break;
      }
    });
  }
  cleanUp() {
    this.startedAt = void 0;
    this.context = void 0;
    if (this.stopMicToo) {
      this.r.stopMic();
    }
  }
  currentRecordingDuration() {
    if (this.startedAt) {
      return (/* @__PURE__ */ new Date()).getTime() - this.startedAt.getTime();
    } else {
      return 0;
    }
  }
  // todo delete me if not referred
  currentContext() {
    return this.context;
  }
  async start(context) {
    if (this.stopMicToo) {
      await this.r.startMic();
    }
    this.recodingStatus = "recording";
    this.context = context;
    return this.r.startRecording();
  }
  done() {
    this.recodingStatus = "done";
    this.r.stopRecording();
  }
  cancel() {
    this.recodingStatus = "canceled";
    this.r.stopRecording();
  }
  addStartListener(f2) {
    this.startListeners.push(f2);
  }
  addDoneListener(f2) {
    this.doneListeners.push(f2);
  }
  addCancelListener(f2) {
    this.cancelListeners.push(f2);
  }
  removeStartListener(f2) {
    this.startListeners = this.startListeners.filter((l2) => l2 !== f2);
  }
  removeDoneListener(f2) {
    this.doneListeners = this.doneListeners.filter((l2) => l2 !== f2);
  }
  removeCancelListener(f2) {
    this.cancelListeners = this.cancelListeners.filter((l2) => l2 !== f2);
  }
}
const controlState = proxy({
  isMouseLeftDown: false,
  player: {
    autoPlay: true,
    isPlaying: false,
    current: "",
    playList: []
  },
  recordingMimeType: chooseAudioMimeType(popularMimeTypes),
  recorder: ref(new EnhancedRecorder(false)),
  sendingMessages: ref([]),
  sendingMessageSignal: 0
});
const playerState = controlState.player;
const onPrevFinish = () => {
  if (!playerState.autoPlay || playerState.playList.length == 0) {
    playerState.isPlaying = false;
    playerState.current = "";
    return;
  }
  const [head] = playerState.playList.splice(0, 1);
  playerState.current = head;
  playerState.isPlaying = true;
};
const pause = () => {
  playerState.isPlaying = false;
};
const play = (audioId) => {
  if (playerState.current !== audioId) {
    playerState.playList = [];
  }
  playerState.current = audioId;
  playerState.isPlaying = true;
};
const clear = () => {
  playerState.isPlaying = false;
  playerState.current = "";
  playerState.playList = [];
};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter2 = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number2, start, end) {
        return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars2) {
        chars2 = chars2 === undefined$1 ? " " : baseToString(chars2);
        var charsLength = chars2.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars2, length) : chars2;
        }
        var result2 = baseRepeat(chars2, nativeCeil(length / stringSize(chars2)));
        return hasUnicode(chars2) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber(number2);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString3(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e3) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match2, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger2(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger2(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$1 ? length : toInteger2(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter3(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype2, properties) {
        var result2 = baseCreate(prototype2);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number2), lower, upper);
      }
      function inRange(number2, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber(number2);
        return baseInRange(number2, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string, target, position) {
        string = toString3(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars2) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars2) + string + createPadding(nativeCeil(mid), chars2);
      }
      function padEnd(string, length, chars2) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars2) : string;
      }
      function padStart(string, length, chars2) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars2) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        return baseRepeat(toString3(string), n2);
      }
      function replace() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString3(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString3(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string, chars2, guard) {
        string = toString3(string);
        if (string && (guard || chars2 === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars2 = baseToString(chars2))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars2), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars2, guard) {
        string = toString3(string);
        if (string && (guard || chars2 === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars2 = baseToString(chars2))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars2, guard) {
        string = toString3(string);
        if (string && (guard || chars2 === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars2 = baseToString(chars2))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars2));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e3) {
          return isError(e3) ? e3 : new Error2(e3);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger2(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger2(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter2;
        return toString3(prefix) + id2;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter3;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger2(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
function PiPlusLight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 256 256", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M222,128a6,6,0,0,1-6,6H134v82a6,6,0,0,1-12,0V134H40a6,6,0,0,1,0-12h82V40a6,6,0,0,1,12,0v82h82A6,6,0,0,1,222,128Z" } }] })(props);
}
function CiSearch(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.1", "id": "search", "x": "0px", "y": "0px", "viewBox": "0 0 24 24", "style": "enable-background:new 0 0 24 24;" }, "child": [{ "tag": "g", "attr": {}, "child": [{ "tag": "path", "attr": { "d": "M20.031,20.79c0.46,0.46,1.17-0.25,0.71-0.7l-3.75-3.76c1.27-1.41,2.04-3.27,2.04-5.31\n		c0-4.39-3.57-7.96-7.96-7.96s-7.96,3.57-7.96,7.96c0,4.39,3.57,7.96,7.96,7.96c1.98,0,3.81-0.73,5.21-1.94L20.031,20.79z\n		 M4.11,11.02c0-3.84,3.13-6.96,6.96-6.96c3.84,0,6.96,3.12,6.96,6.96c0,3.84-3.12,6.96-6.96,6.96C7.24,17.98,4.11,14.86,4.11,11.02\n		z" } }] }] })(props);
}
const spin = "";
const Spin = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: "animate-spin h-5 w-5 text-neutral-500",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: "opacity-25",
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "currentColor",
            strokeWidth: "4"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            className: "opacity-75",
            fill: "currentColor",
            d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          }
        )
      ]
    }
  ) });
};
const Preview = ({ chatSnap }) => {
  if (chatSnap.messages.length === 0) {
    return null;
  }
  const message = chatSnap.messages[chatSnap.messages.length - 1];
  const who = message.role == "user" ? "You" : "Assistant";
  let content = null;
  switch (message.status) {
    case "sending":
    case "thinking":
      content = /* @__PURE__ */ jsxRuntimeExports.jsx(Spin, {});
      break;
    case "sent":
    case "typing":
    case "received":
      if (message.audio) {
        content = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BsSoundwave, {}) });
      } else {
        content = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "truncate ... ", children: message.text });
      }
      break;
    case "error":
      content = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BsEmojiExpressionless, {}) });
      break;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
      who,
      ":"
    ] }),
    " ",
    content
  ] });
};
const ChatComponent = ({ chatSnap }) => {
  const appSnap = useSnapshot(appState);
  const controlSnap = useSnapshot(controlState);
  const [selected, setSelected] = reactExports.useState(false);
  const [over, setMouseOver] = reactExports.useState(false);
  const onContainerMouseDownOrUp = reactExports.useCallback(() => {
    appState.currentChatId = chatSnap.id;
  }, [chatSnap.id]);
  const onMouseEnter = reactExports.useCallback(() => {
    if (controlSnap.isMouseLeftDown) {
      appState.currentChatId = chatSnap.id;
    }
  }, [chatSnap.id, controlSnap.isMouseLeftDown]);
  const removeChat = reactExports.useCallback((e3) => {
    e3.stopPropagation();
    deleteChat(chatSnap.id);
  }, [chatSnap.id]);
  const onDeleteButtonMouseDownOrUp = reactExports.useCallback((e3) => {
    e3.stopPropagation();
  }, []);
  reactExports.useEffect(() => {
    setSelected(appSnap.currentChatId === chatSnap.id);
  }, [appSnap, chatSnap]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative flex gap-1 justify-between items-center",
      onMouseOver: () => setMouseOver(true),
      onMouseLeave: () => setMouseOver(false),
      onMouseDown: onContainerMouseDownOrUp,
      onMouseUp: onContainerMouseDownOrUp,
      onMouseEnter,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `w-full pl-3 pr-10 py-1 gap-y-0.5 flex-col h-14 font-medium text-neutral-800 rounded-lg 
                 transition-all duration-100 ${selected ? " bg-white bg-opacity-90" : "bg-white bg-opacity-40 hover:bg-neutral-100 hover:bg-opacity-70 "}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-auto break-keep", children: chatSnap.name }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-auto text-sm text-neutral-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Preview, { chatSnap }) }) })
            ]
          }
        ),
        over && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "absolute right-2 text-neutral-500 rounded-lg p-0.5 hover:text-neutral-100 hover:bg-neutral-500/[0.4]",
            onMouseDown: onDeleteButtonMouseDownOrUp,
            onMouseUp: onDeleteButtonMouseDownOrUp,
            onClick: removeChat,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                fill: "none",
                viewBox: "0 0 24 24",
                strokeWidth: 2,
                stroke: "currentColor",
                className: "w-6 h-6",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })
              }
            )
          }
        )
      ]
    }
  );
};
const ChatList = () => {
  const appSnap = useSnapshot(appState);
  const chatRef = reactExports.useRef(null);
  const newChat = reactExports.useCallback(() => {
    const optionClone = _.cloneDeep(appState.option);
    const chat = proxy({
      id: randomHash16Char(),
      name: randomHash16Char(),
      // name: "New Chat",
      messages: [],
      option: optionClone,
      inputText: ""
    });
    appState.chats[chat.id] = chat;
    appState.currentChatId = chat.id;
  }, []);
  reactExports.useEffect(() => {
    if (chatRef.current) {
      chatRef.current.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      });
    }
  }, [appSnap.currentChatId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full w-full flex-col gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "mr-auto flex w-full items-center justify-center gap-2 rounded-xl bg-white bg-opacity-40 backdrop-blur",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CiSearch, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-neutral-600 prose", children: "Search" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "flex justify-center items-center rounded-xl stroke-white text-neutral-500\n                 bg-white bg-opacity-80 backdrop-blur cursor-pointer",
          onClick: newChat,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PiPlusLight, { size: 24 })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "h-full w-full overflow-y-auto pr-1 scrollbar-hidden hover:scrollbar-visible",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex cursor-pointer flex-col gap-1",
            children: Object.entries(appSnap.chats).map(
              ([key, chatSnap]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ref: chatSnap.id === appSnap.currentChatId ? chatRef : void 0,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatComponent, { chatSnap })
                },
                key
              )
            )
          }
        )
      }
    )
  ] });
};
var i$4 = Object.defineProperty;
var d$3 = (t4, e3, n2) => e3 in t4 ? i$4(t4, e3, { enumerable: true, configurable: true, writable: true, value: n2 }) : t4[e3] = n2;
var r$2 = (t4, e3, n2) => (d$3(t4, typeof e3 != "symbol" ? e3 + "" : e3, n2), n2);
let o$5 = class o {
  constructor() {
    r$2(this, "current", this.detect());
    r$2(this, "handoffState", "pending");
    r$2(this, "currentId", 0);
  }
  set(e3) {
    this.current !== e3 && (this.handoffState = "pending", this.currentId = 0, this.current = e3);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
let s$5 = new o$5();
let l$3 = (e3, f2) => {
  s$5.isServer ? reactExports.useEffect(e3, f2) : reactExports.useLayoutEffect(e3, f2);
};
function s$4(e3) {
  let r3 = reactExports.useRef(e3);
  return l$3(() => {
    r3.current = e3;
  }, [e3]), r3;
}
function t$3(e3) {
  typeof queueMicrotask == "function" ? queueMicrotask(e3) : Promise.resolve().then(e3).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$4() {
  let n2 = [], r3 = { addEventListener(e3, t4, s5, a4) {
    return e3.addEventListener(t4, s5, a4), r3.add(() => e3.removeEventListener(t4, s5, a4));
  }, requestAnimationFrame(...e3) {
    let t4 = requestAnimationFrame(...e3);
    return r3.add(() => cancelAnimationFrame(t4));
  }, nextFrame(...e3) {
    return r3.requestAnimationFrame(() => r3.requestAnimationFrame(...e3));
  }, setTimeout(...e3) {
    let t4 = setTimeout(...e3);
    return r3.add(() => clearTimeout(t4));
  }, microTask(...e3) {
    let t4 = { current: true };
    return t$3(() => {
      t4.current && e3[0]();
    }), r3.add(() => {
      t4.current = false;
    });
  }, style(e3, t4, s5) {
    let a4 = e3.style.getPropertyValue(t4);
    return Object.assign(e3.style, { [t4]: s5 }), this.add(() => {
      Object.assign(e3.style, { [t4]: a4 });
    });
  }, group(e3) {
    let t4 = o$4();
    return e3(t4), this.add(() => t4.dispose());
  }, add(e3) {
    return n2.push(e3), () => {
      let t4 = n2.indexOf(e3);
      if (t4 >= 0)
        for (let s5 of n2.splice(t4, 1))
          s5();
    };
  }, dispose() {
    for (let e3 of n2.splice(0))
      e3();
  } };
  return r3;
}
function p$3() {
  let [e3] = reactExports.useState(o$4);
  return reactExports.useEffect(() => () => e3.dispose(), [e3]), e3;
}
let o$3 = function(t4) {
  let e3 = s$4(t4);
  return React.useCallback((...r3) => e3.current(...r3), [e3]);
};
function s$3() {
  let r3 = typeof document == "undefined";
  return "useSyncExternalStore" in e$6 ? ((o3) => o3.useSyncExternalStore)(e$6)(() => () => {
  }, () => false, () => !r3) : false;
}
function l$2() {
  let r3 = s$3(), [e3, n2] = reactExports.useState(s$5.isHandoffComplete);
  return e3 && s$5.isHandoffComplete === false && n2(false), reactExports.useEffect(() => {
    e3 !== true && n2(true);
  }, [e3]), reactExports.useEffect(() => s$5.handoff(), []), r3 ? false : e3;
}
var o$2;
let I$1 = (o$2 = React.useId) != null ? o$2 : function() {
  let n2 = l$2(), [e3, u3] = React.useState(n2 ? () => s$5.nextId() : null);
  return l$3(() => {
    e3 === null && u3(s$5.nextId());
  }, [e3]), e3 != null ? "" + e3 : void 0;
};
function u$3(r3, n2, ...a4) {
  if (r3 in n2) {
    let e3 = n2[r3];
    return typeof e3 == "function" ? e3(...a4) : e3;
  }
  let t4 = new Error(`Tried to handle "${r3}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e3) => `"${e3}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t4, u$3), t4;
}
function i$3(t4) {
  var n2;
  if (t4.type)
    return t4.type;
  let e3 = (n2 = t4.as) != null ? n2 : "button";
  if (typeof e3 == "string" && e3.toLowerCase() === "button")
    return "button";
}
function s$2(t4, e3) {
  let [n2, u3] = reactExports.useState(() => i$3(t4));
  return l$3(() => {
    u3(i$3(t4));
  }, [t4.type, t4.as]), l$3(() => {
    n2 || e3.current && e3.current instanceof HTMLButtonElement && !e3.current.hasAttribute("type") && u3("button");
  }, [n2, e3]), n2;
}
let u$2 = Symbol();
function y$3(...t4) {
  let n2 = reactExports.useRef(t4);
  reactExports.useEffect(() => {
    n2.current = t4;
  }, [t4]);
  let c3 = o$3((e3) => {
    for (let o3 of n2.current)
      o3 != null && (typeof o3 == "function" ? o3(e3) : o3.current = e3);
  });
  return t4.every((e3) => e3 == null || (e3 == null ? void 0 : e3[u$2])) ? void 0 : c3;
}
function t$2(...r3) {
  return Array.from(new Set(r3.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
var S$1 = ((a4) => (a4[a4.None = 0] = "None", a4[a4.RenderStrategy = 1] = "RenderStrategy", a4[a4.Static = 2] = "Static", a4))(S$1 || {}), j = ((e3) => (e3[e3.Unmount = 0] = "Unmount", e3[e3.Hidden = 1] = "Hidden", e3))(j || {});
function X2({ ourProps: r3, theirProps: t4, slot: e3, defaultTag: a4, features: s5, visible: n2 = true, name: f2 }) {
  let o3 = N(t4, r3);
  if (n2)
    return c$2(o3, e3, a4, f2);
  let u3 = s5 != null ? s5 : 0;
  if (u3 & 2) {
    let { static: l2 = false, ...p2 } = o3;
    if (l2)
      return c$2(p2, e3, a4, f2);
  }
  if (u3 & 1) {
    let { unmount: l2 = true, ...p2 } = o3;
    return u$3(l2 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return c$2({ ...p2, hidden: true, style: { display: "none" } }, e3, a4, f2);
    } });
  }
  return c$2(o3, e3, a4, f2);
}
function c$2(r3, t4 = {}, e3, a4) {
  let { as: s5 = e3, children: n2, refName: f2 = "ref", ...o3 } = g$1(r3, ["unmount", "static"]), u3 = r3.ref !== void 0 ? { [f2]: r3.ref } : {}, l2 = typeof n2 == "function" ? n2(t4) : n2;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(t4));
  let p2 = {};
  if (t4) {
    let i3 = false, m4 = [];
    for (let [y4, d4] of Object.entries(t4))
      typeof d4 == "boolean" && (i3 = true), d4 === true && m4.push(y4);
    i3 && (p2["data-headlessui-state"] = m4.join(" "));
  }
  if (s5 === reactExports.Fragment && Object.keys(R2(o3)).length > 0) {
    if (!reactExports.isValidElement(l2) || Array.isArray(l2) && l2.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a4} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o3).map((d4) => `  - ${d4}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d4) => `  - ${d4}`).join(`
`)].join(`
`));
    let i3 = l2.props, m4 = typeof (i3 == null ? void 0 : i3.className) == "function" ? (...d4) => t$2(i3 == null ? void 0 : i3.className(...d4), o3.className) : t$2(i3 == null ? void 0 : i3.className, o3.className), y4 = m4 ? { className: m4 } : {};
    return reactExports.cloneElement(l2, Object.assign({}, N(l2.props, R2(g$1(o3, ["ref"]))), p2, u3, w$1(l2.ref, u3.ref), y4));
  }
  return reactExports.createElement(s5, Object.assign({}, g$1(o3, ["ref"]), s5 !== reactExports.Fragment && u3, s5 !== reactExports.Fragment && p2), l2);
}
function w$1(...r3) {
  return { ref: r3.every((t4) => t4 == null) ? void 0 : (t4) => {
    for (let e3 of r3)
      e3 != null && (typeof e3 == "function" ? e3(t4) : e3.current = t4);
  } };
}
function N(...r3) {
  if (r3.length === 0)
    return {};
  if (r3.length === 1)
    return r3[0];
  let t4 = {}, e3 = {};
  for (let s5 of r3)
    for (let n2 in s5)
      n2.startsWith("on") && typeof s5[n2] == "function" ? (e3[n2] != null || (e3[n2] = []), e3[n2].push(s5[n2])) : t4[n2] = s5[n2];
  if (t4.disabled || t4["aria-disabled"])
    return Object.assign(t4, Object.fromEntries(Object.keys(e3).map((s5) => [s5, void 0])));
  for (let s5 in e3)
    Object.assign(t4, { [s5](n2, ...f2) {
      let o3 = e3[s5];
      for (let u3 of o3) {
        if ((n2 instanceof Event || (n2 == null ? void 0 : n2.nativeEvent) instanceof Event) && n2.defaultPrevented)
          return;
        u3(n2, ...f2);
      }
    } });
  return t4;
}
function D$1(r3) {
  var t4;
  return Object.assign(reactExports.forwardRef(r3), { displayName: (t4 = r3.displayName) != null ? t4 : r3.name });
}
function R2(r3) {
  let t4 = Object.assign({}, r3);
  for (let e3 in t4)
    t4[e3] === void 0 && delete t4[e3];
  return t4;
}
function g$1(r3, t4 = []) {
  let e3 = Object.assign({}, r3);
  for (let a4 of t4)
    a4 in e3 && delete e3[a4];
  return e3;
}
function r$1(n2) {
  let e3 = n2.parentElement, l2 = null;
  for (; e3 && !(e3 instanceof HTMLFieldSetElement); )
    e3 instanceof HTMLLegendElement && (l2 = e3), e3 = e3.parentElement;
  let t4 = (e3 == null ? void 0 : e3.getAttribute("disabled")) === "";
  return t4 && i$2(l2) ? false : t4;
}
function i$2(n2) {
  if (!n2)
    return false;
  let e3 = n2.previousElementSibling;
  for (; e3 !== null; ) {
    if (e3 instanceof HTMLLegendElement)
      return false;
    e3 = e3.previousElementSibling;
  }
  return true;
}
function p$2(i3) {
  var t4, r3;
  let s5 = (t4 = i3 == null ? void 0 : i3.form) != null ? t4 : i3.closest("form");
  if (s5) {
    for (let n2 of s5.elements)
      if (n2 !== i3 && (n2.tagName === "INPUT" && n2.type === "submit" || n2.tagName === "BUTTON" && n2.type === "submit" || n2.nodeName === "INPUT" && n2.type === "image")) {
        n2.click();
        return;
      }
    (r3 = s5.requestSubmit) == null || r3.call(s5);
  }
}
let a3 = "div";
var p$1 = ((e3) => (e3[e3.None = 1] = "None", e3[e3.Focusable = 2] = "Focusable", e3[e3.Hidden = 4] = "Hidden", e3))(p$1 || {});
function s$1(t4, o3) {
  let { features: n2 = 1, ...e3 } = t4, d4 = { ref: o3, "aria-hidden": (n2 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n2 & 4) === 4 && (n2 & 2) !== 2 && { display: "none" } } };
  return X2({ ourProps: d4, theirProps: e3, slot: {}, defaultTag: a3, name: "Hidden" });
}
let c$1 = D$1(s$1);
var o$1 = ((r3) => (r3.Space = " ", r3.Enter = "Enter", r3.Escape = "Escape", r3.Backspace = "Backspace", r3.Delete = "Delete", r3.ArrowLeft = "ArrowLeft", r3.ArrowUp = "ArrowUp", r3.ArrowRight = "ArrowRight", r3.ArrowDown = "ArrowDown", r3.Home = "Home", r3.End = "End", r3.PageUp = "PageUp", r3.PageDown = "PageDown", r3.Tab = "Tab", r3))(o$1 || {});
function T2(l2, r3, c3) {
  let [i3, s5] = reactExports.useState(c3), e3 = l2 !== void 0, t4 = reactExports.useRef(e3), u3 = reactExports.useRef(false), d4 = reactExports.useRef(false);
  return e3 && !t4.current && !u3.current ? (u3.current = true, t4.current = e3, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e3 && t4.current && !d4.current && (d4.current = true, t4.current = e3, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e3 ? l2 : i3, o$3((n2) => (e3 || s5(n2), r3 == null ? void 0 : r3(n2)))];
}
let d$2 = reactExports.createContext(null);
function f$1() {
  let r3 = reactExports.useContext(d$2);
  if (r3 === null) {
    let t4 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t4, f$1), t4;
  }
  return r3;
}
function M$1() {
  let [r3, t4] = reactExports.useState([]);
  return [r3.length > 0 ? r3.join(" ") : void 0, reactExports.useMemo(() => function(e3) {
    let i3 = o$3((s5) => (t4((o3) => [...o3, s5]), () => t4((o3) => {
      let p2 = o3.slice(), c3 = p2.indexOf(s5);
      return c3 !== -1 && p2.splice(c3, 1), p2;
    }))), n2 = reactExports.useMemo(() => ({ register: i3, slot: e3.slot, name: e3.name, props: e3.props }), [i3, e3.slot, e3.name, e3.props]);
    return React.createElement(d$2.Provider, { value: n2 }, e3.children);
  }, [t4])];
}
let S3 = "p";
function h$2(r3, t4) {
  let a4 = I$1(), { id: e3 = `headlessui-description-${a4}`, ...i3 } = r3, n2 = f$1(), s5 = y$3(t4);
  l$3(() => n2.register(e3), [e3, n2.register]);
  let o3 = { ref: s5, ...n2.props, id: e3 };
  return X2({ ourProps: o3, theirProps: i3, slot: n2.slot || {}, defaultTag: S3, name: n2.name || "Description" });
}
let y$2 = D$1(h$2), b$1 = Object.assign(y$2, {});
let d$1 = reactExports.createContext(null);
function u$1() {
  let o3 = reactExports.useContext(d$1);
  if (o3 === null) {
    let t4 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t4, u$1), t4;
  }
  return o3;
}
function H$1() {
  let [o3, t4] = reactExports.useState([]);
  return [o3.length > 0 ? o3.join(" ") : void 0, reactExports.useMemo(() => function(e3) {
    let s5 = o$3((r3) => (t4((l2) => [...l2, r3]), () => t4((l2) => {
      let n2 = l2.slice(), p2 = n2.indexOf(r3);
      return p2 !== -1 && n2.splice(p2, 1), n2;
    }))), a4 = reactExports.useMemo(() => ({ register: s5, slot: e3.slot, name: e3.name, props: e3.props }), [s5, e3.slot, e3.name, e3.props]);
    return React.createElement(d$1.Provider, { value: a4 }, e3.children);
  }, [t4])];
}
let A$1 = "label";
function h$1(o3, t4) {
  let i3 = I$1(), { id: e3 = `headlessui-label-${i3}`, passive: s5 = false, ...a4 } = o3, r3 = u$1(), l2 = y$3(t4);
  l$3(() => r3.register(e3), [e3, r3.register]);
  let n2 = { ref: l2, ...r3.props, id: e3 };
  return s5 && ("onClick" in n2 && (delete n2.htmlFor, delete n2.onClick), "onClick" in a4 && delete a4.onClick), X2({ ourProps: n2, theirProps: a4, slot: r3.slot || {}, defaultTag: A$1, name: r3.name || "Label" });
}
let v$1 = D$1(h$1), M3 = Object.assign(v$1, {});
let y$1 = reactExports.createContext(null);
y$1.displayName = "GroupContext";
let Y2 = reactExports.Fragment;
function Z(s5) {
  var d4;
  let [n2, p2] = reactExports.useState(null), [c3, f2] = H$1(), [r3, h4] = M$1(), l2 = reactExports.useMemo(() => ({ switch: n2, setSwitch: p2, labelledby: c3, describedby: r3 }), [n2, p2, c3, r3]), T3 = {}, b3 = s5;
  return React.createElement(h4, { name: "Switch.Description" }, React.createElement(f2, { name: "Switch.Label", props: { htmlFor: (d4 = l2.switch) == null ? void 0 : d4.id, onClick(t4) {
    n2 && (t4.currentTarget.tagName === "LABEL" && t4.preventDefault(), n2.click(), n2.focus({ preventScroll: true }));
  } } }, React.createElement(y$1.Provider, { value: l2 }, X2({ ourProps: T3, theirProps: b3, defaultTag: Y2, name: "Switch.Group" }))));
}
let ee = "button";
function te(s5, n2) {
  let p2 = I$1(), { id: c3 = `headlessui-switch-${p2}`, checked: f2, defaultChecked: r3 = false, onChange: h4, name: l2, value: T$12, form: b3, ...d4 } = s5, t4 = reactExports.useContext(y$1), u3 = reactExports.useRef(null), D3 = y$3(u3, n2, t4 === null ? null : t4.setSwitch), [o3, a4] = T2(f2, h4, r3), S4 = o$3(() => a4 == null ? void 0 : a4(!o3)), C2 = o$3((e3) => {
    if (r$1(e3.currentTarget))
      return e3.preventDefault();
    e3.preventDefault(), S4();
  }), L3 = o$3((e3) => {
    e3.key === o$1.Space ? (e3.preventDefault(), S4()) : e3.key === o$1.Enter && p$2(e3.currentTarget);
  }), v2 = o$3((e3) => e3.preventDefault()), G3 = reactExports.useMemo(() => ({ checked: o3 }), [o3]), R$12 = { id: c3, ref: D3, role: "switch", type: s$2(s5, u3), tabIndex: 0, "aria-checked": o3, "aria-labelledby": t4 == null ? void 0 : t4.labelledby, "aria-describedby": t4 == null ? void 0 : t4.describedby, onClick: C2, onKeyUp: L3, onKeyPress: v2 }, k3 = p$3();
  return reactExports.useEffect(() => {
    var w3;
    let e3 = (w3 = u3.current) == null ? void 0 : w3.closest("form");
    e3 && r3 !== void 0 && k3.addEventListener(e3, "reset", () => {
      a4(r3);
    });
  }, [u3, a4]), React.createElement(React.Fragment, null, l2 != null && o3 && React.createElement(c$1, { features: p$1.Hidden, ...R2({ as: "input", type: "checkbox", hidden: true, readOnly: true, form: b3, checked: o3, name: l2, value: T$12 }) }), X2({ ourProps: R$12, theirProps: d4, slot: G3, defaultTag: ee, name: "Switch" }));
}
let ne = D$1(te), re = Z, Ge = Object.assign(ne, { Group: re, Label: M3, Description: b$1 });
const MySwitch = ({ enabled, setEnabled }) => {
  const switchBoxRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (switchBoxRef.current) {
      switchBoxRef.current.blur();
    }
  }, [enabled]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Ge,
    {
      ref: switchBoxRef,
      checked: enabled,
      onChange: setEnabled,
      className: `${enabled ? "bg-blue-600 border-transparent" : " border-neutral-600"} relative 
                inline-flex h-6 w-11 shrink-0 cursor-pointer rounded-full transition-colors duration-200 ease-in-out 
                focus:outline-none focus-visible:ring-2 focus-visible:ring-white 
                focus-visible:ring-opacity-75 border-2 border-neutral-600 border-dotted`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Use setting" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            "aria-hidden": "true",
            className: `${enabled ? "translate-x-5" : "translate-x-0"}
             pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow-2xl ring-0 transition duration-200 ease-in-out`
          }
        )
      ]
    }
  ) });
};
function DiscreteRange({
  title,
  choices,
  value,
  setValue,
  defaultValue,
  showRange,
  outOfLeftBoundary,
  range
}) {
  const [choiceColor, setChoiceColors] = reactExports.useState([]);
  const [containsValue, setChoiceContainsValue] = reactExports.useState(false);
  const [valueUpdated, setValueUpdated] = reactExports.useState(0);
  const onBlur = (e3) => {
    var _a;
    const target = e3.target.value;
    const found = (_a = choices.find((c3) => c3.name === target)) == null ? void 0 : _a.value;
    let res;
    if (found !== void 0) {
      res = found;
    } else if (typeof value === "string" && range && range.rangeStart <= target && target <= range.rangeEnd) {
      res = target;
    } else if (typeof value === "number") {
      if (range && range.rangeStart <= target && target <= range.rangeEnd) {
        if (!target.match(/^-?\d+(\.\d+)?$/)) {
          res = defaultValue;
        } else if (target.includes(".")) {
          res = Number.parseFloat(target);
        } else {
          res = Number.parseInt(target);
        }
      } else {
        res = defaultValue;
      }
    } else {
      res = defaultValue;
    }
    setValue(res);
    setValueUpdated(valueUpdated + 1);
  };
  reactExports.useEffect(() => {
    var _a;
    if (!inputBoxRef.current) {
      return;
    }
    const found = (_a = choices.find((c3) => c3.value === value)) == null ? void 0 : _a.name;
    if (found !== void 0) {
      inputBoxRef.current.value = found;
      inputBoxRef.current.size = found.length + 1;
    } else {
      inputBoxRef.current.value = value.toString();
      inputBoxRef.current.size = value.toString().length + 1;
    }
  }, [value, choices, valueUpdated]);
  reactExports.useEffect(() => {
    const res = [];
    const contain = choices.find((it) => it.value == value) !== void 0;
    for (let i3 = 0; i3 < choices.length; i3++) {
      res.push({
        index: i3,
        choice: choices[i3],
        // only render color when div is in selected range
        inRange: showRange ? contain && value !== void 0 && choices[i3].value <= value : choices[i3].value === value
      });
    }
    setChoiceContainsValue(contain);
    setChoiceColors(res);
  }, [choices, showRange, value]);
  const handleMouseLeaveFirstElement = (event) => {
    if (outOfLeftBoundary === void 0) {
      return;
    }
    if (controlState.isMouseLeftDown) {
      const { clientX } = event;
      const { right } = event.currentTarget.getBoundingClientRect();
      if (clientX < right) {
        setValue(outOfLeftBoundary);
      }
    }
  };
  const scrollBarRef = reactExports.useRef(null);
  const handleMouseMove = reactExports.useCallback((e3) => {
    if (scrollBarRef.current) {
      const totalWidth = scrollBarRef.current.scrollWidth;
      const visibleWidth = scrollBarRef.current.clientWidth;
      const mouseX = e3.clientX;
      const relativeX = mouseX - scrollBarRef.current.getBoundingClientRect().left;
      let pos;
      if (relativeX <= visibleWidth / 4) {
        pos = 0;
      } else if (relativeX >= visibleWidth * 3 / 4) {
        pos = totalWidth;
      } else {
        pos = (relativeX - visibleWidth / 4) / (visibleWidth / 2) * (totalWidth - visibleWidth);
      }
      scrollBarRef.current.scrollTo({ top: 0, left: pos, behavior: "smooth" });
    }
  }, []);
  const scrollChildRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (scrollChildRef.current) {
      scrollChildRef.current.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
    }
  }, []);
  const onContextMenu = reactExports.useCallback(
    (e3) => {
      e3.preventDefault();
      setValue(defaultValue);
      setValueUpdated(valueUpdated + 1);
    },
    [defaultValue, setValue, valueUpdated]
  );
  const handleMouseEnterChild = (oc2) => {
    if (controlState.isMouseLeftDown) {
      setValue(oc2.choice.value);
    }
  };
  const handleMouseDownChild = (oc2) => {
    setValue(oc2.choice.value);
  };
  const inputBoxRef = reactExports.useRef(null);
  const handleKeyDown = (event) => {
    var _a;
    if (event.code == "Escape") {
      (_a = inputBoxRef.current) == null ? void 0 : _a.blur();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-y-0.5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center max-h-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-neutral-600", children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: inputBoxRef,
          className: "min-w-11 max-h-6 text-center px-1 align-middle outline-0 overflow-hidden border border-neutral-500 rounded-xl resize-none " + (containsValue ? "bg-transparent" : "bg-blue-600 text-neutral-100"),
          onBlur,
          onInput: (e3) => e3.currentTarget.size = e3.currentTarget.value.length + 1,
          onFocus: (e3) => {
            e3.target.select();
          },
          onKeyDown: handleKeyDown
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "flex justify-center items-center w-full border border-neutral-500 rounded-xl overflow-hidden",
        onContextMenu,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex justify-start items-center w-full overflow-auto scrollbar-gone",
            onMouseMove: handleMouseMove,
            ref: scrollBarRef,
            children: choiceColor.map(
              (oc2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ref: oc2.choice.value === value ? scrollChildRef : null,
                  className: "flex justify-center items-center flex-grow " + (oc2.inRange ? "bg-blue-600" : "") + (showRange ? "" : " rounded-full"),
                  onMouseLeave: oc2.index == 0 ? handleMouseLeaveFirstElement : () => {
                  },
                  onMouseDown: () => handleMouseDownChild(oc2),
                  onMouseEnter: () => handleMouseEnterChild(oc2),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-center px-0.5 " + (oc2.inRange ? "text-neutral-100 " : "text-neutral-800 "), children: oc2.choice.name })
                },
                oc2.index
              )
            )
          }
        )
      }
    )
  ] });
}
const SliderRange = ({
  title,
  value,
  setValue,
  defaultValue,
  range
}) => {
  const controlSnap = useSnapshot(controlState);
  const inputBoxRef = reactExports.useRef(null);
  const sliderRef = reactExports.useRef(null);
  const [longValue, setLongValue] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (value < range.start || value > range.end) {
      setValue(defaultValue);
      setLongValue(defaultValue);
    } else {
      setLongValue(value);
    }
  }, []);
  const handleMouseAction = reactExports.useCallback(
    (e3, clicking = false) => {
      if (sliderRef.current && (clicking || controlSnap.isMouseLeftDown)) {
        const clientWidth = sliderRef.current.clientWidth;
        const { left, right } = sliderRef.current.getBoundingClientRect();
        let res;
        if (e3.clientX <= left) {
          setValue(range.start);
          setLongValue(range.start);
        } else if (e3.clientX >= right) {
          setValue(range.end);
          setLongValue(range.end);
        } else {
          const relativeX = e3.clientX - left;
          let percent2 = relativeX / clientWidth;
          if (percent2 <= 0) {
            percent2 = 0;
          }
          if (percent2 > 1) {
            percent2 = 1;
          }
          res = range.start + (range.end - range.start) * percent2;
          setLongValue(res);
          let precision = 1;
          e3.shiftKey && precision++;
          e3.altKey && precision++;
          e3.ctrlKey && precision++;
          e3.metaKey && precision++;
          const str = res.toFixed(precision);
          res = Number.parseFloat(str);
          setValue(res);
        }
      }
    },
    [controlSnap.isMouseLeftDown, setValue, range.start, range.end]
  );
  const onBlur = reactExports.useCallback((e3) => {
    const text = e3.currentTarget.value;
    const parse = Number.parseFloat(text);
    let res;
    if (isNaN(parse)) {
      res = defaultValue;
    } else if (parse < range.start || parse > range.end) {
      res = defaultValue;
    } else {
      res = parse;
    }
    setValue(res);
    setLongValue(res);
  }, [defaultValue, range.end, range.start, setValue]);
  const onContextMenu = reactExports.useCallback(
    (e3) => {
      e3.preventDefault();
      setValue(defaultValue);
      setLongValue(defaultValue);
    },
    [defaultValue, setValue, setLongValue]
  );
  const handleKeyDown = (event) => {
    var _a;
    if (event.key === "Escape" || event.key === "Enter") {
      (_a = inputBoxRef.current) == null ? void 0 : _a.blur();
    }
  };
  reactExports.useEffect(() => {
    if (inputBoxRef.current) {
      const text = "" + value;
      inputBoxRef.current.value = text;
      inputBoxRef.current.size = text.length + 1;
    }
  }, [value]);
  const [leftCapacity, setLeftCapacity] = reactExports.useState(50);
  const [rightCapacity, setRightCapacity] = reactExports.useState(50);
  reactExports.useEffect(
    () => {
      const percent2 = (defaultValue - range.start) / (range.end - range.start) * 100;
      setLeftCapacity(percent2);
      setRightCapacity(100 - percent2);
    },
    [range.end, range.start, longValue, defaultValue]
  );
  const [leftWidth, setLeftWidth] = reactExports.useState(50);
  const [rightWidth, setRightWidth] = reactExports.useState(50);
  reactExports.useEffect(
    () => {
      if (defaultValue === range.start || longValue >= defaultValue) {
        setLeftWidth(0);
      } else {
        const percent2 = (defaultValue - longValue) / (defaultValue - range.start) * 100;
        setLeftWidth(percent2);
      }
      if (defaultValue === range.end || longValue <= defaultValue) {
        setRightWidth(0);
      } else {
        const percent2 = (longValue - defaultValue) / (range.end - defaultValue) * 100;
        setRightWidth(percent2);
      }
    },
    [range.end, range.start, longValue, defaultValue]
  );
  const [isTransparent, setIsTransparent] = reactExports.useState(true);
  const [timer, setTimer] = reactExports.useState();
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer);
    };
  }, [timer]);
  const handleMouseOver = () => {
    clearTimeout(timer);
    setIsTransparent(false);
  };
  const handleMouseLeave = () => {
    const newTimer = setTimeout(() => {
      setIsTransparent(true);
    }, 1e3);
    setTimer(newTimer);
  };
  const [showDivider, setShowDivider] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (leftWidth !== 0 || rightWidth !== 0) {
      setShowDivider(false);
    } else {
      setShowDivider(true);
    }
  }, [leftCapacity, leftWidth, rightWidth]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col gap-y-0.5",
      onMouseOver: handleMouseOver,
      onMouseLeave: handleMouseLeave,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex max-h-10 items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-neutral-600", children: title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              ref: inputBoxRef,
              className: "min-w-11 max-h-6 text-center px-0.5 align-middle outline-0 overflow-hidden border\n                        border-neutral-500 rounded-xl resize-none bg-transparent",
              onInput: (e3) => e3.currentTarget.size = e3.currentTarget.value.length + 1,
              onBlur,
              onFocus: (e3) => {
                e3.target.select();
              },
              onKeyDown: handleKeyDown
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex w-full gap-0.5 justify-center overflow-hidden rounded-xl",
            ref: sliderRef,
            onMouseDown: (e3) => handleMouseAction(e3, true),
            onMouseMove: handleMouseAction,
            onMouseLeave: handleMouseAction,
            onContextMenu,
            children: [
              leftCapacity !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: { width: leftCapacity + "%" },
                  className: "flex justify-end text-transparent prose h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: { width: leftWidth + "%" },
                      className: "h-full bg-slider-pink  brightness-125 text-transparent",
                      children: "x"
                    }
                  )
                }
              ),
              rightCapacity !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: { width: rightCapacity + "%" },
                  className: "flex justify-start text-transparent prose h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: { width: rightWidth + "%" },
                      className: "h-full bg-blue-600 brightness-125 text-transparent",
                      children: "x"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "absolute top-1/2 left-0 h-full w-full -translate-y-1/2 bg-cover opacity-100 brightness-200 contrast-200 bg-noise",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-1/2 text-transparent brightness-125 prose", children: value })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "absolute top-1/2 left-1 -translate-y-1/2 text-neutral-800 font-md text-md transition duration-200 " + (isTransparent ? "text-opacity-0" : "text-opacity-100"),
                  children: range.start
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "absolute top-1/2 right-1 -translate-y-1/2 text-neutral-800 font-md text-md transition duration-200 " + (isTransparent ? "text-opacity-0" : "text-opacity-100"),
                  children: range.end
                }
              ),
              showDivider && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: { left: leftCapacity - leftCapacity / 100 * 0.6 + rightCapacity / 100 * 0.6 + "%" },
                  className: "absolute top-1/2 -translate-y-1/2 h-full w-[1px] bg-neutral-500"
                }
              )
            ]
          }
        )
      ]
    }
  );
};
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var reactIs_production_min = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b2 = 60103, c2 = 60106, d3 = 60107, e$2 = 60108, f = 60114, g = 60109, h3 = 60110, k2 = 60112, l$1 = 60113, m3 = 60120, n$1 = 60115, p = 60116, q2 = 60121, r2 = 60122, u2 = 60117, v = 60129, w2 = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var x2 = Symbol.for;
  b2 = x2("react.element");
  c2 = x2("react.portal");
  d3 = x2("react.fragment");
  e$2 = x2("react.strict_mode");
  f = x2("react.profiler");
  g = x2("react.provider");
  h3 = x2("react.context");
  k2 = x2("react.forward_ref");
  l$1 = x2("react.suspense");
  m3 = x2("react.suspense_list");
  n$1 = x2("react.memo");
  p = x2("react.lazy");
  q2 = x2("react.block");
  r2 = x2("react.server.block");
  u2 = x2("react.fundamental");
  v = x2("react.debug_trace_mode");
  w2 = x2("react.legacy_hidden");
}
function y3(a4) {
  if ("object" === typeof a4 && null !== a4) {
    var t4 = a4.$$typeof;
    switch (t4) {
      case b2:
        switch (a4 = a4.type, a4) {
          case d3:
          case f:
          case e$2:
          case l$1:
          case m3:
            return a4;
          default:
            switch (a4 = a4 && a4.$$typeof, a4) {
              case h3:
              case k2:
              case p:
              case n$1:
              case g:
                return a4;
              default:
                return t4;
            }
        }
      case c2:
        return t4;
    }
  }
}
var z2 = g, A = b2, B2 = k2, C = d3, D2 = p, E2 = n$1, F = c2, G2 = f, H3 = e$2, I2 = l$1;
reactIs_production_min.ContextConsumer = h3;
reactIs_production_min.ContextProvider = z2;
reactIs_production_min.Element = A;
reactIs_production_min.ForwardRef = B2;
reactIs_production_min.Fragment = C;
reactIs_production_min.Lazy = D2;
reactIs_production_min.Memo = E2;
reactIs_production_min.Portal = F;
reactIs_production_min.Profiler = G2;
reactIs_production_min.StrictMode = H3;
reactIs_production_min.Suspense = I2;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a4) {
  return y3(a4) === h3;
};
reactIs_production_min.isContextProvider = function(a4) {
  return y3(a4) === g;
};
reactIs_production_min.isElement = function(a4) {
  return "object" === typeof a4 && null !== a4 && a4.$$typeof === b2;
};
reactIs_production_min.isForwardRef = function(a4) {
  return y3(a4) === k2;
};
reactIs_production_min.isFragment = function(a4) {
  return y3(a4) === d3;
};
reactIs_production_min.isLazy = function(a4) {
  return y3(a4) === p;
};
reactIs_production_min.isMemo = function(a4) {
  return y3(a4) === n$1;
};
reactIs_production_min.isPortal = function(a4) {
  return y3(a4) === c2;
};
reactIs_production_min.isProfiler = function(a4) {
  return y3(a4) === f;
};
reactIs_production_min.isStrictMode = function(a4) {
  return y3(a4) === e$2;
};
reactIs_production_min.isSuspense = function(a4) {
  return y3(a4) === l$1;
};
reactIs_production_min.isValidElementType = function(a4) {
  return "string" === typeof a4 || "function" === typeof a4 || a4 === d3 || a4 === f || a4 === v || a4 === e$2 || a4 === l$1 || a4 === m3 || a4 === w2 || "object" === typeof a4 && null !== a4 && (a4.$$typeof === p || a4.$$typeof === n$1 || a4.$$typeof === g || a4.$$typeof === h3 || a4.$$typeof === k2 || a4.$$typeof === u2 || a4.$$typeof === q2 || a4[0] === r2) ? true : false;
};
reactIs_production_min.typeOf = y3;
let e$1 = (e3) => "object" == typeof e3 && null != e3 && 1 === e3.nodeType, t$1 = (e3, t4) => (!t4 || "hidden" !== e3) && ("visible" !== e3 && "clip" !== e3), n = (e3, n2) => {
  if (e3.clientHeight < e3.scrollHeight || e3.clientWidth < e3.scrollWidth) {
    let l2 = getComputedStyle(e3, null);
    return t$1(l2.overflowY, n2) || t$1(l2.overflowX, n2) || ((e4) => {
      let t4 = ((e5) => {
        if (!e5.ownerDocument || !e5.ownerDocument.defaultView)
          return null;
        try {
          return e5.ownerDocument.defaultView.frameElement;
        } catch (e6) {
          return null;
        }
      })(e4);
      return !!t4 && (t4.clientHeight < e4.scrollHeight || t4.clientWidth < e4.scrollWidth);
    })(e3);
  }
  return false;
}, l = (e3, t4, n2, l2, i3, o3, r3, d4) => o3 < e3 && r3 > t4 || o3 > e3 && r3 < t4 ? 0 : o3 <= e3 && d4 <= n2 || r3 >= t4 && d4 >= n2 ? o3 - e3 - l2 : r3 > t4 && d4 < n2 || o3 < e3 && d4 > n2 ? r3 - t4 + i3 : 0, i$1 = (e3) => {
  let t4 = e3.parentElement;
  return null == t4 ? e3.getRootNode().host || null : t4;
};
var o2 = (t4, o3) => {
  var r3, d4, h4, f2, u3, s5;
  if ("undefined" == typeof document)
    return [];
  let { scrollMode: a4, block: c3, inline: g2, boundary: m4, skipOverflowHiddenElements: p2 } = o3, w3 = "function" == typeof m4 ? m4 : (e3) => e3 !== m4;
  if (!e$1(t4))
    throw new TypeError("Invalid target");
  let W2 = document.scrollingElement || document.documentElement, H4 = [], b3 = t4;
  for (; e$1(b3) && w3(b3); ) {
    if (b3 = i$1(b3), b3 === W2) {
      H4.push(b3);
      break;
    }
    null != b3 && b3 === document.body && n(b3) && !n(document.documentElement) || null != b3 && n(b3, p2) && H4.push(b3);
  }
  let v2 = null != (d4 = null == (r3 = window.visualViewport) ? void 0 : r3.width) ? d4 : innerWidth, y4 = null != (f2 = null == (h4 = window.visualViewport) ? void 0 : h4.height) ? f2 : innerHeight, E3 = null != (u3 = window.scrollX) ? u3 : pageXOffset, M4 = null != (s5 = window.scrollY) ? s5 : pageYOffset, { height: x2, width: I3, top: C2, right: R3, bottom: T3, left: V2 } = t4.getBoundingClientRect(), k3 = "start" === c3 || "nearest" === c3 ? C2 : "end" === c3 ? T3 : C2 + x2 / 2, B3 = "center" === g2 ? V2 + I3 / 2 : "end" === g2 ? R3 : V2, D3 = [];
  for (let e3 = 0; e3 < H4.length; e3++) {
    let t5 = H4[e3], { height: n2, width: i3, top: o4, right: r4, bottom: d5, left: h5 } = t5.getBoundingClientRect();
    if ("if-needed" === a4 && C2 >= 0 && V2 >= 0 && T3 <= y4 && R3 <= v2 && C2 >= o4 && T3 <= d5 && V2 >= h5 && R3 <= r4)
      return D3;
    let f3 = getComputedStyle(t5), u4 = parseInt(f3.borderLeftWidth, 10), s6 = parseInt(f3.borderTopWidth, 10), m5 = parseInt(f3.borderRightWidth, 10), p3 = parseInt(f3.borderBottomWidth, 10), w4 = 0, b4 = 0, O3 = "offsetWidth" in t5 ? t5.offsetWidth - t5.clientWidth - u4 - m5 : 0, X3 = "offsetHeight" in t5 ? t5.offsetHeight - t5.clientHeight - s6 - p3 : 0, Y3 = "offsetWidth" in t5 ? 0 === t5.offsetWidth ? 0 : i3 / t5.offsetWidth : 0, L3 = "offsetHeight" in t5 ? 0 === t5.offsetHeight ? 0 : n2 / t5.offsetHeight : 0;
    if (W2 === t5)
      w4 = "start" === c3 ? k3 : "end" === c3 ? k3 - y4 : "nearest" === c3 ? l(M4, M4 + y4, y4, s6, p3, M4 + k3, M4 + k3 + x2, x2) : k3 - y4 / 2, b4 = "start" === g2 ? B3 : "center" === g2 ? B3 - v2 / 2 : "end" === g2 ? B3 - v2 : l(E3, E3 + v2, v2, u4, m5, E3 + B3, E3 + B3 + I3, I3), w4 = Math.max(0, w4 + M4), b4 = Math.max(0, b4 + E3);
    else {
      w4 = "start" === c3 ? k3 - o4 - s6 : "end" === c3 ? k3 - d5 + p3 + X3 : "nearest" === c3 ? l(o4, d5, n2, s6, p3 + X3, k3, k3 + x2, x2) : k3 - (o4 + n2 / 2) + X3 / 2, b4 = "start" === g2 ? B3 - h5 - u4 : "center" === g2 ? B3 - (h5 + i3 / 2) + O3 / 2 : "end" === g2 ? B3 - r4 + m5 + O3 : l(h5, r4, i3, u4, m5 + O3, B3, B3 + I3, I3);
      let { scrollLeft: e4, scrollTop: f4 } = t5;
      w4 = Math.max(0, Math.min(f4 + w4 / L3, t5.scrollHeight - n2 / L3 + X3)), b4 = Math.max(0, Math.min(e4 + b4 / Y3, t5.scrollWidth - i3 / Y3 + O3)), k3 += f4 - w4, B3 += e4 - b4;
    }
    D3.push({ el: t5, top: w4, left: b4 });
  }
  return D3;
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t4) {
    for (var s5, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s5 = arguments[i3];
      for (var p2 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p2))
          t4[p2] = s5[p2];
    }
    return t4;
  };
  return __assign.apply(this, arguments);
};
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
};
var idCounter = 0;
function noop() {
}
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  var actions = o2(node, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach(function(_ref) {
    var el2 = _ref.el, top = _ref.top, left = _ref.left;
    el2.scrollTop = top;
    el2.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce(fn, time) {
  var timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(function() {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node) {
    refs.forEach(function(ref2) {
      if (typeof ref2 === "function") {
        ref2(node);
      } else if (ref2) {
        ref2.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage$1(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function getState(state, props) {
  return Object.keys(state).reduce(function(prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  var key = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return "Arrow" + key;
  }
  return key;
}
function getHighlightedIndex(start, offset, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count = items.length;
  if (count === 0) {
    return -1;
  }
  var itemsLastIndex = count - 1;
  if (typeof start !== "number" || start < 0 || start > itemsLastIndex) {
    start = offset > 0 ? -1 : itemsLastIndex + 1;
  }
  var current = start + offset;
  if (current < 0) {
    current = circular ? itemsLastIndex : 0;
  } else if (current > itemsLastIndex) {
    current = circular ? 0 : itemsLastIndex;
  }
  var highlightedIndex = getNonDisabledIndex(current, offset < 0, items, isItemDisabled2, circular);
  if (highlightedIndex === -1) {
    return start >= count ? -1 : start;
  }
  return highlightedIndex;
}
function getNonDisabledIndex(start, backwards, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count = items.length;
  if (backwards) {
    for (var index2 = start; index2 >= 0; index2--) {
      if (!isItemDisabled2(items[index2], index2)) {
        return index2;
      }
    }
  } else {
    for (var _index = start; _index < count; _index++) {
      if (!isItemDisabled2(items[_index], _index)) {
        return _index;
      }
    }
  }
  if (circular) {
    return getNonDisabledIndex(backwards ? count - 1 : 0, backwards, items, isItemDisabled2);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var cleanupStatus = debounce(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function setStatus(status, documentProp) {
  var div = getStatusDiv(documentProp);
  if (!status) {
    return;
  }
  div.textContent = status;
  cleanupStatus(documentProp);
}
function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  var props = action.props, type = action.type;
  var changes = {};
  Object.keys(state).forEach(function(key) {
    invokeOnChangeHandler(key, action, state, newState);
    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends({
      type
    }, changes));
  }
}
function invokeOnChangeHandler(key, action, state, newState) {
  var props = action.props, type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
    props[handler](_extends({
      type
    }, newState));
  }
}
function stateReducer(s5, a4) {
  return a4.changes;
}
function getA11ySelectionMessage(selectionParameters) {
  var selectedItem = selectionParameters.selectedItem, itemToStringLocal = selectionParameters.itemToString;
  return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
}
var updateA11yStatus = debounce(function(getA11yMessage, document2) {
  setStatus(getA11yMessage(), document2);
}, 200);
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var useElementIds = "useId" in React ? function useElementIds2(_ref) {
  var id2 = _ref.id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var reactId = "downshift-" + React.useId();
  if (!id2) {
    id2 = reactId;
  }
  var elementIdsRef = reactExports.useRef({
    labelId: labelId || id2 + "-label",
    menuId: menuId || id2 + "-menu",
    getItemId: getItemId || function(index2) {
      return id2 + "-item-" + index2;
    },
    toggleButtonId: toggleButtonId || id2 + "-toggle-button",
    inputId: inputId || id2 + "-input"
  });
  return elementIdsRef.current;
} : function useElementIds3(_ref2) {
  var _ref2$id = _ref2.id, id2 = _ref2$id === void 0 ? "downshift-" + generateId() : _ref2$id, labelId = _ref2.labelId, menuId = _ref2.menuId, getItemId = _ref2.getItemId, toggleButtonId = _ref2.toggleButtonId, inputId = _ref2.inputId;
  var elementIdsRef = reactExports.useRef({
    labelId: labelId || id2 + "-label",
    menuId: menuId || id2 + "-menu",
    getItemId: getItemId || function(index2) {
      return id2 + "-item-" + index2;
    },
    toggleButtonId: toggleButtonId || id2 + "-toggle-button",
    inputId: inputId || id2 + "-input"
  });
  return elementIdsRef.current;
};
function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
  var item, index2;
  if (itemProp === void 0) {
    if (indexProp === void 0) {
      throw new Error(errorMessage);
    }
    item = items[indexProp];
    index2 = indexProp;
  } else {
    index2 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
    item = itemProp;
  }
  return [item, index2];
}
function itemToString(item) {
  return item ? String(item) : "";
}
function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}
function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}
function useLatestRef(val) {
  var ref2 = reactExports.useRef(val);
  ref2.current = val;
  return ref2;
}
function useEnhancedReducer(reducer, initialState, props) {
  var prevStateRef = reactExports.useRef();
  var actionRef = reactExports.useRef();
  var enhancedReducer = reactExports.useCallback(function(state2, action2) {
    actionRef.current = action2;
    state2 = getState(state2, action2.props);
    var changes = reducer(state2, action2);
    var newState = action2.props.stateReducer(state2, _extends({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = reactExports.useReducer(enhancedReducer, initialState), state = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef(props);
  var dispatchWithProps = reactExports.useCallback(function(action2) {
    return dispatch(_extends({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  reactExports.useEffect(function() {
    if (action && prevStateRef.current && prevStateRef.current !== state) {
      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
    }
    prevStateRef.current = state;
  }, [state, props, action]);
  return [state, dispatchWithProps];
}
function useControlledReducer$1(reducer, initialState, props) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  return [getState(state, props), dispatch];
}
var defaultProps$3 = {
  itemToString,
  stateReducer,
  getA11ySelectionMessage,
  scrollIntoView,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" ? {} : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  var defaultValue = props["default" + capitalizeString(propKey)];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  var value = props[propKey];
  if (value !== void 0) {
    return value;
  }
  var initialValue = props["initial" + capitalizeString(propKey)];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex;
  var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    return items.indexOf(selectedItem);
  }
  if (offset === 0) {
    return -1;
  }
  return offset < 0 ? items.length - 1 : 0;
}
function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
  var mouseAndTouchTrackersRef = reactExports.useRef({
    isMouseDown: false,
    isTouchMove: false
  });
  reactExports.useEffect(function() {
    if ((environment == null ? void 0 : environment.addEventListener) == null) {
      return;
    }
    var onMouseDown = function onMouseDown2() {
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    };
    var onMouseUp = function onMouseUp2(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref2) {
        return ref2.current;
      }), environment)) {
        handleBlur();
      }
    };
    var onTouchStart = function onTouchStart2() {
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    };
    var onTouchMove = function onTouchMove2() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    };
    var onTouchEnd = function onTouchEnd2(event) {
      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref2) {
        return ref2.current;
      }), environment, false)) {
        handleBlur();
      }
    };
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [isOpen, environment]);
  return mouseAndTouchTrackersRef;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop;
};
function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref3) {
  var isInitialMount = _ref3.isInitialMount, highlightedIndex = _ref3.highlightedIndex, items = _ref3.items, environment = _ref3.environment, rest = _objectWithoutPropertiesLoose$1(_ref3, _excluded$3);
  reactExports.useEffect(function() {
    if (isInitialMount || false) {
      return;
    }
    updateA11yStatus(function() {
      return getA11yMessage(_extends({
        highlightedIndex,
        highlightedItem: items[highlightedIndex],
        resultCount: items.length
      }, rest));
    }, environment.document);
  }, dependencyArray);
}
function useScrollIntoView(_ref4) {
  var highlightedIndex = _ref4.highlightedIndex, isOpen = _ref4.isOpen, itemRefs = _ref4.itemRefs, getItemNodeFromIndex = _ref4.getItemNodeFromIndex, menuElement = _ref4.menuElement, scrollIntoViewProp = _ref4.scrollIntoView;
  var shouldScrollRef = reactExports.useRef(true);
  useIsomorphicLayoutEffect(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop;
function getChangesOnSelection(props, highlightedIndex, inputValue) {
  var _props$items;
  if (inputValue === void 0) {
    inputValue = true;
  }
  var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
  return _extends({
    isOpen: false,
    highlightedIndex: -1
  }, shouldSelect && _extends({
    selectedItem: props.items[highlightedIndex],
    isOpen: getDefaultValue$1(props, "isOpen"),
    highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
  }, inputValue && {
    inputValue: props.itemToString(props.items[highlightedIndex])
  }));
}
var commonPropTypes = {
  environment: PropTypes.shape({
    addEventListener: PropTypes.func.isRequired,
    removeEventListener: PropTypes.func.isRequired,
    document: PropTypes.shape({
      createElement: PropTypes.func.isRequired,
      getElementById: PropTypes.func.isRequired,
      activeElement: PropTypes.any.isRequired,
      body: PropTypes.any.isRequired
    }).isRequired,
    Node: PropTypes.func.isRequired
  }),
  itemToString: PropTypes.func,
  stateReducer: PropTypes.func
};
var commonDropdownPropTypes = _extends({}, commonPropTypes, {
  getA11yStatusMessage: PropTypes.func,
  highlightedIndex: PropTypes.number,
  defaultHighlightedIndex: PropTypes.number,
  initialHighlightedIndex: PropTypes.number,
  isOpen: PropTypes.bool,
  defaultIsOpen: PropTypes.bool,
  initialIsOpen: PropTypes.bool,
  selectedItem: PropTypes.any,
  initialSelectedItem: PropTypes.any,
  defaultSelectedItem: PropTypes.any,
  id: PropTypes.string,
  labelId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func,
  toggleButtonId: PropTypes.string,
  onSelectedItemChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  onStateChange: PropTypes.func,
  onIsOpenChange: PropTypes.func,
  scrollIntoView: PropTypes.func
});
function downshiftCommonReducer(state, action, stateChangeTypes) {
  var type = action.type, props = action.props;
  var changes;
  switch (type) {
    case stateChangeTypes.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes.ToggleButtonClick:
    case stateChangeTypes.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: action.highlightedIndex
      };
      break;
    case stateChangeTypes.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes.FunctionReset:
      changes = {
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends({}, state, changes);
}
function getItemIndexByCharacterKey(_a) {
  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString2 = _a.itemToString, isItemDisabled2 = _a.isItemDisabled;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index2 = 0; index2 < items.length; index2++) {
    var offsetIndex = (index2 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar) && !isItemDisabled2(item, offsetIndex)) {
      return offsetIndex;
    }
  }
  return highlightedIndex;
}
__assign(__assign({}, commonDropdownPropTypes), { items: PropTypes.array.isRequired, isItemDisabled: PropTypes.func, getA11ySelectionMessage: PropTypes.func });
function getA11yStatusMessage(_a) {
  var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return "".concat(resultCount, " result").concat(resultCount === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
  }
  return "";
}
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage, isItemDisabled: function() {
  return false;
} });
var ToggleButtonClick$1 = 0;
var ToggleButtonKeyDownArrowDown = 1;
var ToggleButtonKeyDownArrowUp = 2;
var ToggleButtonKeyDownCharacter = 3;
var ToggleButtonKeyDownEscape = 4;
var ToggleButtonKeyDownHome = 5;
var ToggleButtonKeyDownEnd = 6;
var ToggleButtonKeyDownEnter = 7;
var ToggleButtonKeyDownSpaceButton = 8;
var ToggleButtonKeyDownPageUp = 9;
var ToggleButtonKeyDownPageDown = 10;
var ToggleButtonBlur = 11;
var MenuMouseLeave$1 = 12;
var ItemMouseMove$1 = 13;
var ItemClick$1 = 14;
var FunctionToggleMenu$1 = 15;
var FunctionOpenMenu$1 = 16;
var FunctionCloseMenu$1 = 17;
var FunctionSetHighlightedIndex$1 = 18;
var FunctionSelectItem$1 = 19;
var FunctionSetInputValue$1 = 20;
var FunctionReset$2 = 21;
var stateChangeTypes$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  ToggleButtonKeyDownEscape,
  ToggleButtonKeyDownHome,
  ToggleButtonKeyDownEnd,
  ToggleButtonKeyDownEnter,
  ToggleButtonKeyDownSpaceButton,
  ToggleButtonKeyDownPageUp,
  ToggleButtonKeyDownPageDown,
  ToggleButtonBlur,
  MenuMouseLeave: MenuMouseLeave$1,
  ItemMouseMove: ItemMouseMove$1,
  ItemClick: ItemClick$1,
  FunctionToggleMenu: FunctionToggleMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionReset: FunctionReset$2
});
function downshiftSelectReducer(state, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state.inputValue + lowercasedKey;
        var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.indexOf(state.selectedItem) : state.highlightedIndex;
        var highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: prevHighlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          isItemDisabled: props.isItemDisabled
        });
        changes = {
          inputValue,
          highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      {
        var _highlightedIndex = state.isOpen ? getHighlightedIndex(state.highlightedIndex, 1, props.items, props.isItemDisabled) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
        changes = {
          highlightedIndex: _highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowUp:
      if (state.isOpen && altKey) {
        changes = getChangesOnSelection(props, state.highlightedIndex, false);
      } else {
        var _highlightedIndex2 = state.isOpen ? getHighlightedIndex(state.highlightedIndex, -1, props.items, props.isItemDisabled) : getHighlightedIndexOnOpen(props, state, -1);
        changes = {
          highlightedIndex: _highlightedIndex2,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownEnter:
    case ToggleButtonKeyDownSpaceButton:
      changes = getChangesOnSelection(props, state.highlightedIndex, false);
      break;
    case ToggleButtonKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, -10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, 10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case ToggleButtonBlur:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
        selectedItem: props.items[state.highlightedIndex]
      });
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }
  return _extends({}, state, changes);
}
var _excluded$2 = ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"], _excluded2$2 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"], _excluded3$1 = ["item", "index", "onMouseMove", "onClick", "onPress", "refKey", "disabled", "ref"];
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  var props = _extends({}, defaultProps$2, userProps);
  var items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, itemToString2 = props.itemToString, getA11ySelectionMessage2 = props.getA11ySelectionMessage, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var initialState = getInitialState$2(props);
  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, initialState, props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var toggleButtonRef = reactExports.useRef(null);
  var menuRef = reactExports.useRef(null);
  var itemRefs = reactExports.useRef({});
  var clearTimeoutRef = reactExports.useRef(null);
  var elementIds = useElementIds(props);
  var previousResultCountRef = reactExports.useRef();
  var isInitialMountRef = reactExports.useRef(true);
  var latest = useLatestRef({
    state,
    props
  });
  var getItemNodeFromIndex = reactExports.useCallback(function(index2) {
    return itemRefs.current[elementIds.getItemId(index2)];
  }, [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  reactExports.useEffect(function() {
    clearTimeoutRef.current = debounce(function(outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return function() {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  reactExports.useEffect(function() {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  reactExports.useEffect(function() {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  reactExports.useEffect(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && toggleButtonRef.current) {
      toggleButtonRef.current.focus();
    }
  }, []);
  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function() {
    dispatch({
      type: ToggleButtonBlur
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker();
  reactExports.useEffect(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  reactExports.useEffect(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var toggleButtonKeyDownHandlers = reactExports.useMemo(function() {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownHome
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownEnd
        });
      },
      Escape: function Escape() {
        if (latest.current.state.isOpen) {
          dispatch({
            type: ToggleButtonKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: latest.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageDown
          });
        }
      },
      " ": function _2(event) {
        event.preventDefault();
        var currentState = latest.current.state;
        if (!currentState.isOpen) {
          dispatch({
            type: ToggleButtonClick$1
          });
          return;
        }
        if (currentState.inputValue) {
          dispatch({
            type: ToggleButtonKeyDownCharacter,
            key: " "
          });
        } else {
          dispatch({
            type: ToggleButtonKeyDownSpaceButton
          });
        }
      }
    };
  }, [dispatch, latest]);
  var toggleMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = reactExports.useCallback(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = reactExports.useCallback(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset = reactExports.useCallback(function() {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = reactExports.useCallback(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var getLabelProps = reactExports.useCallback(function(labelProps) {
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = reactExports.useCallback(function(_temp, _temp2) {
    var _extends2;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey;
    _ref.onKeyDown;
    _ref.onBlur;
    var ref2 = _ref.ref, rest = _objectWithoutPropertiesLoose$1(_ref, _excluded$2);
    var _ref2 = _temp2 === void 0 ? {} : _temp2;
    _ref2.suppressRefError;
    var menuHandleMouseLeave = function menuHandleMouseLeave2() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getToggleButtonProps = reactExports.useCallback(function(_temp3, _temp4) {
    var _extends3;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, onBlur = _ref3.onBlur, onClick = _ref3.onClick;
    _ref3.onPress;
    var onKeyDown = _ref3.onKeyDown, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref2 = _ref3.ref, rest = _objectWithoutPropertiesLoose$1(_ref3, _excluded2$2);
    var _ref4 = _temp4 === void 0 ? {} : _temp4;
    _ref4.suppressRefError;
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        dispatch({
          type: ToggleButtonBlur
        });
      }
    };
    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key
        });
      }
    };
    var toggleProps = _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref2, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
    if (!rest.disabled) {
      {
        toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
        toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
      }
    }
    return toggleProps;
  }, [latest, elementIds, setGetterPropCallInfo, dispatch, mouseAndTouchTrackersRef, toggleButtonKeyDownHandlers]);
  var getItemProps = reactExports.useCallback(function(_temp5) {
    var _extends4;
    var _ref5 = _temp5 === void 0 ? {} : _temp5, itemProp = _ref5.item, indexProp = _ref5.index, onMouseMove = _ref5.onMouseMove, onClick = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, disabledProp = _ref5.disabled, ref2 = _ref5.ref, rest = _objectWithoutPropertiesLoose$1(_ref5, _excluded3$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useSelect.');
    }
    var _latest$current = latest.current, latestState = _latest$current.state, latestProps = _latest$current.props;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index2 = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index2);
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (index2 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index2,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick$1,
        index: index2
      });
    };
    var itemProps = _extends((_extends4 = {}, _extends4[refKey] = handleRefs(ref2, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index2)] = itemNode;
      }
    }), _extends4["aria-disabled"] = disabled, _extends4["aria-selected"] = "" + (item === latestState.selectedItem), _extends4.id = elementIds.getItemId(index2), _extends4.role = "option", _extends4), rest);
    if (!disabled) {
      {
        itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
      }
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    return itemProps;
  }, [latest, elementIds, shouldScrollRef, dispatch]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem,
    reset,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
_extends({}, commonDropdownPropTypes, {
  items: PropTypes.array.isRequired,
  isItemDisabled: PropTypes.func,
  selectedItemChanged: PropTypes.func,
  getA11ySelectionMessage: PropTypes.func,
  inputValue: PropTypes.string,
  defaultInputValue: PropTypes.string,
  initialInputValue: PropTypes.string,
  inputId: PropTypes.string,
  onInputValueChange: PropTypes.func
});
_extends({}, defaultProps$3, {
  selectedItemChanged: function selectedItemChanged(prevItem, item) {
    return prevItem !== item;
  },
  getA11yStatusMessage: getA11yStatusMessage$1,
  isItemDisabled: function isItemDisabled() {
    return false;
  }
});
function getA11yRemovalMessage(selectionParameters) {
  var removedSelectedItem = selectionParameters.removedSelectedItem, itemToStringLocal = selectionParameters.itemToString;
  return itemToStringLocal(removedSelectedItem) + " has been removed.";
}
_extends({}, commonPropTypes, {
  selectedItems: PropTypes.array,
  initialSelectedItems: PropTypes.array,
  defaultSelectedItems: PropTypes.array,
  getA11yRemovalMessage: PropTypes.func,
  activeIndex: PropTypes.number,
  initialActiveIndex: PropTypes.number,
  defaultActiveIndex: PropTypes.number,
  onActiveIndexChange: PropTypes.func,
  onSelectedItemsChange: PropTypes.func,
  keyNavigationNext: PropTypes.string,
  keyNavigationPrevious: PropTypes.string
});
({
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
});
function SelectBoxExample({ choices, defaultValue, setValue }) {
  const {
    isOpen,
    selectedItem,
    getToggleButtonProps,
    getMenuProps,
    highlightedIndex,
    getItemProps,
    selectItem
  } = useSelect({
    defaultSelectedItem: choices[0],
    items: choices,
    itemToString: (c3) => c3.name,
    onSelectedItemChange: ({ selectedItem: newSelectedItem }) => setValue(newSelectedItem.value)
  });
  reactExports.useEffect(() => {
    const ft = choices.filter((c3) => c3.value === defaultValue);
    if (ft.length !== 1) {
      console.error("ft:", ft);
      console.error("defaultValue:", defaultValue);
      throw new Error("one and only one of choices must equal value");
    }
    selectItem(ft[0]);
  }, [defaultValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: "prose border border-neutral-500 rounded-xl cursor-pointer text-neutral-800 px-1.5\n             truncate ... outline-none bg-white bg-opacity-50 backdrop-blur",
        ...getToggleButtonProps(),
        children: selectedItem.name
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "ul",
      {
        className: cx(
          "z-50 bg-opacity-40 backdrop-blur absolute bg-white mt-1 max-h-80",
          " overflow-y-scroll  rounded-xl bg-neutral-200 w-64",
          !isOpen && "hidden"
        ),
        ...getMenuProps(),
        children: isOpen && choices.map((c3, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "li",
          {
            className: cx(
              highlightedIndex === index2 && "bg-white/[0.35]",
              selectedItem.value === c3.value && "bg-white/[0.8]",
              "rounded-xl py-1.5 px-1.5 shadow-sm flex flex-col"
            ),
            ...getItemProps({ item: c3, index: index2 }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-4 pr-1 w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rewrite-this-whitespace-nowrap", children: c3.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rewrite-this-whitespace-nowrap text-sm text-gray-700", children: c3.tags.join(" ") })
            ] })
          },
          `${c3.value}${index2}`
        ))
      }
    )
  ] });
}
function SelectBoxOrNotAvailable({ title, choices, defaultValue, setValue }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-start items-center gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-neutral-600", children: title }),
    defaultValue !== void 0 && choices.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full overflow-x-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectBoxExample,
      {
        choices,
        defaultValue,
        setValue
      }
    ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full justify-end text-neutral-600 line-through", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Not Available" }) })
  ] });
}
const ChatGpt = ({ chatGPTOptionProxy, setEnabled }) => {
  const chatGPTOptionSnap = useSnapshot(chatGPTOptionProxy);
  const chatGPTAbility = useSnapshot(appState.ability.llm.chatGPT);
  const llmOptionSnap = useSnapshot(appState.option.llm);
  const [modelChoices, setModelChoices] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const choices = _.map(appState.ability.llm.chatGPT.models, (model) => ({
      name: model,
      value: model,
      tags: []
    }));
    setModelChoices(choices);
  }, [chatGPTAbility.models]);
  const setMaxHistory = reactExports.useCallback((hist) => {
    appState.option.llm.maxHistory = hist;
  }, []);
  const setModel = reactExports.useCallback((model) => {
    chatGPTOptionProxy.model = model;
  }, []);
  const setMaxTokens = reactExports.useCallback((token) => {
    chatGPTOptionProxy.maxTokens = token;
  }, []);
  const setTemperature = reactExports.useCallback((temperature) => {
    chatGPTOptionProxy.temperature = temperature;
  }, []);
  const setTopP = reactExports.useCallback((topP) => {
    chatGPTOptionProxy.topP = topP;
  }, []);
  const setPresencePenalty = reactExports.useCallback((presencePenalty) => {
    chatGPTOptionProxy.presencePenalty = presencePenalty;
  }, []);
  const setFrequencyPenalty = reactExports.useCallback((frequencyPenalty) => {
    chatGPTOptionProxy.frequencyPenalty = frequencyPenalty;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full items-center justify-between gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col justify-center gap-2 py-2 px-3 border-2 border-neutral-500 border-dashed\n                        rounded-lg w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "ChatGPT" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MySwitch, { enabled: chatGPTOptionSnap.enabled, setEnabled })
        ] }),
        chatGPTOptionSnap.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DiscreteRange,
            {
              choices: historyChoices,
              title: "Max Hisotry",
              setValue: setMaxHistory,
              value: llmOptionSnap.maxHistory,
              showRange: true,
              outOfLeftBoundary: chatGPTAPIReference.maxHistory.rangeStart,
              defaultValue: chatGPTAPIReference.maxHistory.default,
              range: {
                rangeStart: chatGPTAPIReference.maxHistory.rangeStart,
                rangeEnd: chatGPTAPIReference.maxHistory.rangeEnd
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DiscreteRange,
            {
              choices: tokenChoices,
              title: "Max Tokens",
              setValue: setMaxTokens,
              value: chatGPTOptionSnap.maxTokens,
              showRange: true,
              outOfLeftBoundary: chatGPTAPIReference.maxTokens.rangeStart,
              defaultValue: chatGPTAPIReference.maxTokens.default,
              range: {
                rangeStart: chatGPTAPIReference.maxTokens.rangeStart,
                rangeEnd: chatGPTAPIReference.maxTokens.rangeEnd
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Temperature",
              defaultValue: chatGPTAPIReference.temperature.default,
              range: {
                start: chatGPTAPIReference.temperature.rangeStart,
                end: chatGPTAPIReference.temperature.rangeEnd
              },
              setValue: setTemperature,
              value: chatGPTOptionSnap.temperature
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "TopP",
              defaultValue: chatGPTAPIReference.topP.default,
              range: {
                start: chatGPTAPIReference.topP.rangeStart,
                end: chatGPTAPIReference.topP.rangeEnd
              },
              setValue: setTopP,
              value: chatGPTOptionSnap.topP
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Presence Panelty",
              defaultValue: chatGPTAPIReference.presencePenalty.default,
              range: {
                start: chatGPTAPIReference.presencePenalty.rangeStart,
                end: chatGPTAPIReference.presencePenalty.rangeEnd
              },
              setValue: setPresencePenalty,
              value: chatGPTOptionSnap.presencePenalty
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Frequency Panelty",
              defaultValue: chatGPTAPIReference.frequencyPenalty.default,
              range: {
                start: chatGPTAPIReference.frequencyPenalty.rangeStart,
                end: chatGPTAPIReference.frequencyPenalty.rangeEnd
              },
              setValue: setFrequencyPenalty,
              value: chatGPTOptionSnap.frequencyPenalty
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectBoxOrNotAvailable,
            {
              title: "Model",
              choices: modelChoices,
              defaultValue: chatGPTOptionSnap.model,
              setValue: setModel
            }
          )
        ] })
      ]
    }
  ) });
};
const LLM = ({ llmOptionProxy }) => {
  const chatGPTOptionSnap = useSnapshot(llmOptionProxy.chatGPT);
  const disableAll = reactExports.useCallback(() => {
    const switchable = [llmOptionProxy.chatGPT, llmOptionProxy.claude];
    switchable.forEach((it) => it.enabled = false);
  }, []);
  reactExports.useEffect(() => {
    const switchable = [llmOptionProxy.chatGPT, llmOptionProxy.claude];
    const available = switchable.filter((it) => it.available);
    const enabled = available.filter((it) => it.enabled);
    if (enabled.length > 1) {
      enabled.slice(1).forEach((e3) => e3.enabled = false);
    }
  }, [chatGPTOptionSnap]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-full select-none flex-col w-full before:bg-white before:bg-opacity-40\n         pt-1 pb-3 px-3 gap-1 before:backdrop-hack before:backdrop-blur before:rounded-xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center justify-between px-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-neutral-600 prose", children: "Large Language Model" }) }),
    chatGPTOptionSnap.available && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ChatGpt,
      {
        chatGPTOptionProxy: llmOptionProxy.chatGPT,
        setEnabled: (enabled) => {
          if (enabled) {
            disableAll();
          }
          llmOptionProxy.chatGPT.enabled = enabled;
        }
      }
    )
  ] });
};
const GoogleTTS = ({ googleTTSOptionProxy, setEnabled }) => {
  const googleTTSSnap = useSnapshot(googleTTSOptionProxy);
  const googleAbilitySnap = useSnapshot(appState.ability.tts.google);
  const [voiceChoices, setVoicesChoice] = reactExports.useState([]);
  const setGender = reactExports.useCallback((gender) => {
    googleTTSOptionProxy.gender = gender;
  }, []);
  const setLanguage = reactExports.useCallback((languageCode) => {
    googleTTSOptionProxy.languageCode = languageCode;
  }, []);
  reactExports.useEffect(() => {
    var _a;
    const lang = googleTTSSnap.languageCode;
    if (lang) {
      const filtered = _.filter(
        googleAbilitySnap.voices,
        (voice) => _.some(
          voice.tags,
          (tag) => tag.startsWith(lang) || lang.startsWith(tag)
        )
      ).map((v2) => ({
        name: v2.name,
        value: v2.id,
        tags: _.map(v2.tags, (tag) => tag)
      }));
      setVoicesChoice(filtered);
      if (!_.some(filtered, (v2) => v2.value === googleTTSOptionProxy.voiceId)) {
        googleTTSOptionProxy.voiceId = (_a = _.first(filtered)) == null ? void 0 : _a.value;
      }
    } else {
      setVoicesChoice([]);
    }
  }, [googleAbilitySnap, googleTTSSnap.languageCode]);
  const setVoice = reactExports.useCallback((voiceId) => {
    googleTTSOptionProxy.voiceId = voiceId;
  }, []);
  const setSpeakingRate = reactExports.useCallback((speakingRate) => {
    googleTTSOptionProxy.speakingRate = speakingRate;
  }, []);
  const setPitch = reactExports.useCallback((pitch) => {
    googleTTSOptionProxy.pitch = pitch;
  }, []);
  const setVolumeGainDb = reactExports.useCallback((volumeGainDb) => {
    googleTTSOptionProxy.volumeGainDb = volumeGainDb;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full items-center justify-between gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col justify-center gap-2 py-2 px-3 border-2 border-neutral-500 border-dashed\n                        rounded-lg w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "Google" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MySwitch, { enabled: googleTTSSnap.enabled, setEnabled })
        ] }),
        googleTTSSnap.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectBoxOrNotAvailable,
            {
              title: "Gender",
              choices: googleTTSAPIReference.gender.choices,
              defaultValue: googleTTSSnap.gender,
              setValue: setGender
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectBoxOrNotAvailable,
            {
              title: "Language",
              choices: googleTTSAPIReference.language.choices,
              defaultValue: googleTTSSnap.languageCode,
              setValue: setLanguage
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectBoxOrNotAvailable,
            {
              title: "Voice",
              choices: voiceChoices,
              defaultValue: googleTTSSnap.voiceId,
              setValue: setVoice
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Speaking Rate",
              defaultValue: googleTTSAPIReference.speakingRate.default,
              range: {
                start: googleTTSAPIReference.speakingRate.rangeStart,
                end: googleTTSAPIReference.speakingRate.rangeEnd
              },
              setValue: setSpeakingRate,
              value: googleTTSSnap.speakingRate
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Pitch",
              defaultValue: googleTTSAPIReference.pitch.default,
              range: {
                start: googleTTSAPIReference.pitch.rangeStart,
                end: googleTTSAPIReference.pitch.rangeEnd
              },
              setValue: setPitch,
              value: googleTTSSnap.pitch
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Volume Gain Db",
              defaultValue: googleTTSAPIReference.volumeGainDb.default,
              range: {
                start: googleTTSAPIReference.volumeGainDb.rangeStart,
                end: googleTTSAPIReference.volumeGainDb.rangeEnd
              },
              setValue: setVolumeGainDb,
              value: googleTTSSnap.volumeGainDb
            }
          )
        ] })
      ]
    }
  ) });
};
const ElevenlabsTTS = ({ elevenlabsTTSOptionProxy, setEnabled }) => {
  const elevenlabsTTSSnap = useSnapshot(elevenlabsTTSOptionProxy);
  const elevenlabsAbilitySnap = useSnapshot(appState.ability.tts.elevenlabs);
  const [voiceChoices, setVoicesChoice] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const voices = _.map(
      elevenlabsAbilitySnap.voices,
      (v2) => ({
        name: v2.name,
        value: v2.id,
        tags: _.uniq(v2.tags).map((tag) => tag)
      })
    );
    setVoicesChoice(voices);
  }, [elevenlabsAbilitySnap]);
  const setVoice = reactExports.useCallback((voiceId) => {
    elevenlabsTTSOptionProxy.voiceId = voiceId;
  }, []);
  const setStability = reactExports.useCallback((stability) => {
    elevenlabsTTSOptionProxy.stability = stability;
  }, []);
  const setClarity = reactExports.useCallback((clarity) => {
    elevenlabsTTSOptionProxy.clarity = clarity;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full items-center justify-between gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col justify-center gap-2 py-2 px-3 border-2 border-neutral-500 border-dashed\n                        rounded-lg w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "Elevenlabs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MySwitch, { enabled: elevenlabsTTSSnap.enabled, setEnabled })
        ] }),
        elevenlabsTTSSnap.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectBoxOrNotAvailable,
            {
              title: "Voice",
              choices: voiceChoices,
              defaultValue: elevenlabsTTSSnap.voiceId,
              setValue: setVoice
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Stability",
              defaultValue: elevenlabsAPIReference.stability.default,
              range: {
                start: elevenlabsAPIReference.stability.rangeStart,
                end: elevenlabsAPIReference.stability.rangeEnd
              },
              setValue: setStability,
              value: elevenlabsTTSSnap.stability
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderRange,
            {
              title: "Clarity",
              defaultValue: elevenlabsAPIReference.clarity.default,
              range: {
                start: elevenlabsAPIReference.clarity.rangeStart,
                end: elevenlabsAPIReference.clarity.rangeEnd
              },
              setValue: setClarity,
              value: elevenlabsTTSSnap.clarity
            }
          )
        ] })
      ]
    }
  ) });
};
const TTS = ({ ttsOptionProxy }) => {
  useSnapshot(ttsOptionProxy);
  const googleSnap = useSnapshot(ttsOptionProxy.google);
  const elevenlabsSnap = useSnapshot(ttsOptionProxy.elevenlabs);
  const disableAll = reactExports.useCallback(() => {
    const switchable = [ttsOptionProxy.google, ttsOptionProxy.elevenlabs];
    switchable.forEach((it) => it.enabled = false);
  }, []);
  reactExports.useEffect(() => {
    const switchable = [ttsOptionProxy.google, ttsOptionProxy.elevenlabs];
    const available = switchable.filter((it) => it.available);
    const enabled = available.filter((it) => it.enabled);
    if (enabled.length > 1) {
      enabled.slice(1).forEach((e3) => e3.enabled = false);
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-full select-none flex-col w-full before:bg-white before:bg-opacity-40\n         pt-1 pb-3  px-3 gap-1 before:backdrop-hack before:backdrop-blur before:rounded-xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center justify-between px-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-neutral-600 prose", children: "Text to Speech" }) }),
    googleSnap.available && /* @__PURE__ */ jsxRuntimeExports.jsx(
      GoogleTTS,
      {
        googleTTSOptionProxy: ttsOptionProxy.google,
        setEnabled: (enabled) => {
          if (enabled) {
            disableAll();
          }
          ttsOptionProxy.google.enabled = enabled;
        }
      }
    ),
    elevenlabsSnap.available && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ElevenlabsTTS,
      {
        elevenlabsTTSOptionProxy: ttsOptionProxy.elevenlabs,
        setEnabled: (enabled) => {
          if (enabled) {
            disableAll();
          }
          ttsOptionProxy.elevenlabs.enabled = enabled;
        }
      }
    )
  ] });
};
const Whisper = ({ whisperOptionProxy, setEnabled }) => {
  const whisperOptionSnap = useSnapshot(whisperOptionProxy);
  const whisperAbilitySnap = useSnapshot(appState.ability.stt.whisper);
  const setModel = reactExports.useCallback((model) => {
    whisperOptionProxy.model = model;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full items-center justify-between gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col justify-center gap-2 py-2 px-3 border-2 border-neutral-500 border-dashed\n                        rounded-lg w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "Whisper" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MySwitch, { enabled: whisperOptionSnap.enabled, setEnabled })
        ] }),
        whisperOptionSnap.enabled && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectBoxOrNotAvailable,
          {
            title: "Model",
            choices: _.map(whisperAbilitySnap.models, (m4) => ({
              name: m4,
              value: m4,
              tags: []
            })),
            defaultValue: whisperOptionSnap.model,
            setValue: setModel
          }
        ) })
      ]
    }
  ) });
};
const STT = ({ sttOptionProxy }) => {
  useSnapshot(sttOptionProxy);
  const whisperSnap = useSnapshot(sttOptionProxy.whisper);
  const disableAll = reactExports.useCallback(() => {
    const switchable = [sttOptionProxy.whisper];
    switchable.forEach((it) => it.enabled = false);
  }, []);
  reactExports.useEffect(() => {
    const switchable = [sttOptionProxy.whisper];
    const available = switchable.filter((it) => it.available);
    const enabled = available.filter((it) => it.enabled);
    if (enabled.length > 1) {
      enabled.slice(1).forEach((e3) => e3.enabled = false);
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-full select-none flex-col w-full before:bg-white before:bg-opacity-40\n         pt-1 pb-3 px-3 gap-1 before:backdrop-hack before:backdrop-blur before:rounded-xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center justify-between px-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-neutral-600 prose", children: "Text to Speech" }) }),
    whisperSnap.available && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Whisper,
      {
        whisperOptionProxy: sttOptionProxy.whisper,
        setEnabled: (enabled) => {
          if (enabled) {
            disableAll();
          }
          sttOptionProxy.whisper.enabled = enabled;
        }
      }
    )
  ] });
};
const OtherSetting$1 = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col w-full items-center justify-between gap-2 rounded-xl bg-white\n            bg-opacity-40 backdrop-blur pt-1 pb-3 px-3 ",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center w-full px-3 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "Other" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "flex flex-wrap justify-start items-center gap-2 py-2 border-2 border-neutral-500 border-dashed rounded-lg w-full px-3",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CountDownButton,
                {
                  text: "Clear All Chats",
                  countDownMs: 1e3,
                  color: "red",
                  action: clearChats,
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BsTrash3, { className: "text-lg" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ResetButton, { countDownMs: 2e3 })
            ]
          }
        )
      ]
    }
  );
};
const Global = ({ optionProxy }) => {
  useSnapshot(optionProxy);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-40 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LLM, { llmOptionProxy: optionProxy.llm }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-30 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TTS, { ttsOptionProxy: optionProxy.tts }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-20 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(STT, { sttOptionProxy: optionProxy.stt }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-10 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(OtherSetting$1, {}) })
  ] });
};
const OtherSetting = ({ chatProxy }) => {
  useSnapshot(chatProxy);
  const clearMessages = reactExports.useCallback(() => {
    chatProxy.messages = [];
  }, [chatProxy]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col w-full items-center justify-between gap-2 rounded-xl bg-white\n            bg-opacity-40 backdrop-blur pt-1 pb-3 px-3 ",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center w-full px-3 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-lg text-neutral-600", children: "Other" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex flex-wrap justify-start items-center gap-2 py-2 border-2 border-neutral-500 border-dashed rounded-lg w-full px-3",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CountDownButton,
              {
                text: "Clear Message",
                countDownMs: 1e3,
                color: "red",
                action: () => clearMessages(),
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BsTrash3, { className: "text-lg" })
              }
            )
          }
        )
      ]
    }
  );
};
const Current = ({ chatProxy }) => {
  useSnapshot(chatProxy);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-40 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LLM, { llmOptionProxy: chatProxy.option.llm }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-30 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TTS, { ttsOptionProxy: chatProxy.option.tts }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-20 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(STT, { sttOptionProxy: chatProxy.option.stt }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-10 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(OtherSetting, { chatProxy }) })
  ] });
};
const Panel = () => {
  const appSnap = useSnapshot(appState);
  const [chatProxy, setChatProxy] = reactExports.useState();
  reactExports.useEffect(() => {
    if (appSnap.currentChatId) {
      setChatProxy(appState.chats[appState.currentChatId]);
    }
  }, [appSnap.currentChatId, appSnap.chats]);
  const onMouseUp = reactExports.useCallback((p2) => {
    appState.panelSelection = p2;
  }, []);
  const onMouseDown = reactExports.useCallback((p2) => {
    appState.panelSelection = p2;
  }, []);
  const onMouseEnter = reactExports.useCallback((p2) => {
    if (controlState.isMouseLeftDown) {
      appState.panelSelection = p2;
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex h-full select-none flex-col gap-3 w-full",
      onKeyDown: escapeSpaceKey,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center rounded-xl font-medium min-h-12  gap-y-2\n            p-1 bg-white bg-opacity-40", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: cx(
                "flex w-1/3 justify-center items-center h-full rounded-lg transition-all duration-150",
                appSnap.panelSelection === "chats" ? "bg-white/[0.8]" : "hover:bg-white/[0.4]"
              ),
              onMouseUp: () => onMouseUp("chats"),
              onMouseDown: () => onMouseDown("chats"),
              onMouseEnter: () => onMouseEnter("chats"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center", children: "Chats" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: cx(
                "flex w-1/3 justify-center items-center h-full rounded-lg transition-all duration-150",
                appSnap.panelSelection === "global" ? "bg-white/[0.8]" : "hover:bg-white/[0.4]"
              ),
              onMouseUp: () => onMouseUp("global"),
              onMouseDown: () => onMouseDown("global"),
              onMouseEnter: () => onMouseEnter("global"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center", children: "Setting" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: cx(
                "flex w-1/3 justify-center items-center h-full rounded-lg transition-all duration-150",
                appSnap.currentChatId === "" ? "hidden" : "",
                appSnap.panelSelection === "current" ? "bg-white bg-opacity-80" : "hover:bg-white/[0.4]"
              ),
              onMouseUp: () => onMouseUp("current"),
              onMouseDown: () => onMouseDown("current"),
              onMouseEnter: () => onMouseEnter("current"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center", children: "Current" })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "flex flex-col gap-y-3 items-center overflow-y-auto pr-1",
            children: [
              appSnap.panelSelection === "chats" && /* @__PURE__ */ jsxRuntimeExports.jsx(ChatList, {}),
              appSnap.panelSelection === "global" && /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { optionProxy: appState.option }),
              appSnap.panelSelection === "current" && chatProxy && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Current, { chatProxy }) })
            ]
          }
        )
      ]
    }
  );
};
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13:
            discardTrailingNewline = true;
          case 10:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field) {
        case "data":
          message.data = message.data ? message.data + "\n" + value : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          const retry = parseInt(value, 10);
          if (!isNaN(retry)) {
            onRetry(message.retry = retry);
          }
          break;
      }
    }
  };
}
function concat(a4, b3) {
  const res = new Uint8Array(a4.length + b3.length);
  res.set(a4);
  res.set(b3, a4.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var __rest = globalThis && globalThis.__rest || function(s5, e3) {
  var t4 = {};
  for (var p2 in s5)
    if (Object.prototype.hasOwnProperty.call(s5, p2) && e3.indexOf(p2) < 0)
      t4[p2] = s5[p2];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s5); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p2[i3]))
        t4[p2[i3]] = s5[p2[i3]];
    }
  return t4;
};
const EventStreamContentType = "text/event-stream";
const DefaultRetryInterval = 1e3;
const LastEventId = "last-event-id";
function fetchEventSource(input, _a) {
  var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((resolve, reject) => {
    const headers = Object.assign({}, inputHeaders);
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer = 0;
    function dispose() {
      document.removeEventListener("visibilitychange", onVisibilityChange);
      window.clearTimeout(retryTimer);
      curRequestController.abort();
    }
    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const fetch2 = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
    const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
    async function create() {
      var _a2;
      curRequestController = new AbortController();
      try {
        const response = await fetch2(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
        await onopen(response);
        await getBytes(response.body, getLines(getMessages((id2) => {
          if (id2) {
            headers[LastEventId] = id2;
          } else {
            delete headers[LastEventId];
          }
        }, (retry) => {
          retryInterval = retry;
        }, onmessage)));
        onclose === null || onclose === void 0 ? void 0 : onclose();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController.signal.aborted) {
          try {
            const interval = (_a2 = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a2 !== void 0 ? _a2 : retryInterval;
            window.clearTimeout(retryTimer);
            retryTimer = window.setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
  }
}
const EventMessageThinking = "message/thinking";
const EventMessageTextTyping = "message/text/typing";
const EventMessageTextEOF = "message/text/EOF";
const EventMessageAudio = "message/audio";
const EventMessageError = "message/error";
const EventSystemAbility = "system/ability";
const SSE = () => {
  const networkSnp = useSnapshot(networkState);
  const authSnp = useSnapshot(appState.auth);
  reactExports.useEffect(() => {
    const ep = SSEEndpoint();
    const url = ep + "?stream=" + networkState.streamId;
    console.info("connecting to SSE: ", url);
    const ctrl = new AbortController();
    fetchEventSource(url, {
      signal: ctrl.signal,
      headers: {
        "Authorization": "Bearer " + appState.auth.passwordHash
      },
      keepalive: true,
      onopen: async (response) => {
        console.info("EventSource connected to server, response: ", response);
      },
      onmessage: (msg) => {
        console.debug("received an msg from SSE server", msg.event, msg.data.slice(0, 500));
        const data = JSON.parse(msg.data);
        if (msg.event === EventSystemAbility) {
          const sa2 = data;
          adjustOption(appState.option, sa2);
          appState.ability = sa2;
          return;
        }
        const chatId = data.chatId;
        const chatProxy = appState.chats[chatId];
        if (!chatProxy) {
          console.warn("received an event from server, but can't find a chat to deal with, this usually happens when a chat has been deleted, or this would be fatal err that requires our developers to re-check the code. chatId:", chatId);
          return;
        }
        const meta = data;
        if (msg.event === EventMessageThinking) {
          const message = newThinking(meta.messageID);
          chatProxy.messages.push(message);
        } else if (msg.event == EventMessageTextTyping) {
          const found = findMessage(chatProxy, meta.messageID);
          if (!found) {
            console.info("can't find a message to deal with, skipping... chatId,messageId: ", chatId, meta.messageID);
            return;
          }
          const text = data;
          onTyping(found, text.text);
        } else if (msg.event == EventMessageTextEOF) {
          const found = findMessage(chatProxy, meta.messageID);
          if (!found) {
            console.info("can't find a message to deal with, skipping... chatId,messageId: ", chatId, meta.messageID);
            return;
          }
          const text = data;
          onEOF(found, text.text ?? "");
        } else if (msg.event == EventMessageAudio) {
          const found = findMessage(chatProxy, meta.messageID);
          if (!found) {
            console.info("can't find a message to deal with, skipping... chatId,messageId: ", chatId, meta.messageID);
            return;
          }
          const audio = data;
          const blob = base64ToBlob(audio.audio, audioPlayerMimeType);
          const audioId = formatNow() + "-" + randomHash16Char();
          audioDb.setItem(audioId, blob, () => {
            onAudio(found, { id: audioId, durationMs: audio.durationMs });
          });
        } else if (msg.event === EventMessageError) {
          const found = findMessage(chatProxy, meta.messageID);
          if (!found) {
            console.info("can't find a message to deal with, skipping... chatId,messageId: ", chatId, meta.messageID);
            return;
          }
          const error = data;
          onError(found, error.errMsg);
        } else {
          console.warn("unknown event type:", msg.event);
        }
      },
      onerror: (err) => {
        console.error("SSE error:", err);
      }
    });
    return () => {
      ctrl.abort("reconnecting");
    };
  }, [networkSnp, authSnp]);
  return null;
};
const historyMessages = (chat, maxHistory) => {
  if (maxHistory <= 0) {
    return [];
  }
  const messages = [];
  for (let i3 = chat.messages.length - 1; i3 >= 0; i3--) {
    if (messages.length === maxHistory) {
      break;
    }
    const m4 = chat.messages[i3];
    if (isInHistory(m4)) {
      messages.push({ role: m4.role, content: m4.text });
    }
  }
  return messages.reverse();
};
const systemMessage = {
  role: "system",
  content: "You are a helpful assistant!"
};
const SubscribeSendingMessage = () => {
  var _a;
  const controlSnp = useSnapshot(controlState);
  reactExports.useEffect(() => {
    var _a2;
    if (controlState.sendingMessages.length === 0) {
      return;
    }
    const [sm] = controlState.sendingMessages.splice(0, 1);
    if (!sm) {
      return;
    }
    controlState.sendingMessageSignal++;
    if (sm.audioBlob) {
      if (sm.durationMs < minSpeakTimeMillis) {
        console.info("audio is less than ms", minSpeakTimeMillis);
        return;
      }
    }
    const chatProxy = appState.chats[sm.chatId];
    if (!chatProxy) {
      console.warn("chat does exist any more, chatId:", sm.chatId);
      return;
    }
    const option = snapshot(chatProxy.option);
    let messages = historyMessages(chatProxy, option.llm.maxHistory);
    messages = [systemMessage, ...messages];
    const message = newSending();
    const talkOption = toRestfulAPIOption(option);
    let postPromise;
    if (sm.audioBlob) {
      console.debug("sending audio and chat: ", message);
      message.audio = { id: "" };
      chatProxy.messages.push(message);
      postPromise = postAudioChat(sm.audioBlob, ((_a2 = controlSnp.recordingMimeType) == null ? void 0 : _a2.fileName) ?? "audio.webm", {
        chatId: chatProxy.id,
        ticketId: randomHash16Char(),
        ms: messages,
        talkOption
      });
    } else {
      messages.push({ role: "user", content: sm.text });
      console.debug("sending chat: ", messages);
      chatProxy.messages.push(message);
      postPromise = postChat({
        chatId: chatProxy.id,
        ticketId: randomHash16Char(),
        ms: messages,
        talkOption
      });
    }
    postPromise.then(
      (r3) => {
        if (r3.status >= 200 && r3.status < 300) {
          onSent(message);
        } else {
          onError(message, "Failed to send, reason:" + r3.statusText);
        }
      }
    ).catch((e3) => {
      onError(message, "Failed to send, reason:" + e3.message);
    });
    if (sm.audioBlob) {
      const audioId = randomHash16Char();
      audioDb.setItem(audioId, sm.audioBlob, () => console.debug("saved audio blob, audioId:", audioId));
    }
  }, [(_a = controlSnp.recordingMimeType) == null ? void 0 : _a.fileName, controlSnp.sendingMessageSignal]);
  return null;
};
const TimeoutContentDetection = () => {
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      const chats = appState.chats;
      for (const entry of Object.entries(chats)) {
        for (const message of entry[1].messages.slice(-60)) {
          setErrorIfTimeout(message);
        }
      }
    }, 2e3);
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, []);
  return null;
};
const Workers = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SubscribeSendingMessage, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TimeoutContentDetection, {})
  ] });
};
const WindowListeners = () => {
  const setMouseDown = reactExports.useCallback((isMouseLeftDown) => {
    controlState.isMouseLeftDown = isMouseLeftDown;
  }, []);
  const recorder = controlState.recorder;
  reactExports.useEffect(
    () => {
      const handleKeyUp = (event) => {
        var _a;
        if (event.key == " " && ((_a = recorder.currentContext()) == null ? void 0 : _a.triggeredBy) === "spacebar") {
          recorder.done();
        }
      };
      const handleKeyDown = (event) => {
        var _a, _b;
        if (event.key === " ") {
          if (event.repeat) {
            console.debug("handleKeyDown skip repeated space");
            return;
          }
          if (!((_a = recorder.currentContext()) == null ? void 0 : _a.triggeredBy)) {
            console.debug("handleKeyDown with not repeated space");
            recorder.start({ triggeredBy: "spacebar" }).catch((e3) => {
              console.error("failed to start recorder", e3);
            });
          }
        } else {
          if (((_b = recorder.currentContext()) == null ? void 0 : _b.triggeredBy) === "spacebar") {
            recorder.cancel();
          }
        }
      };
      const handleMouseDown = (event) => {
        if (event.button === 0) {
          setMouseDown(true);
          console.debug("mouse left is down");
        }
      };
      const handleMouseUp = (event) => {
        if (event.button === 0) {
          setMouseDown(false);
          console.debug("mouse left is up");
        }
      };
      const handleBrowserBlur = () => {
        setMouseDown(false);
      };
      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);
      window.addEventListener("mousedown", handleMouseDown);
      window.addEventListener("mouseup", handleMouseUp);
      window.addEventListener("blur", handleBrowserBlur);
      return () => {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
        window.removeEventListener("mousedown", handleMouseDown);
        window.removeEventListener("mouseup", handleMouseUp);
        window.removeEventListener("blur", handleBrowserBlur);
      };
    },
    [setMouseDown, recorder]
  );
  return null;
};
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function decode(audioData, sampleRate) {
  return __awaiter$2(this, void 0, void 0, function* () {
    const audioCtx = new AudioContext({ sampleRate });
    const decode2 = audioCtx.decodeAudioData(audioData);
    return decode2.finally(() => audioCtx.close());
  });
}
function normalize(channelData) {
  const firstChannel = channelData[0];
  if (firstChannel.some((n2) => n2 > 1 || n2 < -1)) {
    const length = firstChannel.length;
    let max = 0;
    for (let i3 = 0; i3 < length; i3++) {
      const absN = Math.abs(firstChannel[i3]);
      if (absN > max)
        max = absN;
    }
    for (const channel of channelData) {
      for (let i3 = 0; i3 < length; i3++) {
        channel[i3] /= max;
      }
    }
  }
  return channelData;
}
function createBuffer(channelData, duration) {
  if (typeof channelData[0] === "number")
    channelData = [channelData];
  normalize(channelData);
  return {
    duration,
    length: channelData[0].length,
    sampleRate: channelData[0].length / duration,
    numberOfChannels: channelData.length,
    getChannelData: (i3) => channelData === null || channelData === void 0 ? void 0 : channelData[i3],
    copyFromChannel: AudioBuffer.prototype.copyFromChannel,
    copyToChannel: AudioBuffer.prototype.copyToChannel
  };
}
const Decoder = {
  decode,
  createBuffer
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function fetchBlob(url, progressCallback, requestInit) {
  var _a, _b;
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield fetch(url, requestInit);
    {
      const reader = (_a = response.clone().body) === null || _a === void 0 ? void 0 : _a.getReader();
      const contentLength = Number((_b = response.headers) === null || _b === void 0 ? void 0 : _b.get("Content-Length"));
      let receivedLength = 0;
      const processChunk = (done, value) => __awaiter$1(this, void 0, void 0, function* () {
        if (done)
          return;
        receivedLength += (value === null || value === void 0 ? void 0 : value.length) || 0;
        const percentage = Math.round(receivedLength / contentLength * 100);
        progressCallback(percentage);
        return reader === null || reader === void 0 ? void 0 : reader.read().then(({ done: done2, value: value2 }) => processChunk(done2, value2));
      });
      reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));
    }
    return response.blob();
  });
}
const Fetcher = {
  fetchBlob
};
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
  /** Subscribe to an event. Returns an unsubscribe function. */
  on(eventName, listener) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = /* @__PURE__ */ new Set();
    }
    this.listeners[eventName].add(listener);
    return () => this.un(eventName, listener);
  }
  /** Subscribe to an event only once */
  once(eventName, listener) {
    const unsubscribe = this.on(eventName, listener);
    const unsubscribeOnce = this.on(eventName, () => {
      unsubscribe();
      unsubscribeOnce();
    });
    return unsubscribe;
  }
  /** Unsubscribe from an event */
  un(eventName, listener) {
    if (this.listeners[eventName]) {
      if (listener) {
        this.listeners[eventName].delete(listener);
      } else {
        delete this.listeners[eventName];
      }
    }
  }
  /** Clear all events */
  unAll() {
    this.listeners = {};
  }
  /** Emit an event */
  emit(eventName, ...args) {
    if (this.listeners[eventName]) {
      this.listeners[eventName].forEach((listener) => listener(...args));
    }
  }
}
class Player extends EventEmitter {
  constructor(options) {
    super();
    if (options.media) {
      this.media = options.media;
    } else {
      this.media = document.createElement("audio");
    }
    if (options.mediaControls) {
      this.media.controls = true;
    }
    if (options.autoplay) {
      this.media.autoplay = true;
    }
    if (options.playbackRate != null) {
      this.onceMediaEvent("canplay", () => {
        if (options.playbackRate != null) {
          this.media.playbackRate = options.playbackRate;
        }
      });
    }
  }
  onMediaEvent(event, callback, options) {
    this.media.addEventListener(event, callback, options);
    return () => this.media.removeEventListener(event, callback);
  }
  onceMediaEvent(event, callback) {
    return this.onMediaEvent(event, callback, { once: true });
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const src = this.getSrc();
    if (src.startsWith("blob:")) {
      URL.revokeObjectURL(src);
    }
  }
  setSrc(url, blob) {
    const src = this.getSrc();
    if (src === url)
      return;
    this.revokeSrc();
    const newSrc = blob instanceof Blob ? URL.createObjectURL(blob) : url;
    this.media.src = newSrc;
    this.media.load();
  }
  destroy() {
    this.media.pause();
    this.revokeSrc();
    this.media.src = "";
    this.media.load();
  }
  /** Start playing the audio */
  play() {
    return this.media.play();
  }
  /** Pause the audio */
  pause() {
    this.media.pause();
  }
  /** Check if the audio is playing */
  isPlaying() {
    return this.media.currentTime > 0 && !this.media.paused && !this.media.ended;
  }
  /** Jumpt to a specific time in the audio (in seconds) */
  setTime(time) {
    this.media.currentTime = time;
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    return this.media.duration;
  }
  /** Get the current audio position in seconds */
  getCurrentTime() {
    return this.media.currentTime;
  }
  /** Get the audio volume */
  getVolume() {
    return this.media.volume;
  }
  /** Set the audio volume */
  setVolume(volume) {
    this.media.volume = volume;
  }
  /** Get the audio muted state */
  getMuted() {
    return this.media.muted;
  }
  /** Mute or unmute the audio */
  setMuted(muted) {
    this.media.muted = muted;
  }
  /** Get the playback speed */
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  /** Set the playback speed, pass an optional false to NOT preserve the pitch */
  setPlaybackRate(rate, preservePitch) {
    if (preservePitch != null) {
      this.media.preservesPitch = preservePitch;
    }
    this.media.playbackRate = rate;
  }
  /** Get the HTML media element */
  getMediaElement() {
    return this.media;
  }
  /** Set a sink id to change the audio output device */
  setSinkId(sinkId) {
    const media = this.media;
    return media.setSinkId(sinkId);
  }
}
function makeDraggable(element, onDrag, onStart, onEnd, threshold = 5) {
  let unsub = () => {
    return;
  };
  if (!element)
    return unsub;
  const down = (e3) => {
    if (e3.button === 2)
      return;
    e3.preventDefault();
    e3.stopPropagation();
    let startX = e3.clientX;
    let startY = e3.clientY;
    let isDragging = false;
    const move = (e4) => {
      e4.preventDefault();
      e4.stopPropagation();
      const x2 = e4.clientX;
      const y4 = e4.clientY;
      if (isDragging || Math.abs(x2 - startX) >= threshold || Math.abs(y4 - startY) >= threshold) {
        const { left, top } = element.getBoundingClientRect();
        if (!isDragging) {
          isDragging = true;
          onStart === null || onStart === void 0 ? void 0 : onStart(startX - left, startY - top);
        }
        onDrag(x2 - startX, y4 - startY, x2 - left, y4 - top);
        startX = x2;
        startY = y4;
      }
    };
    const click = (e4) => {
      if (isDragging) {
        e4.preventDefault();
        e4.stopPropagation();
      }
    };
    const up = () => {
      if (isDragging) {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      }
      unsub();
    };
    document.addEventListener("pointermove", move);
    document.addEventListener("pointerup", up);
    document.addEventListener("pointerleave", up);
    document.addEventListener("click", click, true);
    unsub = () => {
      document.removeEventListener("pointermove", move);
      document.removeEventListener("pointerup", up);
      document.removeEventListener("pointerleave", up);
      setTimeout(() => {
        document.removeEventListener("click", click, true);
      }, 10);
    };
  };
  element.addEventListener("pointerdown", down);
  return () => {
    unsub();
    element.removeEventListener("pointerdown", down);
  };
}
class Renderer extends EventEmitter {
  constructor(options, audioElement) {
    super();
    this.timeouts = [];
    this.isScrolling = false;
    this.audioData = null;
    this.resizeObserver = null;
    this.isDragging = false;
    this.options = options;
    let parent;
    if (typeof options.container === "string") {
      parent = document.querySelector(options.container);
    } else if (options.container instanceof HTMLElement) {
      parent = options.container;
    }
    if (!parent) {
      throw new Error("Container not found");
    }
    this.parent = parent;
    const [div, shadow] = this.initHtml();
    parent.appendChild(div);
    this.container = div;
    this.scrollContainer = shadow.querySelector(".scroll");
    this.wrapper = shadow.querySelector(".wrapper");
    this.canvasWrapper = shadow.querySelector(".canvases");
    this.progressWrapper = shadow.querySelector(".progress");
    this.cursor = shadow.querySelector(".cursor");
    if (audioElement) {
      shadow.appendChild(audioElement);
    }
    this.initEvents();
  }
  initEvents() {
    this.wrapper.addEventListener("click", (e3) => {
      const rect = this.wrapper.getBoundingClientRect();
      const x2 = e3.clientX - rect.left;
      const relativeX = x2 / rect.width;
      this.emit("click", relativeX);
    });
    if (this.options.dragToSeek) {
      this.initDrag();
    }
    this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;
      const startX = scrollLeft / scrollWidth;
      const endX = (scrollLeft + clientWidth) / scrollWidth;
      this.emit("scroll", startX, endX);
    });
    const delay2 = this.createDelay(100);
    this.resizeObserver = new ResizeObserver(() => {
      delay2(() => this.reRender());
    });
    this.resizeObserver.observe(this.scrollContainer);
  }
  initDrag() {
    makeDraggable(
      this.wrapper,
      // On drag
      (_2, __, x2) => {
        this.emit("drag", Math.max(0, Math.min(1, x2 / this.wrapper.getBoundingClientRect().width)));
      },
      // On start drag
      () => this.isDragging = true,
      // On end drag
      () => this.isDragging = false
    );
  }
  getHeight() {
    const defaultHeight = 128;
    if (this.options.height == null)
      return defaultHeight;
    if (!isNaN(Number(this.options.height)))
      return Number(this.options.height);
    if (this.options.height === "auto")
      return this.parent.clientHeight || defaultHeight;
    return defaultHeight;
  }
  initHtml() {
    const div = document.createElement("div");
    const shadow = div.attachShadow({ mode: "open" });
    shadow.innerHTML = `
      <style>
        :host {
          user-select: none;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
          touch-action: none;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight()}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper">
          <div class="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `;
    return [div, shadow];
  }
  setOptions(options) {
    this.options = options;
    this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  destroy() {
    var _a;
    this.container.remove();
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  createDelay(delayMs = 10) {
    const context = {};
    this.timeouts.push(context);
    return (callback) => {
      context.timeout && clearTimeout(context.timeout);
      context.timeout = setTimeout(callback, delayMs);
    };
  }
  // Convert array of color values to linear gradient
  convertColorValues(color2) {
    if (!Array.isArray(color2))
      return color2 || "";
    if (color2.length < 2)
      return color2[0] || "";
    const canvasElement = document.createElement("canvas");
    const ctx = canvasElement.getContext("2d");
    const gradient = ctx.createLinearGradient(0, 0, 0, canvasElement.height);
    const colorStopPercentage = 1 / (color2.length - 1);
    color2.forEach((color3, index2) => {
      const offset = index2 * colorStopPercentage;
      gradient.addColorStop(offset, color3);
    });
    return gradient;
  }
  renderBarWaveform(channelData, options, ctx, vScale) {
    const topChannel = channelData[0];
    const bottomChannel = channelData[1] || channelData[0];
    const length = topChannel.length;
    const { width, height } = ctx.canvas;
    const halfHeight = height / 2;
    const pixelRatio = window.devicePixelRatio || 1;
    const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;
    const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;
    const barRadius = options.barRadius || 0;
    const barIndexScale = width / (barWidth + barGap) / length;
    const rectFn = barRadius && "roundRect" in ctx ? "roundRect" : "rect";
    ctx.beginPath();
    let prevX = 0;
    let maxTop = 0;
    let maxBottom = 0;
    for (let i3 = 0; i3 <= length; i3++) {
      const x2 = Math.round(i3 * barIndexScale);
      if (x2 > prevX) {
        const topBarHeight = Math.round(maxTop * halfHeight * vScale);
        const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);
        const barHeight = topBarHeight + bottomBarHeight || 1;
        let y4 = halfHeight - topBarHeight;
        if (options.barAlign === "top") {
          y4 = 0;
        } else if (options.barAlign === "bottom") {
          y4 = height - barHeight;
        }
        ctx[rectFn](prevX * (barWidth + barGap), y4, barWidth, barHeight, barRadius);
        prevX = x2;
        maxTop = 0;
        maxBottom = 0;
      }
      const magnitudeTop = Math.abs(topChannel[i3] || 0);
      const magnitudeBottom = Math.abs(bottomChannel[i3] || 0);
      if (magnitudeTop > maxTop)
        maxTop = magnitudeTop;
      if (magnitudeBottom > maxBottom)
        maxBottom = magnitudeBottom;
    }
    ctx.fill();
    ctx.closePath();
  }
  renderLineWaveform(channelData, _options, ctx, vScale) {
    const drawChannel = (index2) => {
      const channel = channelData[index2] || channelData[0];
      const length = channel.length;
      const { height } = ctx.canvas;
      const halfHeight = height / 2;
      const hScale = ctx.canvas.width / length;
      ctx.moveTo(0, halfHeight);
      let prevX = 0;
      let max = 0;
      for (let i3 = 0; i3 <= length; i3++) {
        const x2 = Math.round(i3 * hScale);
        if (x2 > prevX) {
          const h4 = Math.round(max * halfHeight * vScale) || 1;
          const y4 = halfHeight + h4 * (index2 === 0 ? -1 : 1);
          ctx.lineTo(prevX, y4);
          prevX = x2;
          max = 0;
        }
        const value = Math.abs(channel[i3] || 0);
        if (value > max)
          max = value;
      }
      ctx.lineTo(prevX, halfHeight);
    };
    ctx.beginPath();
    drawChannel(0);
    drawChannel(1);
    ctx.fill();
    ctx.closePath();
  }
  renderWaveform(channelData, options, ctx) {
    ctx.fillStyle = this.convertColorValues(options.waveColor);
    if (options.renderFunction) {
      options.renderFunction(channelData, ctx);
      return;
    }
    let vScale = options.barHeight || 1;
    if (options.normalize) {
      const max = Array.from(channelData[0]).reduce((max2, value) => Math.max(max2, Math.abs(value)), 0);
      vScale = max ? 1 / max : 1;
    }
    if (options.barWidth || options.barGap || options.barAlign) {
      this.renderBarWaveform(channelData, options, ctx, vScale);
      return;
    }
    this.renderLineWaveform(channelData, options, ctx, vScale);
  }
  renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {
    const pixelRatio = window.devicePixelRatio || 1;
    const canvas = document.createElement("canvas");
    const length = channelData[0].length;
    canvas.width = Math.round(width * (end - start) / length);
    canvas.height = height * pixelRatio;
    canvas.style.width = `${Math.floor(canvas.width / pixelRatio)}px`;
    canvas.style.height = `${height}px`;
    canvas.style.left = `${Math.floor(start * width / pixelRatio / length)}px`;
    canvasContainer.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    this.renderWaveform(channelData.map((channel) => channel.slice(start, end)), options, ctx);
    const progressCanvas = canvas.cloneNode();
    progressContainer.appendChild(progressCanvas);
    const progressCtx = progressCanvas.getContext("2d");
    if (canvas.width > 0 && canvas.height > 0) {
      progressCtx.drawImage(canvas, 0, 0);
    }
    progressCtx.globalCompositeOperation = "source-in";
    progressCtx.fillStyle = this.convertColorValues(options.progressColor);
    progressCtx.fillRect(0, 0, canvas.width, canvas.height);
  }
  renderChannel(channelData, options, width) {
    const canvasContainer = document.createElement("div");
    const height = this.getHeight();
    canvasContainer.style.height = `${height}px`;
    this.canvasWrapper.style.minHeight = `${height}px`;
    this.canvasWrapper.appendChild(canvasContainer);
    const progressContainer = canvasContainer.cloneNode();
    this.progressWrapper.appendChild(progressContainer);
    const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;
    const len = channelData[0].length;
    const scale2 = len / scrollWidth;
    let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);
    if (options.barWidth || options.barGap) {
      const barWidth = options.barWidth || 0.5;
      const barGap = options.barGap || barWidth / 2;
      const totalBarWidth = barWidth + barGap;
      if (viewportWidth % totalBarWidth !== 0) {
        viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;
      }
    }
    const start = Math.floor(Math.abs(scrollLeft) * scale2);
    const end = Math.floor(start + viewportWidth * scale2);
    const viewportLen = end - start;
    const draw = (start2, end2) => {
      this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start2), Math.min(end2, len), canvasContainer, progressContainer);
    };
    const headDelay = this.createDelay();
    const tailDelay = this.createDelay();
    const renderHead = (fromIndex, toIndex) => {
      draw(fromIndex, toIndex);
      if (fromIndex > 0) {
        headDelay(() => {
          renderHead(fromIndex - viewportLen, toIndex - viewportLen);
        });
      }
    };
    const renderTail = (fromIndex, toIndex) => {
      draw(fromIndex, toIndex);
      if (toIndex < len) {
        tailDelay(() => {
          renderTail(fromIndex + viewportLen, toIndex + viewportLen);
        });
      }
    };
    renderHead(start, end);
    if (end < len) {
      renderTail(end, end + viewportLen);
    }
  }
  render(audioData) {
    this.timeouts.forEach((context) => context.timeout && clearTimeout(context.timeout));
    this.timeouts = [];
    this.canvasWrapper.innerHTML = "";
    this.progressWrapper.innerHTML = "";
    this.wrapper.style.width = "";
    const pixelRatio = window.devicePixelRatio || 1;
    const parentWidth = this.scrollContainer.clientWidth;
    const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));
    this.isScrolling = scrollWidth > parentWidth;
    const useParentWidth = this.options.fillParent && !this.isScrolling;
    const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;
    this.wrapper.style.width = useParentWidth ? "100%" : `${scrollWidth}px`;
    this.scrollContainer.style.overflowX = this.isScrolling ? "auto" : "hidden";
    this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar);
    this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;
    this.cursor.style.width = `${this.options.cursorWidth}px`;
    if (this.options.splitChannels) {
      for (let i3 = 0; i3 < audioData.numberOfChannels; i3++) {
        const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i3]);
        this.renderChannel([audioData.getChannelData(i3)], options, width);
      }
    } else {
      const channels = [audioData.getChannelData(0)];
      if (audioData.numberOfChannels > 1)
        channels.push(audioData.getChannelData(1));
      this.renderChannel(channels, this.options, width);
    }
    this.audioData = audioData;
    this.emit("render");
  }
  reRender() {
    if (!this.audioData)
      return;
    const oldCursorPosition = this.progressWrapper.clientWidth;
    this.render(this.audioData);
    const newCursortPosition = this.progressWrapper.clientWidth;
    this.scrollContainer.scrollLeft += newCursortPosition - oldCursorPosition;
  }
  zoom(minPxPerSec) {
    this.options.minPxPerSec = minPxPerSec;
    this.reRender();
  }
  scrollIntoView(progress2, isPlaying = false) {
    const { clientWidth, scrollLeft, scrollWidth } = this.scrollContainer;
    const progressWidth = scrollWidth * progress2;
    const center = clientWidth / 2;
    const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;
    if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {
      if (this.options.autoCenter && !this.isDragging) {
        const minDiff = center / 20;
        if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {
          this.scrollContainer.scrollLeft += minDiff;
        } else {
          this.scrollContainer.scrollLeft = progressWidth - center;
        }
      } else if (this.isDragging) {
        const gap = 10;
        this.scrollContainer.scrollLeft = progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;
      } else {
        this.scrollContainer.scrollLeft = progressWidth;
      }
    }
    {
      const { scrollLeft: scrollLeft2 } = this.scrollContainer;
      const startX = scrollLeft2 / scrollWidth;
      const endX = (scrollLeft2 + clientWidth) / scrollWidth;
      this.emit("scroll", startX, endX);
    }
  }
  renderProgress(progress2, isPlaying) {
    if (isNaN(progress2))
      return;
    this.progressWrapper.style.width = `${progress2 * 100}%`;
    this.cursor.style.left = `${progress2 * 100}%`;
    this.cursor.style.marginLeft = Math.round(progress2 * 100) === 100 ? `-${this.options.cursorWidth}px` : "";
    if (this.isScrolling && this.options.autoScroll) {
      this.scrollIntoView(progress2, isPlaying);
    }
  }
}
Renderer.MAX_CANVAS_WIDTH = 4e3;
class Timer extends EventEmitter {
  constructor() {
    super(...arguments);
    this.unsubscribe = () => void 0;
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    });
    this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const defaultOptions = {
  waveColor: "#999",
  progressColor: "#555",
  cursorWidth: 1,
  minPxPerSec: 0,
  fillParent: true,
  interact: true,
  dragToSeek: false,
  autoScroll: true,
  autoCenter: true,
  sampleRate: 8e3
};
class WaveSurfer extends Player {
  /** Create a new WaveSurfer instance */
  static create(options) {
    return new WaveSurfer(options);
  }
  /** Create a new WaveSurfer instance */
  constructor(options) {
    var _a, _b;
    super({
      media: options.media,
      mediaControls: options.mediaControls,
      autoplay: options.autoplay,
      playbackRate: options.audioRate
    });
    this.plugins = [];
    this.decodedData = null;
    this.subscriptions = [];
    this.options = Object.assign({}, defaultOptions, options);
    this.timer = new Timer();
    const audioElement = !options.media ? this.getMediaElement() : void 0;
    this.renderer = new Renderer(this.options, audioElement);
    this.initPlayerEvents();
    this.initRendererEvents();
    this.initTimerEvents();
    this.initPlugins();
    const url = this.options.url || ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.currentSrc) || ((_b = this.options.media) === null || _b === void 0 ? void 0 : _b.src);
    if (url) {
      this.load(url, this.options.peaks, this.options.duration);
    }
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      const currentTime = this.getCurrentTime();
      this.renderer.renderProgress(currentTime / this.getDuration(), true);
      this.emit("timeupdate", currentTime);
      this.emit("audioprocess", currentTime);
    }));
  }
  initPlayerEvents() {
    this.subscriptions.push(this.onMediaEvent("timeupdate", () => {
      const currentTime = this.getCurrentTime();
      this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());
      this.emit("timeupdate", currentTime);
    }), this.onMediaEvent("play", () => {
      this.emit("play");
      this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause");
      this.timer.stop();
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop();
    }), this.onMediaEvent("ended", () => {
      this.emit("finish");
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(
      // Seek on click
      this.renderer.on("click", (relativeX) => {
        if (this.options.interact) {
          this.seekTo(relativeX);
          this.emit("interaction", relativeX * this.getDuration());
          this.emit("click", relativeX);
        }
      }),
      // Scroll
      this.renderer.on("scroll", (startX, endX) => {
        const duration = this.getDuration();
        this.emit("scroll", startX * duration, endX * duration);
      }),
      // Redraw
      this.renderer.on("render", () => {
        this.emit("redraw");
      })
    );
    {
      let debounce2;
      this.subscriptions.push(this.renderer.on("drag", (relativeX) => {
        if (!this.options.interact)
          return;
        this.renderer.renderProgress(relativeX);
        clearTimeout(debounce2);
        debounce2 = setTimeout(() => {
          this.seekTo(relativeX);
        }, this.isPlaying() ? 0 : 200);
        this.emit("interaction", relativeX * this.getDuration());
        this.emit("drag", relativeX);
      }));
    }
  }
  initPlugins() {
    var _a;
    if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length))
      return;
    this.options.plugins.forEach((plugin) => {
      this.registerPlugin(plugin);
    });
  }
  /** Set new wavesurfer options and re-render it */
  setOptions(options) {
    this.options = Object.assign({}, this.options, options);
    this.renderer.setOptions(this.options);
    if (options.audioRate) {
      this.setPlaybackRate(options.audioRate);
    }
    if (options.mediaControls != null) {
      this.getMediaElement().controls = options.mediaControls;
    }
  }
  /** Register a wavesurfer.js plugin */
  registerPlugin(plugin) {
    plugin.init(this);
    this.plugins.push(plugin);
    this.subscriptions.push(plugin.once("destroy", () => {
      this.plugins = this.plugins.filter((p2) => p2 !== plugin);
    }));
    return plugin;
  }
  /** For plugins only: get the waveform wrapper div */
  getWrapper() {
    return this.renderer.getWrapper();
  }
  /** Get the current scroll position in pixels */
  getScroll() {
    return this.renderer.getScroll();
  }
  /** Get all registered plugins */
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(url, blob, channelData, duration) {
    return __awaiter(this, void 0, void 0, function* () {
      this.emit("load", url);
      if (this.isPlaying())
        this.pause();
      this.decodedData = null;
      if (!blob && !channelData) {
        const onProgress = (percentage) => this.emit("loading", percentage);
        blob = yield Fetcher.fetchBlob(url, onProgress, this.options.fetchParams);
      }
      this.setSrc(url, blob);
      if (channelData) {
        duration = (yield Promise.resolve(duration || this.getDuration())) || (yield new Promise((resolve) => {
          this.onceMediaEvent("loadedmetadata", () => resolve(this.getDuration()));
        })) || (yield Promise.resolve(0));
        this.decodedData = Decoder.createBuffer(channelData, duration);
      } else if (blob) {
        const arrayBuffer = yield blob.arrayBuffer();
        this.decodedData = yield Decoder.decode(arrayBuffer, this.options.sampleRate);
      }
      this.emit("decode", this.getDuration());
      if (this.decodedData) {
        this.renderer.render(this.decodedData);
      }
      this.emit("ready", this.getDuration());
    });
  }
  /** Load an audio file by URL, with optional pre-decoded audio data */
  load(url, channelData, duration) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.loadAudio(url, void 0, channelData, duration);
    });
  }
  /** Load an audio blob */
  loadBlob(blob, channelData, duration) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.loadAudio("blob", blob, channelData, duration);
    });
  }
  /** Zoom the waveform by a given pixels-per-second factor */
  zoom(minPxPerSec) {
    if (!this.decodedData) {
      throw new Error("No audio loaded");
    }
    this.renderer.zoom(minPxPerSec);
    this.emit("zoom", minPxPerSec);
  }
  /** Get the decoded audio data */
  getDecodedData() {
    return this.decodedData;
  }
  /** Get decoded peaks */
  exportPeaks({ channels = 1, maxLength = 8e3, precision = 1e4 } = {}) {
    if (!this.decodedData) {
      throw new Error("The audio has not been decoded yet");
    }
    const channelsLen = Math.min(channels, this.decodedData.numberOfChannels);
    const peaks = [];
    for (let i3 = 0; i3 < channelsLen; i3++) {
      const data = this.decodedData.getChannelData(i3);
      const length = Math.min(data.length, maxLength);
      const scale2 = data.length / length;
      const sampledData = [];
      for (let j2 = 0; j2 < length; j2++) {
        const n2 = Math.round(j2 * scale2);
        const val = data[n2];
        sampledData.push(Math.round(val * precision) / precision);
      }
      peaks.push(sampledData);
    }
    return peaks;
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    let duration = super.getDuration() || 0;
    if ((duration === 0 || duration === Infinity) && this.decodedData) {
      duration = this.decodedData.duration;
    }
    return duration;
  }
  /** Toggle if the waveform should react to clicks */
  toggleInteraction(isInteractive) {
    this.options.interact = isInteractive;
  }
  /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */
  seekTo(progress2) {
    const time = this.getDuration() * progress2;
    this.setTime(time);
  }
  /** Play or pause the audio */
  playPause() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  /** Stop the audio and go to the beginning */
  stop() {
    this.pause();
    this.setTime(0);
  }
  /** Skip N or -N seconds from the current position */
  skip(seconds) {
    this.setTime(this.getCurrentTime() + seconds);
  }
  /** Empty the waveform by loading a tiny silent audio */
  empty() {
    this.load("", [[0]], 1e-3);
  }
  /** Unmount wavesurfer */
  destroy() {
    this.emit("destroy");
    this.plugins.forEach((plugin) => plugin.destroy());
    this.subscriptions.forEach((unsubscribe) => unsubscribe());
    this.timer.destroy();
    this.renderer.destroy();
    super.destroy();
  }
}
class t3 {
  constructor() {
    this.listeners = {};
  }
  on(t4, e3) {
    return this.listeners[t4] || (this.listeners[t4] = /* @__PURE__ */ new Set()), this.listeners[t4].add(e3), () => this.un(t4, e3);
  }
  once(t4, e3) {
    const s5 = this.on(t4, e3), i3 = this.on(t4, () => {
      s5(), i3();
    });
    return s5;
  }
  un(t4, e3) {
    this.listeners[t4] && (e3 ? this.listeners[t4].delete(e3) : delete this.listeners[t4]);
  }
  unAll() {
    this.listeners = {};
  }
  emit(t4, ...e3) {
    this.listeners[t4] && this.listeners[t4].forEach((t5) => t5(...e3));
  }
}
class e2 extends t3 {
  constructor(t4) {
    super(), this.subscriptions = [], this.options = t4;
  }
  onInit() {
  }
  init(t4) {
    this.wavesurfer = t4, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((t4) => t4());
  }
}
const s4 = { lineWidth: 1, labelSize: 11 };
class i2 extends e2 {
  constructor(t4) {
    super(t4 || {}), this.unsubscribe = () => {
    }, this.onPointerMove = (t5) => {
      if (!this.wavesurfer)
        return;
      const e3 = this.wavesurfer.getWrapper().getBoundingClientRect(), { width: s5 } = e3, i3 = t5.clientX - e3.left, r3 = Math.min(1, Math.max(0, i3 / s5)), n2 = Math.min(s5 - this.options.lineWidth - 1, i3);
      this.wrapper.style.transform = `translateX(${n2}px)`, this.wrapper.style.opacity = "1";
      const o3 = this.wavesurfer.getDuration() || 0;
      this.label.textContent = this.formatTime(o3 * r3);
      const a4 = this.label.offsetWidth;
      this.label.style.transform = n2 + a4 > s5 ? `translateX(-${a4 + this.options.lineWidth}px)` : "", this.emit("hover", r3);
    }, this.onPointerLeave = () => {
      this.wrapper.style.opacity = "0";
    }, this.options = Object.assign({}, s4, t4), this.wrapper = document.createElement("div"), this.label = document.createElement("span"), this.wrapper.appendChild(this.label);
  }
  static create(t4) {
    return new i2(t4);
  }
  addUnits(t4) {
    return `${t4}${"number" == typeof t4 ? "px" : ""}`;
  }
  onInit() {
    if (!this.wavesurfer)
      throw Error("WaveSurfer is not initialized");
    const t4 = this.wavesurfer.options, e3 = this.options.lineColor || t4.cursorColor || t4.progressColor;
    this.wrapper.setAttribute("part", "hover"), Object.assign(this.wrapper.style, { position: "absolute", zIndex: 10, left: 0, top: 0, height: "100%", pointerEvents: "none", borderLeft: `${this.addUnits(this.options.lineWidth)} solid ${e3}`, opacity: "0", transition: "opacity .1s ease-in" }), this.label.setAttribute("part", "hover-label"), Object.assign(this.label.style, { display: "block", backgroundColor: this.options.labelBackground, color: this.options.labelColor, fontSize: `${this.addUnits(this.options.labelSize)}`, transition: "transform .1s ease-in", padding: "2px 3px" });
    const s5 = this.wavesurfer.getWrapper();
    s5.appendChild(this.wrapper), s5.addEventListener("pointermove", this.onPointerMove), s5.addEventListener("pointerleave", this.onPointerLeave), this.unsubscribe = () => {
      s5.removeEventListener("pointermove", this.onPointerMove), s5.removeEventListener("pointerleave", this.onPointerLeave);
    };
  }
  formatTime(t4) {
    return `${Math.floor(t4 / 60)}:${`0${Math.floor(t4) % 60}`.slice(-2)}`;
  }
  destroy() {
    super.destroy(), this.unsubscribe(), this.wrapper.remove();
  }
}
const Audio = ({ audioSnap, loadAudio, self: self2 }) => {
  const [audioUrl, setAudioUrl] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (loadAudio) {
      audioDb.getItem(audioSnap.id, (blob) => {
        if (blob) {
          const url = URL.createObjectURL(blob);
          setAudioUrl(url);
        } else {
          console.error("audio blob is empty, audioId:", audioSnap.id);
        }
      }).catch((e3) => {
        console.error("failed to get audio blob, audioId:", audioSnap.id, e3);
      });
    }
  }, [audioSnap.id, loadAudio]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Wave, { url: audioUrl, audioId: audioSnap.id, self: self2 });
};
const Wave = ({ url, audioId, self: self2 }) => {
  const playerSnap = useSnapshot(playerState);
  const wavesurfer = reactExports.useRef();
  const container = reactExports.useRef(null);
  const [amIPlaying, setAmIPlaying] = reactExports.useState(false);
  const color2 = self2 ? selfColor : assistantColor;
  reactExports.useEffect(() => {
    wavesurfer.current = WaveSurfer.create({
      container: container.current,
      waveColor: color2.wave,
      progressColor: color2.progress,
      cursorWidth: 0,
      barWidth: 4,
      barGap: 2,
      barRadius: 10,
      height: "auto",
      url,
      plugins: [
        i2.create({
          lineColor: color2.hoverLine,
          lineWidth: 1,
          labelBackground: color2.labelBg,
          labelColor: color2.label,
          labelSize: "11px"
        })
      ]
    });
    wavesurfer.current.on("interaction", () => {
      wavesurfer.current.play().catch((e3) => {
        console.error("can't play", e3);
      });
    });
    wavesurfer.current.on("play", () => {
      play(audioId);
    });
    wavesurfer.current.on("pause", () => {
      pause();
    });
    wavesurfer.current.on("finish", () => {
      onPrevFinish();
    });
    wavesurfer.current.on("destroy", () => {
      clear();
    });
    return () => {
      wavesurfer.current && wavesurfer.current.destroy();
    };
  }, [audioId, color2, url]);
  reactExports.useEffect(() => {
    setAmIPlaying(playerSnap.isPlaying && playerSnap.current === audioId);
  }, [audioId, playerSnap]);
  reactExports.useEffect(() => {
    if (wavesurfer.current) {
      if (amIPlaying) {
        if (!wavesurfer.current.isPlaying()) {
          wavesurfer.current.play();
        }
      } else {
        if (wavesurfer.current.isPlaying()) {
          wavesurfer.current.pause();
        }
      }
    }
  }, [amIPlaying]);
  const togglePlay = () => {
    if (!wavesurfer.current) {
      return;
    }
    if (wavesurfer.current.isPlaying()) {
      wavesurfer.current.pause();
    } else {
      wavesurfer.current.play().catch((e3) => {
        console.error("can't play", e3);
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex rounded-2xl items-center p-1 gap-2 " + color2.boxBg, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex justify-center items-center rounded-full w-10 h-10 shrink-0 " + color2.playBg,
        onClick: togglePlay,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { hidden: amIPlaying, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              fill: color2.play,
              viewBox: "0 0 24 24",
              className: "w-6 h-6",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  d: "M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { hidden: !amIPlaying, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              strokeWidth: 4,
              stroke: "currentColor",
              className: "w-6 h-6 " + color2.pause,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M15.75 5.25v13.5m-7.5-13.5v13.5" })
            }
          ) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: container, className: "w-full h-10" })
  ] });
};
const selfColor = {
  boxBg: "bg-blue-600",
  playBg: "bg-blue-grey",
  play: "white",
  pause: "text-white",
  wave: "rgb(128, 154, 241)",
  progress: "rgb(213, 221, 250)",
  hoverLine: "white",
  labelBg: "#94a3b8",
  label: "white"
};
const assistantColor = {
  boxBg: "bg-neutral-200",
  playBg: "bg-white",
  play: "#5e5e5e",
  pause: "text-neutral-500",
  wave: "#8c8c8c",
  progress: "#2f2f2f",
  hoverLine: "black",
  labelBg: "#d1d5db",
  label: "black"
};
var Component = {};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i3 = 0; i3 < selection.rangeCount; i3++) {
    ranges.push(selection.getRangeAt(i3));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  var debug, message, reselectPrevious, range, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e3) {
      e3.stopPropagation();
      if (options.format) {
        e3.preventDefault();
        if (typeof e3.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e3.clipboardData.clearData();
          e3.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e3.preventDefault();
        options.onCopy(e3.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range.selectNodeContents(mark);
    selection.addRange(range);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
Object.defineProperty(Component, "__esModule", {
  value: true
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault(reactExports);
var _copyToClipboard = _interopRequireDefault(copyToClipboard);
var _excluded = ["text", "onCopy", "options", "children"];
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(CopyToClipboard2, _React$PureComponent);
  var _super = _createSuper(CopyToClipboard2);
  function CopyToClipboard2() {
    var _this;
    _classCallCheck(this, CopyToClipboard2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
      var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
      var elem = _react["default"].Children.only(children);
      var result = (0, _copyToClipboard["default"])(text, options);
      if (onCopy) {
        onCopy(text, result);
      }
      if (elem && elem.props && typeof elem.props.onClick === "function") {
        elem.props.onClick(event);
      }
    });
    return _this;
  }
  _createClass(CopyToClipboard2, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.text;
      _this$props2.onCopy;
      _this$props2.options;
      var children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
      var elem = _react["default"].Children.only(children);
      return /* @__PURE__ */ _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);
  return CopyToClipboard2;
}(_react["default"].PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
var reactConfetti_min = { exports: {} };
(function(module, exports) {
  !function(t4, e3) {
    module.exports = e3(reactExports);
  }("undefined" != typeof self ? self : commonjsGlobal, function(t4) {
    return function(t5) {
      var e3 = {};
      function n2(r3) {
        if (e3[r3])
          return e3[r3].exports;
        var i3 = e3[r3] = { i: r3, l: false, exports: {} };
        return t5[r3].call(i3.exports, i3, i3.exports, n2), i3.l = true, i3.exports;
      }
      return n2.m = t5, n2.c = e3, n2.d = function(t6, e4, r3) {
        n2.o(t6, e4) || Object.defineProperty(t6, e4, { enumerable: true, get: r3 });
      }, n2.r = function(t6) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t6, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t6, "__esModule", { value: true });
      }, n2.t = function(t6, e4) {
        if (1 & e4 && (t6 = n2(t6)), 8 & e4)
          return t6;
        if (4 & e4 && "object" == typeof t6 && t6 && t6.__esModule)
          return t6;
        var r3 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r3), Object.defineProperty(r3, "default", { enumerable: true, value: t6 }), 2 & e4 && "string" != typeof t6)
          for (var i3 in t6)
            n2.d(r3, i3, (function(e5) {
              return t6[e5];
            }).bind(null, i3));
        return r3;
      }, n2.n = function(t6) {
        var e4 = t6 && t6.__esModule ? function() {
          return t6.default;
        } : function() {
          return t6;
        };
        return n2.d(e4, "a", e4), e4;
      }, n2.o = function(t6, e4) {
        return Object.prototype.hasOwnProperty.call(t6, e4);
      }, n2.p = "", n2(n2.s = 2);
    }([function(e3, n2) {
      e3.exports = t4;
    }, function(t5, e3, n2) {
      var r3 = { linear: function(t6, e4, n3, r4) {
        return (n3 - e4) * t6 / r4 + e4;
      }, easeInQuad: function(t6, e4, n3, r4) {
        return (n3 - e4) * (t6 /= r4) * t6 + e4;
      }, easeOutQuad: function(t6, e4, n3, r4) {
        return -(n3 - e4) * (t6 /= r4) * (t6 - 2) + e4;
      }, easeInOutQuad: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4 / 2) < 1 ? i3 / 2 * t6 * t6 + e4 : -i3 / 2 * (--t6 * (t6 - 2) - 1) + e4;
      }, easeInCubic: function(t6, e4, n3, r4) {
        return (n3 - e4) * (t6 /= r4) * t6 * t6 + e4;
      }, easeOutCubic: function(t6, e4, n3, r4) {
        return (n3 - e4) * ((t6 = t6 / r4 - 1) * t6 * t6 + 1) + e4;
      }, easeInOutCubic: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4 / 2) < 1 ? i3 / 2 * t6 * t6 * t6 + e4 : i3 / 2 * ((t6 -= 2) * t6 * t6 + 2) + e4;
      }, easeInQuart: function(t6, e4, n3, r4) {
        return (n3 - e4) * (t6 /= r4) * t6 * t6 * t6 + e4;
      }, easeOutQuart: function(t6, e4, n3, r4) {
        return -(n3 - e4) * ((t6 = t6 / r4 - 1) * t6 * t6 * t6 - 1) + e4;
      }, easeInOutQuart: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4 / 2) < 1 ? i3 / 2 * t6 * t6 * t6 * t6 + e4 : -i3 / 2 * ((t6 -= 2) * t6 * t6 * t6 - 2) + e4;
      }, easeInQuint: function(t6, e4, n3, r4) {
        return (n3 - e4) * (t6 /= r4) * t6 * t6 * t6 * t6 + e4;
      }, easeOutQuint: function(t6, e4, n3, r4) {
        return (n3 - e4) * ((t6 = t6 / r4 - 1) * t6 * t6 * t6 * t6 + 1) + e4;
      }, easeInOutQuint: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4 / 2) < 1 ? i3 / 2 * t6 * t6 * t6 * t6 * t6 + e4 : i3 / 2 * ((t6 -= 2) * t6 * t6 * t6 * t6 + 2) + e4;
      }, easeInSine: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return -i3 * Math.cos(t6 / r4 * (Math.PI / 2)) + i3 + e4;
      }, easeOutSine: function(t6, e4, n3, r4) {
        return (n3 - e4) * Math.sin(t6 / r4 * (Math.PI / 2)) + e4;
      }, easeInOutSine: function(t6, e4, n3, r4) {
        return -(n3 - e4) / 2 * (Math.cos(Math.PI * t6 / r4) - 1) + e4;
      }, easeInExpo: function(t6, e4, n3, r4) {
        return 0 == t6 ? e4 : (n3 - e4) * Math.pow(2, 10 * (t6 / r4 - 1)) + e4;
      }, easeOutExpo: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return t6 == r4 ? e4 + i3 : i3 * (1 - Math.pow(2, -10 * t6 / r4)) + e4;
      }, easeInOutExpo: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return 0 === t6 ? e4 : t6 === r4 ? e4 + i3 : (t6 /= r4 / 2) < 1 ? i3 / 2 * Math.pow(2, 10 * (t6 - 1)) + e4 : i3 / 2 * (2 - Math.pow(2, -10 * --t6)) + e4;
      }, easeInCirc: function(t6, e4, n3, r4) {
        return -(n3 - e4) * (Math.sqrt(1 - (t6 /= r4) * t6) - 1) + e4;
      }, easeOutCirc: function(t6, e4, n3, r4) {
        return (n3 - e4) * Math.sqrt(1 - (t6 = t6 / r4 - 1) * t6) + e4;
      }, easeInOutCirc: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4 / 2) < 1 ? -i3 / 2 * (Math.sqrt(1 - t6 * t6) - 1) + e4 : i3 / 2 * (Math.sqrt(1 - (t6 -= 2) * t6) + 1) + e4;
      }, easeInElastic: function(t6, e4, n3, r4) {
        var i3, o3, a4, c3 = n3 - e4;
        return a4 = 1.70158, 0 === t6 ? e4 : 1 == (t6 /= r4) ? e4 + c3 : ((o3 = 0) || (o3 = 0.3 * r4), (i3 = c3) < Math.abs(c3) ? (i3 = c3, a4 = o3 / 4) : a4 = o3 / (2 * Math.PI) * Math.asin(c3 / i3), -i3 * Math.pow(2, 10 * (t6 -= 1)) * Math.sin((t6 * r4 - a4) * (2 * Math.PI) / o3) + e4);
      }, easeOutElastic: function(t6, e4, n3, r4) {
        var i3, o3, a4, c3 = n3 - e4;
        return a4 = 1.70158, 0 === t6 ? e4 : 1 == (t6 /= r4) ? e4 + c3 : ((o3 = 0) || (o3 = 0.3 * r4), (i3 = c3) < Math.abs(c3) ? (i3 = c3, a4 = o3 / 4) : a4 = o3 / (2 * Math.PI) * Math.asin(c3 / i3), i3 * Math.pow(2, -10 * t6) * Math.sin((t6 * r4 - a4) * (2 * Math.PI) / o3) + c3 + e4);
      }, easeInOutElastic: function(t6, e4, n3, r4) {
        var i3, o3, a4, c3 = n3 - e4;
        return a4 = 1.70158, 0 === t6 ? e4 : 2 == (t6 /= r4 / 2) ? e4 + c3 : ((o3 = 0) || (o3 = r4 * (0.3 * 1.5)), (i3 = c3) < Math.abs(c3) ? (i3 = c3, a4 = o3 / 4) : a4 = o3 / (2 * Math.PI) * Math.asin(c3 / i3), t6 < 1 ? i3 * Math.pow(2, 10 * (t6 -= 1)) * Math.sin((t6 * r4 - a4) * (2 * Math.PI) / o3) * -0.5 + e4 : i3 * Math.pow(2, -10 * (t6 -= 1)) * Math.sin((t6 * r4 - a4) * (2 * Math.PI) / o3) * 0.5 + c3 + e4);
      }, easeInBack: function(t6, e4, n3, r4, i3) {
        return void 0 === i3 && (i3 = 1.70158), (n3 - e4) * (t6 /= r4) * t6 * ((i3 + 1) * t6 - i3) + e4;
      }, easeOutBack: function(t6, e4, n3, r4, i3) {
        return void 0 === i3 && (i3 = 1.70158), (n3 - e4) * ((t6 = t6 / r4 - 1) * t6 * ((i3 + 1) * t6 + i3) + 1) + e4;
      }, easeInOutBack: function(t6, e4, n3, r4, i3) {
        var o3 = n3 - e4;
        return void 0 === i3 && (i3 = 1.70158), (t6 /= r4 / 2) < 1 ? o3 / 2 * (t6 * t6 * ((1 + (i3 *= 1.525)) * t6 - i3)) + e4 : o3 / 2 * ((t6 -= 2) * t6 * ((1 + (i3 *= 1.525)) * t6 + i3) + 2) + e4;
      }, easeInBounce: function(t6, e4, n3, i3) {
        var o3 = n3 - e4;
        return o3 - r3.easeOutBounce(i3 - t6, 0, o3, i3) + e4;
      }, easeOutBounce: function(t6, e4, n3, r4) {
        var i3 = n3 - e4;
        return (t6 /= r4) < 1 / 2.75 ? i3 * (7.5625 * t6 * t6) + e4 : t6 < 2 / 2.75 ? i3 * (7.5625 * (t6 -= 1.5 / 2.75) * t6 + 0.75) + e4 : t6 < 2.5 / 2.75 ? i3 * (7.5625 * (t6 -= 2.25 / 2.75) * t6 + 0.9375) + e4 : i3 * (7.5625 * (t6 -= 2.625 / 2.75) * t6 + 0.984375) + e4;
      }, easeInOutBounce: function(t6, e4, n3, i3) {
        var o3 = n3 - e4;
        return t6 < i3 / 2 ? 0.5 * r3.easeInBounce(2 * t6, 0, o3, i3) + e4 : 0.5 * r3.easeOutBounce(2 * t6 - i3, 0, o3, i3) + 0.5 * o3 + e4;
      } };
      t5.exports = r3;
    }, function(t5, e3, n2) {
      t5.exports = n2(3);
    }, function(t5, e3, n2) {
      n2.r(e3), n2.d(e3, "ReactConfetti", function() {
        return Q3;
      });
      var r3, i3, o3 = n2(0), a4 = n2.n(o3), c3 = n2(1), s5 = n2.n(c3);
      function u3(t6, e4) {
        return t6 + Math.random() * (e4 - t6);
      }
      function f2(t6, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r4 = e4[n3];
          r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(t6, r4.key, r4);
        }
      }
      function h4(t6, e4, n3) {
        return e4 in t6 ? Object.defineProperty(t6, e4, { value: n3, enumerable: true, configurable: true, writable: true }) : t6[e4] = n3, t6;
      }
      !function(t6) {
        t6[t6.Circle = 0] = "Circle", t6[t6.Square = 1] = "Square", t6[t6.Strip = 2] = "Strip";
      }(r3 || (r3 = {})), function(t6) {
        t6[t6.Positive = 1] = "Positive", t6[t6.Negative = -1] = "Negative";
      }(i3 || (i3 = {}));
      var l2 = function() {
        function t6(e5, n4, r4, o4) {
          !function(t7, e6) {
            if (!(t7 instanceof e6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t6), h4(this, "context", void 0), h4(this, "radius", void 0), h4(this, "x", void 0), h4(this, "y", void 0), h4(this, "w", void 0), h4(this, "h", void 0), h4(this, "vx", void 0), h4(this, "vy", void 0), h4(this, "shape", void 0), h4(this, "angle", void 0), h4(this, "angularSpin", void 0), h4(this, "color", void 0), h4(this, "rotateY", void 0), h4(this, "rotationDirection", void 0), h4(this, "getOptions", void 0), this.getOptions = n4;
          var a5, c4, s6 = this.getOptions(), f3 = s6.colors, l3 = s6.initialVelocityX, p3 = s6.initialVelocityY;
          this.context = e5, this.x = r4, this.y = o4, this.w = u3(5, 20), this.h = u3(5, 20), this.radius = u3(5, 10), this.vx = "number" == typeof l3 ? u3(-l3, l3) : u3(l3.min, l3.max), this.vy = "number" == typeof p3 ? u3(-p3, 0) : u3(p3.min, p3.max), this.shape = (a5 = 0, c4 = 2, Math.floor(a5 + Math.random() * (c4 - a5 + 1))), this.angle = u3(0, 360) * Math.PI / 180, this.angularSpin = u3(-0.2, 0.2), this.color = f3[Math.floor(Math.random() * f3.length)], this.rotateY = u3(0, 1), this.rotationDirection = u3(0, 1) ? i3.Positive : i3.Negative;
        }
        var e4, n3;
        return e4 = t6, (n3 = [{ key: "update", value: function() {
          var t7 = this.getOptions(), e5 = t7.gravity, n4 = t7.wind, o4 = t7.friction, a5 = t7.opacity, c4 = t7.drawShape;
          this.x += this.vx, this.y += this.vy, this.vy += e5, this.vx += n4, this.vx *= o4, this.vy *= o4, this.rotateY >= 1 && this.rotationDirection === i3.Positive ? this.rotationDirection = i3.Negative : this.rotateY <= -1 && this.rotationDirection === i3.Negative && (this.rotationDirection = i3.Positive);
          var s6 = 0.1 * this.rotationDirection;
          if (this.rotateY += s6, this.angle += this.angularSpin, this.context.save(), this.context.translate(this.x, this.y), this.context.rotate(this.angle), this.context.scale(1, this.rotateY), this.context.rotate(this.angle), this.context.beginPath(), this.context.fillStyle = this.color, this.context.strokeStyle = this.color, this.context.globalAlpha = a5, this.context.lineCap = "round", this.context.lineWidth = 2, c4 && "function" == typeof c4)
            c4.call(this, this.context);
          else
            switch (this.shape) {
              case r3.Circle:
                this.context.beginPath(), this.context.arc(0, 0, this.radius, 0, 2 * Math.PI), this.context.fill();
                break;
              case r3.Square:
                this.context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
                break;
              case r3.Strip:
                this.context.fillRect(-this.w / 6, -this.h / 2, this.w / 3, this.h);
            }
          this.context.closePath(), this.context.restore();
        } }]) && f2(e4.prototype, n3), t6;
      }();
      function p2(t6, e4, n3) {
        return e4 in t6 ? Object.defineProperty(t6, e4, { value: n3, enumerable: true, configurable: true, writable: true }) : t6[e4] = n3, t6;
      }
      var v2 = function t6(e4, n3) {
        var r4 = this;
        !function(t7, e5) {
          if (!(t7 instanceof e5))
            throw new TypeError("Cannot call a class as a function");
        }(this, t6), p2(this, "canvas", void 0), p2(this, "context", void 0), p2(this, "getOptions", void 0), p2(this, "x", 0), p2(this, "y", 0), p2(this, "w", 0), p2(this, "h", 0), p2(this, "lastNumberOfPieces", 0), p2(this, "tweenInitTime", Date.now()), p2(this, "particles", []), p2(this, "particlesGenerated", 0), p2(this, "removeParticleAt", function(t7) {
          r4.particles.splice(t7, 1);
        }), p2(this, "getParticle", function() {
          var t7 = u3(r4.x, r4.w + r4.x), e5 = u3(r4.y, r4.h + r4.y);
          return new l2(r4.context, r4.getOptions, t7, e5);
        }), p2(this, "animate", function() {
          var t7 = r4.canvas, e5 = r4.context, n4 = r4.particlesGenerated, i5 = r4.lastNumberOfPieces, o4 = r4.getOptions(), a5 = o4.run, c4 = o4.recycle, s6 = o4.numberOfPieces, u4 = o4.debug, f3 = o4.tweenFunction, h5 = o4.tweenDuration;
          if (!a5)
            return false;
          var l3 = r4.particles.length, p3 = c4 ? l3 : n4, v3 = Date.now();
          if (p3 < s6) {
            i5 !== s6 && (r4.tweenInitTime = v3, r4.lastNumberOfPieces = s6);
            for (var y5 = r4.tweenInitTime, d5 = f3(v3 - y5 > h5 ? h5 : Math.max(0, v3 - y5), p3, s6, h5), b4 = Math.round(d5 - p3), g3 = 0; g3 < b4; g3++)
              r4.particles.push(r4.getParticle());
            r4.particlesGenerated += b4;
          }
          return u4 && (e5.font = "12px sans-serif", e5.fillStyle = "#333", e5.textAlign = "right", e5.fillText("Particles: ".concat(l3), t7.width - 10, t7.height - 20)), r4.particles.forEach(function(e6, n5) {
            e6.update(), (e6.y > t7.height || e6.y < -100 || e6.x > t7.width + 100 || e6.x < -100) && (c4 && p3 <= s6 ? r4.particles[n5] = r4.getParticle() : r4.removeParticleAt(n5));
          }), l3 > 0 || p3 < s6;
        }), this.canvas = e4;
        var i4 = this.canvas.getContext("2d");
        if (!i4)
          throw new Error("Could not get canvas context");
        this.context = i4, this.getOptions = n3;
      };
      function y4(t6, e4) {
        var n3 = Object.keys(t6);
        if (Object.getOwnPropertySymbols) {
          var r4 = Object.getOwnPropertySymbols(t6);
          e4 && (r4 = r4.filter(function(e5) {
            return Object.getOwnPropertyDescriptor(t6, e5).enumerable;
          })), n3.push.apply(n3, r4);
        }
        return n3;
      }
      function d4(t6) {
        for (var e4 = 1; e4 < arguments.length; e4++) {
          var n3 = null != arguments[e4] ? arguments[e4] : {};
          e4 % 2 ? y4(Object(n3), true).forEach(function(e5) {
            g2(t6, e5, n3[e5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(n3)) : y4(Object(n3)).forEach(function(e5) {
            Object.defineProperty(t6, e5, Object.getOwnPropertyDescriptor(n3, e5));
          });
        }
        return t6;
      }
      function b3(t6, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r4 = e4[n3];
          r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(t6, r4.key, r4);
        }
      }
      function g2(t6, e4, n3) {
        return e4 in t6 ? Object.defineProperty(t6, e4, { value: n3, enumerable: true, configurable: true, writable: true }) : t6[e4] = n3, t6;
      }
      var O3 = { width: "undefined" != typeof window ? window.innerWidth : 300, height: "undefined" != typeof window ? window.innerHeight : 200, numberOfPieces: 200, friction: 0.99, wind: 0, gravity: 0.1, initialVelocityX: 4, initialVelocityY: 10, colors: ["#f44336", "#e91e63", "#9c27b0", "#673ab7", "#3f51b5", "#2196f3", "#03a9f4", "#00bcd4", "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107", "#FF9800", "#FF5722", "#795548"], opacity: 1, debug: false, tweenFunction: s5.a.easeInOutQuad, tweenDuration: 5e3, recycle: true, run: true }, w3 = function() {
        function t6(e5, n4) {
          var r4 = this;
          !function(t7, e6) {
            if (!(t7 instanceof e6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t6), g2(this, "canvas", void 0), g2(this, "context", void 0), g2(this, "_options", void 0), g2(this, "generator", void 0), g2(this, "rafId", void 0), g2(this, "setOptionsWithDefaults", function(t7) {
            var e6 = { confettiSource: { x: 0, y: 0, w: r4.canvas.width, h: 0 } };
            r4._options = d4(d4(d4({}, e6), O3), t7), Object.assign(r4, t7.confettiSource);
          }), g2(this, "update", function() {
            var t7 = r4.options, e6 = t7.run, n5 = t7.onConfettiComplete, i5 = r4.canvas, o4 = r4.context;
            e6 && (o4.fillStyle = "white", o4.clearRect(0, 0, i5.width, i5.height)), r4.generator.animate() ? r4.rafId = requestAnimationFrame(r4.update) : (n5 && "function" == typeof n5 && r4.generator.particlesGenerated > 0 && n5.call(r4, r4), r4._options.run = false);
          }), g2(this, "reset", function() {
            r4.generator && r4.generator.particlesGenerated > 0 && (r4.generator.particlesGenerated = 0, r4.generator.particles = [], r4.generator.lastNumberOfPieces = 0);
          }), g2(this, "stop", function() {
            r4.options = { run: false }, r4.rafId && (cancelAnimationFrame(r4.rafId), r4.rafId = void 0);
          }), this.canvas = e5;
          var i4 = this.canvas.getContext("2d");
          if (!i4)
            throw new Error("Could not get canvas context");
          this.context = i4, this.generator = new v2(this.canvas, function() {
            return r4.options;
          }), this.options = n4, this.update();
        }
        var e4, n3;
        return e4 = t6, (n3 = [{ key: "options", get: function() {
          return this._options;
        }, set: function(t7) {
          var e5 = this._options && this._options.run, n4 = this._options && this._options.recycle;
          this.setOptionsWithDefaults(t7), this.generator && (Object.assign(this.generator, this.options.confettiSource), "boolean" == typeof t7.recycle && t7.recycle && false === n4 && (this.generator.lastNumberOfPieces = this.generator.particles.length)), "boolean" == typeof t7.run && t7.run && false === e5 && this.update();
        } }]) && b3(e4.prototype, n3), t6;
      }();
      function m4(t6) {
        return function(t7) {
          if (Array.isArray(t7))
            return C2(t7);
        }(t6) || function(t7) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(t7))
            return Array.from(t7);
        }(t6) || S4(t6) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function x2(t6) {
        return (x2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
          return typeof t7;
        } : function(t7) {
          return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
        })(t6);
      }
      function P2() {
        return (P2 = Object.assign || function(t6) {
          for (var e4 = 1; e4 < arguments.length; e4++) {
            var n3 = arguments[e4];
            for (var r4 in n3)
              Object.prototype.hasOwnProperty.call(n3, r4) && (t6[r4] = n3[r4]);
          }
          return t6;
        }).apply(this, arguments);
      }
      function j2(t6, e4) {
        var n3 = Object.keys(t6);
        if (Object.getOwnPropertySymbols) {
          var r4 = Object.getOwnPropertySymbols(t6);
          e4 && (r4 = r4.filter(function(e5) {
            return Object.getOwnPropertyDescriptor(t6, e5).enumerable;
          })), n3.push.apply(n3, r4);
        }
        return n3;
      }
      function M4(t6) {
        for (var e4 = 1; e4 < arguments.length; e4++) {
          var n3 = null != arguments[e4] ? arguments[e4] : {};
          e4 % 2 ? j2(Object(n3), true).forEach(function(e5) {
            T3(t6, e5, n3[e5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(n3)) : j2(Object(n3)).forEach(function(e5) {
            Object.defineProperty(t6, e5, Object.getOwnPropertyDescriptor(n3, e5));
          });
        }
        return t6;
      }
      function I3(t6, e4) {
        return function(t7) {
          if (Array.isArray(t7))
            return t7;
        }(t6) || function(t7, e5) {
          if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t7)))
            return;
          var n3 = [], r4 = true, i4 = false, o4 = void 0;
          try {
            for (var a5, c4 = t7[Symbol.iterator](); !(r4 = (a5 = c4.next()).done) && (n3.push(a5.value), !e5 || n3.length !== e5); r4 = true)
              ;
          } catch (t8) {
            i4 = true, o4 = t8;
          } finally {
            try {
              r4 || null == c4.return || c4.return();
            } finally {
              if (i4)
                throw o4;
            }
          }
          return n3;
        }(t6, e4) || S4(t6, e4) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function S4(t6, e4) {
        if (t6) {
          if ("string" == typeof t6)
            return C2(t6, e4);
          var n3 = Object.prototype.toString.call(t6).slice(8, -1);
          return "Object" === n3 && t6.constructor && (n3 = t6.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t6) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? C2(t6, e4) : void 0;
        }
      }
      function C2(t6, e4) {
        (null == e4 || e4 > t6.length) && (e4 = t6.length);
        for (var n3 = 0, r4 = new Array(e4); n3 < e4; n3++)
          r4[n3] = t6[n3];
        return r4;
      }
      function D3(t6, e4) {
        if (!(t6 instanceof e4))
          throw new TypeError("Cannot call a class as a function");
      }
      function E3(t6, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r4 = e4[n3];
          r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(t6, r4.key, r4);
        }
      }
      function _2(t6, e4) {
        return (_2 = Object.setPrototypeOf || function(t7, e5) {
          return t7.__proto__ = e5, t7;
        })(t6, e4);
      }
      function R3(t6) {
        var e4 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t7) {
            return false;
          }
        }();
        return function() {
          var n3, r4 = F2(t6);
          if (e4) {
            var i4 = F2(this).constructor;
            n3 = Reflect.construct(r4, arguments, i4);
          } else
            n3 = r4.apply(this, arguments);
          return k3(this, n3);
        };
      }
      function k3(t6, e4) {
        return !e4 || "object" !== x2(e4) && "function" != typeof e4 ? A2(t6) : e4;
      }
      function A2(t6) {
        if (void 0 === t6)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t6;
      }
      function F2(t6) {
        return (F2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t7) {
          return t7.__proto__ || Object.getPrototypeOf(t7);
        })(t6);
      }
      function T3(t6, e4, n3) {
        return e4 in t6 ? Object.defineProperty(t6, e4, { value: n3, enumerable: true, configurable: true, writable: true }) : t6[e4] = n3, t6;
      }
      var B3 = a4.a.createRef(), N2 = function(t6) {
        !function(t7, e5) {
          if ("function" != typeof e5 && null !== e5)
            throw new TypeError("Super expression must either be null or a function");
          t7.prototype = Object.create(e5 && e5.prototype, { constructor: { value: t7, writable: true, configurable: true } }), e5 && _2(t7, e5);
        }(o4, t6);
        var e4, n3, i4 = R3(o4);
        function o4(t7) {
          var e5;
          D3(this, o4);
          for (var n4 = arguments.length, r4 = new Array(n4 > 1 ? n4 - 1 : 0), c4 = 1; c4 < n4; c4++)
            r4[c4 - 1] = arguments[c4];
          return T3(A2(e5 = i4.call.apply(i4, [this, t7].concat(r4))), "canvas", a4.a.createRef()), T3(A2(e5), "confetti", void 0), e5.canvas = t7.canvasRef || B3, e5;
        }
        return e4 = o4, (n3 = [{ key: "componentDidMount", value: function() {
          if (this.canvas.current) {
            var t7 = q3(this.props)[0];
            this.confetti = new w3(this.canvas.current, t7);
          }
        } }, { key: "componentDidUpdate", value: function() {
          var t7 = q3(this.props)[0];
          this.confetti && (this.confetti.options = t7);
        } }, { key: "componentWillUnmount", value: function() {
          this.confetti && this.confetti.stop(), this.confetti = void 0;
        } }, { key: "render", value: function() {
          var t7 = I3(q3(this.props), 2), e5 = t7[0], n4 = t7[1], r4 = M4({ zIndex: 2, position: "absolute", pointerEvents: "none", top: 0, left: 0, bottom: 0, right: 0 }, n4.style);
          return a4.a.createElement("canvas", P2({ width: e5.width, height: e5.height, ref: this.canvas }, n4, { style: r4 }));
        } }]) && E3(e4.prototype, n3), o4;
      }(o3.Component);
      function q3(t6) {
        var e4 = {}, n3 = {}, r4 = [].concat(m4(Object.keys(O3)), ["confettiSource", "drawShape", "onConfettiComplete"]), i4 = ["canvasRef"];
        for (var o4 in t6) {
          var a5 = t6[o4];
          r4.includes(o4) ? e4[o4] = a5 : i4.includes(o4) ? i4[o4] = a5 : n3[o4] = a5;
        }
        return [e4, n3, {}];
      }
      T3(N2, "defaultProps", M4({}, O3)), T3(N2, "displayName", "ReactConfetti");
      var Q3 = a4.a.forwardRef(function(t6, e4) {
        return a4.a.createElement(N2, P2({ canvasRef: e4 }, t6));
      });
      e3.default = Q3;
    }]).default;
  });
})(reactConfetti_min);
var reactConfetti_minExports = reactConfetti_min.exports;
const Confetti = /* @__PURE__ */ getDefaultExportFromCjs(reactConfetti_minExports);
const RichOpText = ({ text, deleteFunc }) => {
  const [hovering, setHovering] = reactExports.useState(false);
  const [copied, setCopied] = reactExports.useState(false);
  const [confettiCount, setConfettiCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setCopied(false);
    }, 1e3);
    return () => {
      clearTimeout(timer);
    };
  }, [copied]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      onMouseOver: () => setHovering(true),
      onMouseLeave: () => setHovering(false),
      className: "relative rounded-2xl self-end max-w-3/4 whitespace-pre-wrap text-violet-100 bg-blue-600 px-2 py-1.5",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text }),
        confettiCount === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Confetti, { numberOfPieces: 500, wind: 0.02, recycle: false }, confettiCount),
        hovering && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "flex justify-center rounded-lg overflow-hidden items-center pointer-events-none absolute inset-x-0 -top-8 z-10 left-auto bg-black bg-opacity-0 backdrop-blur backdrop-filter",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                lib.CopyToClipboard,
                {
                  text,
                  onCopy: () => {
                    setCopied(true);
                    setConfettiCount(confettiCount + 1);
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "bg-neutral-400 bg-opacity-10 hover:bg-opacity-20 pointer-events-auto relative px-4 py-2 text-xs font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-50",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-400", children: "Copy" })
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: deleteFunc,
                  className: "bg-neutral-400 bg-opacity-10 hover:bg-opacity-20 pointer-events-auto relative px-4 py-2 text-xs\n                 font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-50",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-400", children: "Delete" })
                }
              )
            ]
          }
        )
      ]
    }
  );
};
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Error caught by ErrorBoundary:", error, errorInfo);
  }
  render() {
    var _a;
    if (this.state.hasError) {
      return (
        // todo put error on message box UI
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Something went wrong." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: (_a = this.state.error) == null ? void 0 : _a.message })
        ] })
      );
    }
    return this.props.children;
  }
}
const MessageList = ({ chatSnap }) => {
  const scrollRef = reactExports.useRef(null);
  const [shouldBeInHistory, setShouldBeInHistory] = reactExports.useState(/* @__PURE__ */ new Set());
  const [shouldLoadVoice, setShouldLoadVoice] = reactExports.useState(/* @__PURE__ */ new Set());
  reactExports.useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "instant" });
    }
  });
  reactExports.useEffect(() => {
    const messages = chatSnap.messages;
    const mh2 = chatSnap.option.llm.maxHistory;
    for (let i3 = messages.length - 1; i3 >= 0; i3--) {
      if (shouldBeInHistory.size >= mh2 && shouldLoadVoice.size >= maxLoadedVoice) {
        break;
      }
      if (messages[i3].status === "deleted") {
        continue;
      }
      if (shouldBeInHistory.size < mh2) {
        if (isInHistory(messages[i3])) {
          shouldBeInHistory.add(i3);
        }
      }
      if (shouldLoadVoice.size >= maxLoadedVoice) {
        if (messages[i3].audio) {
          shouldLoadVoice.add(i3);
        }
      }
    }
    setShouldBeInHistory(shouldBeInHistory);
    setShouldLoadVoice(shouldLoadVoice);
  }, [chatSnap, shouldBeInHistory, shouldLoadVoice]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-y-auto w-full scrollbar-hidden hover:scrollbar-visible", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5 rounded-lg w-full justify-end", children: chatSnap.messages.filter((msg) => msg.status !== "deleted").map(
      (msg, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1 mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Row,
        {
          chatId: chatSnap.id,
          messageSnap: msg,
          shouldBeInHistory: shouldBeInHistory.has(index2),
          shouldLoadAudio: shouldLoadVoice.has(index2)
        }
      ) }, msg.id)
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: scrollRef })
  ] });
};
const Row = ({
  chatId,
  messageSnap,
  shouldBeInHistory,
  shouldLoadAudio
}) => {
  const markAsDeleted = reactExports.useCallback(() => {
    markMessageAsDeleted(chatId, messageSnap.id);
  }, [chatId, messageSnap.id]);
  switch (messageSnap.status) {
  }
  let m4;
  if (messageSnap.audio) {
    m4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg max-w-1/2 md:max-w-2/5 w-full text-neutral-900 self-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Audio, { audioSnap: messageSnap.audio, self: messageSnap.role == "user", loadAudio: shouldLoadAudio }) });
  } else {
    m4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: shouldBeInHistory ? "border border-neutral-500 border-dashed" : "", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RichOpText, { deleteFunc: markAsDeleted, text: messageSnap.text }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: m4 });
};
const TextArea = ({ chatProxy }) => {
  const chatSnap = useSnapshot(chatProxy);
  const [inputAreaIsLarge, setInputAreaIsLarge] = reactExports.useState(false);
  const arrowButtonRef = reactExports.useRef(null);
  const sendButtonRef = reactExports.useRef(null);
  const textAreaRef = reactExports.useRef(null);
  const [isComposing, setIsComposing] = reactExports.useState(false);
  const stopPropagation = reactExports.useCallback((event) => {
    console.debug("stopPropagation", event.code);
    event.stopPropagation();
  }, []);
  const sendAndClearText = reactExports.useCallback(() => {
    var _a;
    if (sendButtonRef.current) {
      sendButtonRef.current.blur();
    }
    if (chatProxy.inputText) {
      controlState.sendingMessages.push({ chatId: chatSnap.id, text: chatSnap.inputText });
      controlState.sendingMessageSignal++;
      chatProxy.inputText = "";
    }
    (_a = textAreaRef.current) == null ? void 0 : _a.focus();
  }, [chatProxy, chatSnap.id, chatSnap.inputText]);
  const handleKeyDown = reactExports.useCallback((event) => {
    event.stopPropagation();
    if (isComposing) {
      return;
    } else if ((event.ctrlKey || event.metaKey) && event.code === "Enter") {
      sendAndClearText();
    } else if (event.code === "Escape") {
      if (textAreaRef.current) {
        textAreaRef.current.blur();
      }
    }
  }, [isComposing, sendAndClearText]);
  const handleCompositionStart = reactExports.useCallback(() => {
    console.debug("is composing");
    setIsComposing(true);
  }, []);
  const handleCompositionEnd = reactExports.useCallback(() => {
    console.debug("is not composing");
    setIsComposing(false);
  }, []);
  const handleClick = reactExports.useCallback(() => {
    setInputAreaIsLarge(!inputAreaIsLarge);
    if (arrowButtonRef) {
      arrowButtonRef.current.blur();
    }
  }, [inputAreaIsLarge]);
  reactExports.useEffect(() => {
    var _a, _b;
    if (inputAreaIsLarge) {
      (_a = textAreaRef.current) == null ? void 0 : _a.focus();
    } else {
      (_b = textAreaRef.current) == null ? void 0 : _b.blur();
    }
  }, [inputAreaIsLarge]);
  const autoGrowHeight = (e3) => {
    e3.currentTarget.style.height = "5px";
    e3.currentTarget.style.height = e3.currentTarget.scrollHeight + "px";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-full mt-auto bottom-0 max-w-4xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        ref: arrowButtonRef,
        className: "rounded-full flex items-center justify-center w-10 -mb-1 ",
        onClick: handleClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            strokeWidth: 1.5,
            stroke: "currentColor",
            className: "text-neutral-500 w-6 h-6 mb-0.5",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: inputAreaIsLarge ? "M19.5 8.25l-7.5 7.5-7.5-7.5" : "M4.5 15.75l7.5-7.5 7.5 7.5"
              }
            )
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          ref: textAreaRef,
          className: "w-full outline-0 rounded-xl resize-none bg-white pl-2 py-1 lg:p-3 mt-auto\n                        placeholder:text-neutral-500 placeholder:select-none min-h-24 max-h-[30rem]",
          onKeyUp: stopPropagation,
          value: chatSnap.inputText,
          onInput: autoGrowHeight,
          onChange: (e3) => chatProxy.inputText = e3.target.value,
          onKeyDown: handleKeyDown,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          placeholder: "Message"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          ref: sendButtonRef,
          className: "-ml-8 mb-1 self-end capitalize text-neutral-600 ",
          onClick: sendAndClearText,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              fill: "none",
              viewBox: "0 0 24 24",
              strokeWidth: "2",
              stroke: "currentColor",
              className: "w-6 h-6",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  d: "M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5"
                }
              )
            }
          )
        }
      )
    ] })
  ] });
};
const Recorder = ({ chatId }) => {
  const [isRecording, setIsRecording] = reactExports.useState(false);
  const [recordDuration, setRecordDuration] = reactExports.useState(0);
  const [context, setContext] = reactExports.useState(void 0);
  const recorder = controlState.recorder;
  reactExports.useEffect(() => {
    const startListener = (ctx) => {
      setContext(ctx);
      setIsRecording(true);
    };
    const doneListener = (blob, duration, ctx) => {
      setContext(ctx);
      setIsRecording(false);
      controlState.sendingMessages.push(
        {
          chatId,
          text: "",
          audioBlob: blob,
          durationMs: duration
        }
      );
      controlState.sendingMessageSignal++;
    };
    const cancelListener = (_blob, _duration, ctx) => {
      setContext(ctx);
      setIsRecording(false);
    };
    recorder.addStartListener(startListener);
    recorder.addDoneListener(doneListener);
    recorder.addCancelListener(cancelListener);
    return () => {
      recorder.removeStartListener(startListener);
      recorder.removeDoneListener(doneListener);
      recorder.removeCancelListener(cancelListener);
    };
  }, [recorder, setIsRecording, setContext, chatId]);
  reactExports.useEffect(() => {
    let interval;
    if (isRecording) {
      interval = setInterval(() => {
        setRecordDuration(recorder.currentRecordingDuration());
      }, 50);
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [isRecording, recorder, setRecordDuration]);
  const handleClickStart = reactExports.useCallback(() => {
    console.debug("handleClickStart");
    recorder.start({ triggeredBy: "click" }).catch(
      (e3) => {
        console.error("failed to start recorder", e3);
      }
    );
  }, [recorder]);
  const handleClickDone = reactExports.useCallback(() => {
    console.debug("handleClickDone");
    recorder.done();
  }, [recorder]);
  const handleTouchStart = reactExports.useCallback(() => {
    console.debug("handleTouchStart");
    recorder.start({ triggeredBy: "touch" }).catch((e3) => {
      console.error("failed to start recorder", e3);
    });
  }, [recorder]);
  const handleTouchEnd = reactExports.useCallback(() => {
    var _a;
    console.debug("handleTouchEnd");
    if (((_a = recorder.currentContext()) == null ? void 0 : _a.triggeredBy) === "touch") {
      recorder.done();
    }
  }, [recorder]);
  const handleTouchCancel = reactExports.useCallback(() => {
    var _a;
    console.debug("handleTouchCancel");
    if (((_a = recorder.currentContext()) == null ? void 0 : _a.triggeredBy) === "touch") {
      recorder.cancel();
    }
  }, [recorder]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      onTouchStart: handleTouchStart,
      onTouchEnd: handleTouchEnd,
      onTouchCancel: handleTouchCancel,
      className: "rounded-lg w-full select-none",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: handleClickStart,
            className: cx("flex gap-3 justify-center items-center", isRecording ? "hidden" : ""),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  strokeWidth: "1.5",
                  stroke: "currentColor",
                  className: "w-7 h-7 text-neutral-600",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      d: "M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "prose text-lg text-neutral-600", children: [
                "Hold ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden sm:inline rounded-md text-neutral-700 bg-white opacity-70 px-1.5", children: "Spacebar" }),
                " to speak"
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: handleClickDone,
            className: cx("flex justify-evenly items-center", isRecording ? "" : "hidden"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "hidden sm:block overflow-hidden whitespace-nowrap text-neutral-500 text-sm bg-white rounded-full px-2 " + ((context == null ? void 0 : context.triggeredBy) === "spacebar" ? "" : "hidden"),
                  children: [
                    "Press any key to ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline text-red-400", children: "cancel" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 24 24",
                    fill: "currentColor",
                    className: "w-7 h-7 text-rose-500",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.25 4.5a3.75 3.75 0 117.5 0v8.25a3.75 3.75 0 11-7.5 0V4.5z" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          d: "M6 10.5a.75.75 0 01.75.75v1.5a5.25 5.25 0 1010.5 0v-1.5a.75.75 0 011.5 0v1.5a6.751 6.751 0 01-6 6.709v2.291h3a.75.75 0 010 1.5h-7.5a.75.75 0 010-1.5h3v-2.291a6.751 6.751 0 01-6-6.709v-1.5A.75.75 0 016 10.5z"
                        }
                      )
                    ]
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "prose text-xl text-rose-500 rounded-lg px-2", children: timeElapsedMMSS(recordDuration) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "hidden sm:block overflow-hidden whitespace-nowrap text-neutral-500 text-sm bg-white rounded-full px-2 " + ((context == null ? void 0 : context.triggeredBy) === "spacebar" ? "" : "hidden"),
                  children: [
                    "Release to ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline text-blue-500", children: "send" })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const ChatWindow = () => {
  const appSnap = useSnapshot(appState);
  const [chatProxy, setChatProxy] = reactExports.useState(void 0);
  const [chatSnap, setChatSnap] = reactExports.useState(void 0);
  reactExports.useEffect(() => {
    const cp = appState.chats[appState.currentChatId];
    setChatProxy(cp);
    const snap = appSnap.chats[appSnap.currentChatId];
    setChatSnap(snap);
  }, [appSnap.chats, appSnap.currentChatId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col items-center max-w-4xl w-full h-full rounded-xl justify-between gap-1 p-2\n                    bg-white bg-opacity-40 backdrop-blur",
      children: [
        chatSnap === void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}),
        chatSnap !== void 0 && chatProxy !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageList, { chatSnap }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "bottom-0 mt-auto flex w-full flex-col items-center gap-2 rounded-xl px-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TextArea, { chatProxy }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1 flex w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Recorder, { chatId: chatProxy.id }) })
              ]
            }
          )
        ] })
      ]
    }
  );
};
const DEVTOOLS = Symbol();
function devtools(proxyObject, options) {
  if (typeof options === "string") {
    console.warn(
      "string name option is deprecated, use { name }. https://github.com/pmndrs/valtio/pull/400"
    );
    options = { name: options };
  }
  const { enabled, name = "", ...rest } = options || {};
  let extension;
  try {
    extension = (enabled != null ? enabled : ({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && enabled) {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({ name, ...rest });
  const unsub1 = subscribe(proxyObject, (ops) => {
    const action = ops.filter(([_2, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(".")}`).join(", ");
    if (!action) {
      return;
    }
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));
      delete snapWithoutDevtools[DEVTOOLS];
      devtools2.send(
        {
          type: action,
          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()
        },
        snapWithoutDevtools
      );
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c, _d, _e, _f;
    if (message.type === "ACTION" && message.payload) {
      try {
        Object.assign(proxyObject, JSON.parse(message.payload));
      } catch (e3) {
        console.error(
          "please dispatch a serializable value that JSON.parse() and proxy() support\n",
          e3
        );
      }
    }
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
        const state = JSON.parse(message.state);
        Object.assign(proxyObject, state);
      }
      proxyObject[DEVTOOLS] = message;
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({ state }, index2) => {
        const action = actions[index2] || "No action found";
        Object.assign(proxyObject, state);
        if (index2 === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2 == null ? void 0 : unsub2();
  };
}
const unsDevTools = [
  devtools(appState, { name: "appState", enabled: true }),
  devtools(hydrationState, { name: "hydrationState", enabled: true }),
  devtools(controlState, { name: "controlState", enabled: true }),
  devtools(networkState, { name: "controlState", enabled: true })
];
function Home() {
  const hydrationSnap = useSnapshot(hydrationState);
  reactExports.useEffect(() => {
    return () => unsDevTools.forEach((it) => it == null ? void 0 : it());
  }, []);
  return hydrationSnap.hydrated ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WallpaperSimultaneousCounter, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex h-screen w-screen items-center justify-center gap-2 overflow-hidden p-3 home lg:gap-5",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden sm:block h-full min-w-60 max-w-86", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Panel, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChatWindow, {})
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SSE, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Workers, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WindowListeners, {})
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
}
const expState = proxy(
  {
    clicked: 0,
    person: {
      name: "kate",
      age: 50
    }
  }
);
const PersonWindow = ({ personProxy }) => {
  const personSnp = useSnapshot(personProxy);
  const addMyOwnName = reactExports.useCallback(() => {
    personProxy.name += "x";
  }, [personProxy]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col justify-center items-center w-1/2 h-1/2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: addMyOwnName, children: "addMyOwnName" }),
      "name: ",
      personSnp.name
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      "age: ",
      personProxy.age
    ] })
  ] });
};
const Experiment = () => {
  const addClicked = reactExports.useCallback(() => {
    expState.clicked++;
  }, []);
  const personAddAge = reactExports.useCallback(() => {
    expState.person.age++;
  }, []);
  const changePerson = reactExports.useCallback(() => {
    expState.person = {
      name: "jack",
      age: 1999
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center w-screen h-screen bg-neutral-400 ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center w-1/2 h-1/2 gap-10", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col justify-center items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: addClicked,
          children: [
            "add clicked: ",
            expState.clicked
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: changePerson,
          children: "change person"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: personAddAge,
          children: "add age"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PersonWindow, { personProxy: expState.person })
  ] }) });
};
const router = createBrowserRouter([
  {
    path: "/",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}),
    errorElement: /* @__PURE__ */ jsxRuntimeExports.jsx(Error$1, {})
  },
  {
    path: "/auth",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(Auth, {}),
    errorElement: /* @__PURE__ */ jsxRuntimeExports.jsx(Error$1, {})
  },
  {
    path: "/chat",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}),
    errorElement: /* @__PURE__ */ jsxRuntimeExports.jsx(Error$1, {})
  },
  {
    path: "/exp",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(Experiment, {}),
    errorElement: /* @__PURE__ */ jsxRuntimeExports.jsx(Error$1, {})
  }
]);
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) })
);
//# sourceMappingURL=index-6617c495.js.map
